[{"title":"该开始读书了","url":"/2024/03/18/该开始读书了/","content":"\n\n\n\n## 什么值得读\n\n\n今天发现了一个有趣的网站，叫 [什么值得读](https://www.shenmezhidedu.com/)，网站中分门别类的列举了很多书单，同时，左侧的菜单栏中还有不同的功能模块。我没有一一的去看，只是看了认知觉醒一栏的三篇文章。![img](https://img-blog.csdnimg.cn/img_convert/067d49a772be61af5c1c80b58e1fcfd1.png) [经常看书的人和不看书的人有什么区别](https://www.shenmezhidedu.com/jinri/haowen/5884.html)这篇文章中讲述了奶头乐理论。简而言之就是，**为了减少全球被剥削的80%的人对20%剥削者的恶意，上层人通过使用快速的娱乐，比如短视频，游戏，小说等来麻痹这些人，让他们丧失独立思考的能力。**\n 我承认**我确实和文中作者说的一样**，沉迷于短视频，小说等无法获取到知识的娱乐中很久了，仔细想来，我已经对梦想这种词汇极为陌生。\n 其实在一个月前，我也尝试过重新拾起阅读的习惯，不过坚持了几天，最后还是放弃了。一是确实很少有属于自己的时间，每天上班到八点，回家之后和女朋友看剧（没有怪女朋友的意思，因为我也享受其中）。二是平常看书的时间基本上在地铁上，不方便阅读纸质书，阅读媒介基本上是微信阅读和番茄免费小说。看着看着，就容易被其他东西给带跑偏（比如游戏，小说）。\n 其实之前也一样，每次想养成一个什么样的习惯，最后都会因为自控力不够中道崩殂。\n 仔细想来，还没有成功做成什么事情。\n\n\n\n## 作者的建议\n\n为了抵抗娱乐对人的控制，作者提了一下几点建议：\n\n1. **控制花在娱乐内容上的时间**\n\n包括但不限于**肤浅的书籍、影视、综艺节目、游戏，娱乐圈资讯**。\n 他们的肤浅体现在内容，他们把最厉害的技术用在吸引你上面，反复调节的色彩，苦思冥想的标题，不断优化的用户体验，让你**一旦进入就无法自拔**，沉溺其中。\n 如果你还没有接触，那么不要接触；如果你已经接触，可以有意识的控制减少。\n 这类内容在消费的时候很爽，但像垃圾食品一样，占有你大量的精力和心思，让你再也没有动力主动学习，做困难的事情。\n\n1. **为你的人生制定一个目标**\n\n没有目标的人生，就像没有方向的船。飘荡在海上，不知去往何方；\n 为自己制定一个目标，并在脑海中想象达成后的画面，越具体越清晰越好；\n 想想当目标实现后，它能带给你的快乐，带给你的改变；\n 这样你就有充足的动力去实现这个目标，不要怕目标高远，像白日梦。如果连做梦都不敢，还能做什么呢？\n 有了目标后就制定计划，日拱一卒，每天朝目标前进一点点，能往前就决不后退。\n 记住：再牛逼的梦想也抵不住傻逼似的坚持。\n\n1. **培养一两个有益身心的兴趣爱好**\n\n有趣的人都会有有趣的爱好，这个兴趣爱好可以让你**在工作的繁忙后恢复活力**，结识到更多的良师益友，找到自己的天赋点，对自己更有自信。\n 这个兴趣能够为你提供能量，不管是情绪上的还是身体上的，能够帮助你更好的达成目标。可以是 [读书](https://www.shenmezhidedu.com/tag/%e8%af%bb%e4%b9%a6)、学一样乐器、坚持健身或者写作。\n 同时，要尽量规律性的培养兴趣，养成习惯。\n 为什么要养成习惯呢？因为即使有再大的兴趣，在不断深入、重复的过程中，也会使你感到枯燥。而人的意志力是有限的，就像辛苦认真工作了一天，在下班后会控制不住的大吃大喝，随意购物一样。**而当一个行为成为习惯之后，会有效的减少意志力的消耗，有助于长期持续。****越是长期的兴趣，越是能够给你带来意想不到的收获。**\n\n1. **挑选好书，持续阅读**\n\n读一本好书，就像在与作者对话，穿越了时间和空间的距离，触达知识的源头。\n 与什么样的人交流，你就会有什么样的思想，他们在潜移默化的影响着你。\n 如果你的交流对象只有心胸狭隘，不思进取的俗人，那么久而久之，你可能也变成了这样。\n 如果你的交流对象都是经过时间长河检验的巨人，那么久而久之，你就可以站在巨人的肩膀上看的更远。\n 为自己挑选值得读的好书，不仅是专业上的，还有非专业的。那些能够引发你思考，帮助你蜕变的书籍。\n 接着就开始 [阅读](https://www.shenmezhidedu.com/tag/%e9%98%85%e8%af%bb)吧～即使每天10分钟，坚持100天，你会发现自己的变化！\n\n\n\n## 我的想法\n\n我打算遵循作者的建议\n\n1. **减少没有营养的娱乐**，从今天开始不刷短视频（包括b站，小红书，懂车帝）。停止之前的网络小说的阅读。\n2. 制定目标： \n <ol>\n  2. 每个月阅读完一本书，并输出读书笔记。\n  2. 制定一个学习计划。\n  2. 制定每月计划，包括学习计划，读书计划等。\n </ol>\n6. 培养兴趣：我现在还没想好能培养什么兴趣爱好，我之前一直想学画画，但是显而易见，一直没有成功。实际上我有点想学钢琴，之后搬家到苏州后，我可能会买一个电钢琴，学习钢琴吧。这一项暂且搁置\n7. 读书：如3，制定读书计划。\n\n","tags":["学习","读书笔记"]},{"title":"html入门笔记","url":"/2024/03/18/html入门笔记/","content":"\n\n这是是在wuyxinu大佬的笔记里摘抄的，去掉了一些对我自己而言不怎么用得着的部分\n 原笔记网址：http://t.csdn.cn/rEZHo\n\n## 一、简介\n\n### 1、前端开发最核心技术\n\n(1)HTML\n\nHTML，全称“Hyper Text Markup Language（超文本标记语言）”\n\n(2)CSS\n\nCSS，全称“（层叠样式表）”\n\n(3)JavaScript\n\n### 2、前端开发其他技术\n\n(1)Ajax\n\nAjax，即“Asynchronous Javascript And XML（异步JavaScript和XML）”，是指一种创建交互式网页应用的网页开发技术。\n\n可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用Ajax）如果需要更新内容，必须重载整个页面。\n\n(2)SEO\n\nSEO，即“Search Engine Optimization（搜索引擎优化）”。利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式\n\n## 二、基础内容\n\n### 1.基础总结\n\nHTML基本结构：\n\n\n![img](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5sdnllc3R1ZHkuY29tL0FwcF9pbWFnZXMvbGVzc29uL2hqLzMtMS0xLnBuZw?x-oss-process=image/format,png)\n\n### 2.HTML的基本标签\n\n#### (1)HTML标签\n\n整个网页是从这里开始的，然后到结束。\n\n#### (2)head标签\n\nhead标签代表页面的“头”，定义一些特殊内容，这些内容往往都是“不可见内容”（在浏览器不可见）。\n\n\n#### (3)body标签\n\n代表页面的“身”，定义网页展示内容，这些内容往往都是“可见内容”（在浏览器可见）。\n\n后续课程讲解的标签都是在标签内部的各种标签。\n\n### 3、段落与文字\n\n#### (一)、段落标签\n\n**(1)、段落与文字标签**\n\n\n**(2)、文本格式化标签**\n\n\n#### (二)、网页特殊符号\n\n#### (三)、自闭合标签\n\nHTML标签分为2种，一种是“一般标签”，另外一种是“自闭合标签”。一般标签有开始符号和结束符号，自闭合标签只有开始符号没有结束符号。\n\n一般标签可以在开始符号和结束符号之间插入其他标签或文字。\n\n自闭合标签由于没有结束符号，不能插入其他标签或文字，只能定义自身的属性。\n\n**(1)、一般标签**\n\n举例：\n\n**(2)、自闭合标签**\n\n举例：<br/>、<hr/>\n\n#### (四)、块元素和行内元素\n\n(1)、HTML元素根据浏览器表现形式分为两类：①块元素；②行内元素；\n\n(2)、块元素特点：\n\n（1）独占一行，排斥其他元素跟其位于同一行，包括块元素和行内元素；\n （2）块元素内部可以容纳其他块元素或行元素；\n 常见块元素有：h1~h6、p、hr、div等。\n\n(3)、行内元素特点：\n\n（1）可以与其他行内元素位于同一行；\n （2）行内内部可以容纳其他行内元素，但不可以容纳块元素，不然会出现无法预知的效果；\n 常见行内元素有：strong、em、span等。\n\n### 4、列表\n\n**(1)、有序列表**\n\n```java\n<ol>\n    <li>有序列表项</li>\n    <li>有序列表项</li>\n    <li>有序列表项</li>\n</ol>\n```\n\n**(2)、无序列表**\n\n```java\n<ul  type=\"列表项符号\">\n    <li>无序列表项</li>\n    <li>无序列表项</li>\n    <li>无序列表项</li>\n</ul>\n```\n\n### 5、表格\n\n#### (一)、表格语义记忆\n\n1 表格基本标签：\n\n\n2 表格结构标签：\n\n\n#### (二)、表格基本结构\n\n```java\n<table>\n    <tr>\n        <td>单元格1</td>\n        <td>单元格2</td>\n    </tr>\n    <tr>\n        <td>单元格1</td>\n        <td>单元格2</td>\n    </tr>\n</table>\n```\n\n#### (三)、表格完整结构\n\n```java\n<table>\n    <caption>表格标题</caption>\n    <!--表头-->\n    <thead>\n        <tr>\n            <th>表头单元格1</th>\n    <th>表头单元格2</th>\n        </tr>\n    </thead>\n    <!--表身-->\n    <tbody>\n        <tr>\n            <td>标准单元格1</td>\n            <td>标准单元格2</td>\n        </tr>\n        <tr>\n            <td>标准单元格1</td>\n            <td>标准单元格2</td>\n        </tr>\n    </tbody>\n    <!--表脚-->\n    <tfoot>\n        <tr>\n            <td>标准单元格1</td>\n            <td>标准单元格2</td>\n        </tr>\n    </tfoot>\n</table>\n```\n\n### 6、图像\n\n#### (一)、图像标签\n\n在HTML中，图像标签为。是一个自闭合标签。 [img标签](http://www.lvyestudy.com/les_hj/hj_7.1.aspx)只需要掌握3个属性就可以了：src、alt、title。\n\n语法：\n\n<img src=\"图片地址\" alt=\"图片描述（给搜索引擎看）\" title=\"图片描述（给用户看）\">\n\nalt:图片显示不出来时的提示文字\n\ntitle:鼠标移到图片上的提示文字\n\n#### (二)、相对路径和绝对路径\n\n相对路径，指的是同一个网站下，不同文件之间的的位置定位。引用的文件位置是相对当前文件的位置而言，从而得到相对路径。\n\n绝对路径，指的是文件的完整路径。\n\n详细复习内容，请查看 [相对路径和绝对路径](http://www.lvyestudy.com/les_hj/hj_7.2.aspx)。\n\n### 7、链接\n\n超链接使用 [a标签](http://www.lvyestudy.com/les_hj/hj_8.2.aspx)，语法如下：\n\n\n#### target属性值：\n\n1 _self：默认方式，即在当前窗口打开链接\n\n2 _blank：在一个全新的空白窗口中打开链接\n\n#### href\n\n超链接根据链接对象的不同分为：\n\n**（1）外部链接**\n\n从自己的网站跳转到别人的网站\n\n**（2）内部链接：**\n\n①内部页面链接；\n\n在自己的网站中，网页之间相互跳转。<a href=\"a.html\" target=\"_blank\">跳转到a.html</a>\n\n②锚点链接；\n\n跳转到当前网页指定的位置\n\n先给要跳转的位置标签设置id属性\n\n在a标签的href属性中写#id\n\n```java\n<h2 id=“one”>第一层</h2>\n<a href=\"#one\">去第一层</a>\n```\n\n**（3）空链接**\n\n当还没有想好跳转到哪里时,在href中写#号。写一个#号会回到本网页的顶部，写两个#号单击了链接也不发生变化。\n\n```java\n<a href=\"#\">回到本网页的顶部</a>\n<a href=\"##\">单击了链接也不发生变化</a>\n```\n\n### 8、表单\n\n表单标签共有4个：、、和。其中和是配合使用的。\n\n#### (一)、input标签表单\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/8595c9fd77ab2ca0bf3276a54682736a.png)\n\n#### (二)、textarea标签表单\n\n```java\n<textarea rows=\"行数\" cols=\"列数\">多行文本框内容</textarea>\n```\n\n#### (三)、select和option\n\n```java\n<select multiple=\"mutiple\" size=\"可见列表项的数目\">\n    <option value=\"选项值\" selected=\"selected\">选项显示的内容</option>\n    ……\n    <option value=\"选项值\">选项显示的内容</option>\n</select>\n```\n\nhttps://blog.csdn.net/wuyxinu/article/details/103583618#t13\n\n","tags":["前端","html","css"]},{"title":"html中元素的隐藏，以及用jquery来显示和隐藏元素","url":"/2024/03/18/html中元素的隐藏，以及用jquery来显示和隐藏元素/","content":"\n\n添加一个属性：style=\"display:none;\"\n\n```java\n<td id=\"tdTest\" style=\"display:none;\">//默认隐藏\n<input type=\"text\" id=\"inputtest\">//默认显示\n<script>\n    //显示td\n    $(\"#tdTest\").show();\n    //隐藏td和input\n    $(\"#tdTest\").hide();\n    $(\"#inputtest\").hide();\n    //显示input\n    $(\"#inputtest\").show();\n    \n    //注：除此之外，表单元素还可以通过type属性来隐藏\n\t//隐藏input\n     $(\"#inputtest\").attr(\"type\",\"hidden\");\n</script>\n```\n\n","tags":["前端","html","jquery"]},{"title":"typora设置高亮快捷键","url":"/2024/03/18/typora设置高亮快捷键/","content":"\n\n#### 自定义快捷键\n\n1. 偏好设置-通用-高级设置-打开高级设置\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/455646e62f0ed7a670859db04e4cb147.png)\n\n1. 打开conf.user.json\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/572d9922bc20ceba608820bd58ac9b58.png)\n\n1. 找到keyBinding\n2. 在keyBinding中添加\"Highlight\": \"Ctrl + g\"\n\n```java\n\"keyBinding\": {\n    // for example: \n    // \"Always on Top\": \"Ctrl+Shift+P\"\n    \"Highlight\": \"Ctrl + g\" \n  },\n```\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/132475d90f07c6125c6086f399b0dc5e.png)\n\n1. 重启typora，完成\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/0a596751df3beef112f15776f80e0a28.png)\n\n","tags":["java","开发工具","学习"]},{"title":"一行指令关闭windows特定端口，解决端口被占用问题","url":"/2024/03/18/一行指令关闭windows特定端口，解决端口被占用问题/","content":"\n\n#### 1：一条代码\n\n```java\nGet-Process -Id (Get-NetTCPConnection -LocalPort 10001).OwningProcess | Stop-Process -Force\n```\n\n注意：get-process命令需要打开Powershell终端才能运行\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/afdf2fc85c7e6274e56129ae0b43c5d8.png)\n\n**解释：**\n\n- \n 这是一条 PowerShell 命令，用于根据本地端口号查找对应的进程并强制结束它。下面是该命令的详细解释：\n <ul>\n  - \n   Get-NetTCPConnection -LocalPort 10001：使用 Get-NetTCPConnection 命令查找本地使用 10001 端口的 TCP 连接。该命令返回了与该端口相关联的网络连接（如果有）。-LocalPort 参数指定要查找的本地端口号。\n  - \n   (Get-NetTCPConnection -LocalPort 10001).OwningProcess：从上一条命令的输出中取出 OwningProcess 属性的值，即与本地端口相关联的进程 ID。\n  - \n   Get-Process -Id：使用 Get-Process 命令查找与指定的进程 ID 相关联的进程对象。\n  - \n   | Stop-Process -Force：使用管道将输出传递给 Stop-Process 命令，强制结束指定的进程。-Force 参数表示强制结束进程，即使进程不响应也要结束。\n </ul>\n 因此，该命令的作用是：查找本地端口号为 10001 的 TCP 连接，并通过该连接的 OwningProcess 属性获取进程 ID，然后使用 Get-Process 命令获取该进程对象，并将其传递给 Stop-Process 命令来强制结束该进程。这可以在需要停止指定端口上的进程时很有用。\n\n因此，这个命令的意思是：使用 netstat 工具查找所有使用 10001 端口的连接，并将每个连接的进程 ID 作为参数传递给 taskkill 命令，以便强制结束该进程。可以用类似其他端口的情况使用，只需要替换 “10001” 为想要查找和终止进程的端口号即可。\n\n#### 2：普通方法\n\n我要关闭10001端口的进程：\n\n```java\nnetstat -ano|findstr \"10001\"\n```\n\n结果：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/fa0ce3e30a84e4aa8a38340b76fce07b.png)\n\n5928就是使用这个端口的进程编码，我们关闭这个端口：\n\n```java\ntaskkill /f /pid 5928\n```\n\n搞定\n\n","tags":["一键系列","windows","网络"]},{"title":"linux学习之二基础命令篇","url":"/2024/03/18/linux学习之二基础命令篇/","content":"\n\n## 一 linux的目录结构\n\n### 学习目标\n\n>1 掌握linux系统的目录结构\n\n### linux的目录结构\n\n\nLinux的目录结构是一个树型结构\n Windows 系统可以拥有多个盘符, 如 C盘、D盘、E盘\n Linux没有盘符这个概念, 只有一个根目录 /, 所有文件都在它下面![img](https://img-blog.csdnimg.cn/7ae9f2547cd84ccbb28ad850e8f8d5d0.png)\n\n### Linux路径的描述方式\n\n- 在Linux系统中，路径之间的层级关系，使用：/ 来表示\n- 在Windows系统中，路径之间的层级关系，使用： \\ 来表示**windows:**\n\n\n![img](https://img-blog.csdnimg.cn/72602aa5526f481a8004e72d8a4c5d0d.png)**D:\\data\\work\\hello.txt**\n\n- 注意：\n- D:表示D盘\n- \\表示层级关系\n\n\n**linux:**![img](https://img-blog.csdnimg.cn/da1ffc24bcf64bd3a7b5901de6c41c0c.png)**/usr/local/hello.txt**\n\n- 注意：\n- 开头的/表示根目录\n- 后面的/表示层级关系\n\n### 总结\n\n1. Linux操作系统的目录结构\n    Linux只有一个顶级目录，称之为：根目录\n    Windows系统有多个顶级目录，即各个盘符\n<li>在Linux系统中表示\n    出现在开头的/表示：根目录\n    出现在后面的/表示：层次关系</li>\n\n### 课后练习\n\n请根据语言描述，写出对应的Linux路径\n\n- 在根目录下有一个文件夹test，文件夹内有一个文件hello.txt，请描述文件的路径\n  /test/hello.txt\n- 在根目录下有一个文件itheima.txt，请描述文件的路径\n  /itheima.txt\n- 在根目录下有一个文件夹itcast，在itcast文件夹内有文件夹itheima，在itheima文件夹内有文件hello.txt，请描述文件的路径\n  /itcast/itheima/hello.txt\n\n## 二 linux命令入门\n\n### linux命令基础格式\n\n无论是什么命令，用于什么用途，在Linux中，命令有其通用的格式：command [-options] [parameter]\n\n- command： 命令本身\n- -options：[可选，非必填]命令的一些选项，可以通过选项控制命令的行为细节\n- parameter：[可选，非必填]命令的参数，多数用于命令的指向目标等\n\n *语法中的[]，表示可选的意思* \n\n### ls命令\n\nls命令的作用是列出目录下的内容，语法细节如下：ls [-a -l -h] [linux路径]\n\n\n- -a -l -h 是可选的选项\n- Linux路径是此命令可选的参数\n  当不使用选项和参数，直接使用ls命令本体，表示：以平铺形式，列出当前工作目录下的内容![img](https://img-blog.csdnimg.cn/c09af8949939427a9fe7f38eb8017bda.png)\n\n### home目录和工作目录\n\n\n直接输入ls命令，表示列出当前工作目录下的内容，当前工作目录是？![img](https://img-blog.csdnimg.cn/c09af8949939427a9fe7f38eb8017bda.png)\n Linux系统的命令行终端，在启动的时候，默认会加载:\n\n- 当前登录用户的HOME目录作为当前工作目录，所以ls命令列出的是HOME目录的内容\n- HOME目录：每个Linux操作用户在Linux系统的个人账户目录，路径在：/home/用户名 \n <ul>\n  - 如，图中的Linux用户是root，其HOME目录是：/home/root\n  - Windows系统和Linux系统，均设有用户的HOME目录，如图：\n </ul>\n\n\n\n![img](https://img-blog.csdnimg.cn/3e4d8500ce054f2bb173d6e9f1af8dd5.png)![img](https://img-blog.csdnimg.cn/dd7ae71dafb34eeb82eea490840c1ae6.png)\n\n### ls命令的参数\n\n\n刚刚展示了，直接使用ls命令，并未使用选项和参数。\n 那么ls的选项和参数具体有什么作用呢？首先我们先来看参数。\n 当ls不使用参数，表示列出：当前工作目录的内容，即用户的HOME目录\n 当使用参数，ls命令的参数表示：指定一个Linux路径，列出指定路径的内容\n 如![img](https://img-blog.csdnimg.cn/8872dbcbaedb41318ab5e07e74261ca8.png)\n 通过ls / 列出了根目录的内容\n\n### ls命令的选项\n\n\n\n- -a选项，表示：all的意思，即列出全部文件（包含隐藏的文件/文件夹）\n- -l选项，表示：以列表（竖向排列）的形式展示内容，并展示更多信息\n- -h 表示以易于阅读的形式，列出文件大小，如K、M、G\n- -h选项必须要搭配 -l 一起使用![img](https://img-blog.csdnimg.cn/5c97357073f04df18fa62e8183866fa3.png)\n  -l -h 搭配使用![img](https://img-blog.csdnimg.cn/e5d2238ecf0748da8e750c9fadc0d6dc.png)\n\n>注：<br>\n 语法中的选项是可以组合使用的，比如学习的-a和-l可以组合应用。\n\n### 总结\n\n1. Linux命令的基础格式command [options] [parameter]\n2. ls命令的语法和作用\n\n- command [-a -l -h] [linux路径]\n- -a列出全部内容、-l以列表展示、-h更易读的大小显示\n- 参数表示要列出内容的路径，不提供即列出当前工作目录内容\n\n1. 当前工作目录和HOME目录\n\n- Linux终端（命令行）启动后默认价值HOME目录作为当前工作的目录\n- HOME目录指：用户在系统内的专属目录\n\n1. 隐藏文件\\文件夹\n\n- 在Linux系统中，以”.”开头的文件\\文件夹会自动隐藏\n  只有通过-a选项才可以展示出来\n\n## 三 目录切换相关命令\n\n### cd切换工作目录当Linux终端（命令行）打开的时候，会默认以用户的HOME目录作为当前的工作目录\n\n我们可以通过cd命令，更改当前所在的工作目录。\n cd命令来自英文：Change Directory\n 语法： cd [linux路径]\n\n\n- cd命令无需选项，只有参数，表示要切换到哪个目录下\n- cd命令直接执行，不写参数，表示回到用户的HOME目录![img](https://img-blog.csdnimg.cn/de9907a5214745958cd664b19168f48a.png)\n\n","tags":["linux","学习","服务器"]},{"title":"一句代码获取当前时间的字符串`","url":"/2024/03/18/一句代码获取当前时间的字符串/","content":"\n\n直接用这段代码就可以\n\n```java\nString.valueOf(new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()))\n```\n\nyyyy-MM-dd处自定义时间的格式\n 如写yyyy-MM-dd HH:mm:ss就可以获得2022-12-31 17:11:51\n 写yyyyMMdd就可以获得20221231\n\n","tags":["java","java日常"]},{"title":"idea从新建一个maven项目到打包成可运行jar包全流程","url":"/2024/01/03/idea从新建一个maven项目到打包成可运行jar包全流程/","content":"\n\n## 1 创建maven项目\n\n\n\n\n点击new-project![img](https://img-blog.csdnimg.cn/img_convert/704c9673bce6b313687ff1d8a706dc25.png)\n 选择左侧的maven Archetype\n 修改Name，JDK，Catalog，Archetype（org.apache.maven.archetypes:maven-archetype-webapp）为下图中配置![img](https://img-blog.csdnimg.cn/img_convert/02fe39c93f5a882d62bd9113362419a8.png)\n 修改地址（自选），版本号（自选），之后店家create![img](https://img-blog.csdnimg.cn/img_convert/af45dccc7d8fcf029d87919fb0c42a18.png)\n\n## 2 配置maven\n\n\n在settings中找到下图中maven的位置，并自定义maven包，点击apply![img](https://img-blog.csdnimg.cn/img_convert/81718d7ed06cf9d010b902bf2ee1e37d.png)\n\n## 3 完善项目结构\n\n\n\n在src文件夹右击，分别点击New，DIrectory![img](https://img-blog.csdnimg.cn/img_convert/ee3559ccb24b71a018cc31586d7f0207.png)\n 把下面四个各选一遍![img](https://img-blog.csdnimg.cn/img_convert/91a3d1948cab604f6d0fa26e3ec8eebd.png)\n\n## 4 编写代码\n\n\n\n\n这里我将我之前的笔记 [自制java工具实现 ctrl+c+c 翻译鼠标选中文本](http://t.csdnimg.cn/uKNQs)的代码放入项目中:\n 依赖：![img](https://img-blog.csdnimg.cn/img_convert/d0b4a1bd8c243c2ea9778fac0c0bf89a.png)\n 项目结构：![img](https://img-blog.csdnimg.cn/img_convert/ec3df5be3731736e85408676ef6232dd.png)\n 运行成功：![img](https://img-blog.csdnimg.cn/img_convert/56c6886e15fb4ed75b6004891366ed3a.png)\n\n## 5 打包成可执行文件\n\n\n\npom中packaging中的war修改成jar![img](https://img-blog.csdnimg.cn/img_convert/08e392e816bb75fe6ac462e9c72ff9ac.png)\n 删除pom文件中，默认生成的build![img](https://img-blog.csdnimg.cn/img_convert/96518ff062d85f05ee63081c778e86d4.png)\n 粘贴下面的build配置\n\n```java\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-assembly-plugin</artifactId>\n      <executions>\n        <execution>\n          <phase>package</phase>\n          <goals>\n            <goal>single</goal>\n          </goals>\n          <configuration>\n            <archive>\n              <manifest>\n                <!--                  填写你的main方法所在的主类-->\n                <mainClass>\n                  com.ice.CtrlCCTranslate.GlobalKeyListenerExample\n                </mainClass>\n              </manifest>\n            </archive>\n            <descriptorRefs>\n              <descriptorRef>jar-with-dependencies</descriptorRef>\n            </descriptorRefs>\n          </configuration>\n        </execution>\n      </executions>\n    </plugin>\n  </plugins>\n</build>\n```\n\n\n\n点击下面的Terminal，运行mvn clean package![img](https://img-blog.csdnimg.cn/img_convert/861926d45e7ed5550fb3b078f6bb837d.png)\n BUILD SUCCESS![img](https://img-blog.csdnimg.cn/img_convert/f7c80b7775806dc324d37ee47d4623df.png)\n\n## 6 运行可执行文件\n\n\n\n到项目下的target文件夹中找到文件名长的那个jar包，双击运行![img](https://img-blog.csdnimg.cn/img_convert/f6e2d0f37782ec132e110daa1f38802e.png)\n 运行成功：![img](https://img-blog.csdnimg.cn/img_convert/a4b2842465553872e0f8924468325664.png)\n\n","tags":["java日常","java开发使用技巧","intellij-idea","maven","jar"]},{"title":"自制java工具实现 ctrl+c+c 翻译鼠标选中文本","url":"/2024/01/02/自制java工具实现 ctrl+c+c 翻译鼠标选中文本/","content":"\n\n## 前言\n\n>本功能的实现基于这篇笔记 <a href=\"http://t.csdnimg.cn/1I8ln\" rel=\"nofollow\">http://t.csdnimg.cn/1I8ln</a>，本文阅读过程中有疑惑都可以查看此笔记\n\n>实现思路：检测到按压ctrl +c +c 后，获取当前剪切板文字，调用百度翻译api。\n\n>实现结果：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/ff245149703b143ded382a531038fd40.gif)\n\n>完整代码在最后\n\n## 实现过程\n\n### 1 监控ctrl +c +c\n\n\n\n\n\n\n在当前demo的功能中我们可以看到，当按压键盘时会调用nativeKeyPressed方法，并会打印当前按下的按钮字符串。![img](https://img-blog.csdnimg.cn/img_convert/2d88df6e2dfc1217d8e251da0b734d80.png)\n 我们去掉一些打印的干扰：去除release和type的打印，以及press打印的前缀![img](https://img-blog.csdnimg.cn/img_convert/9705a1498f4aae7ec9c1c78e06b4d2a9.png)\n 此时就只会打印我们的按键![img](https://img-blog.csdnimg.cn/img_convert/aae9d4cc19f29ecedb77ffafe69638b1.png)\n 现在去实现：**当连续按压ctrl+c+c时，打印\"你按下了ctrl+c+c哦\"**\n 思路：初始设置一个key字符串为\"“,当检测到按压ctrl时，设置key为\"Ctrl”，当不是Ctrl时，key拼接本次按压的按键，然后和\"CtrlCC\"做比较。如果相同，则说明用户连续按压了ctrl+c+c；**代码实现**（红框内为添加的代码）：![img](https://img-blog.csdnimg.cn/img_convert/bedef91c497647cf9b5f53de643e7f42.png)**效果：**![img](https://img-blog.csdnimg.cn/img_convert/282cfcd5fab9e67796ebf9db239ce244.png)\n\n### 2 获取剪切板内容\n\n在我们进行ctrl+c+c的操作过程中，第一个ctrl+c就会将鼠标选择的内容放到剪切板里，此时我们获取剪切板的内容，之后再用这个内容调用翻译api即可。**创建一个剪切板工具类**\n\n```java\n/**\n * 剪切板工具类\n */\npublic class ClipBoardUtil {\n    public static String getClipboardText() {\n        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n        //从系统剪切板中获取数据\n        Transferable content = clipboard.getContents(null);\n        //判断是否为文本类型\n        if (content.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n            //从数据中获取文本值\n            String text = null;\n            try {\n                text = (String) content.getTransferData(DataFlavor.stringFlavor);\n            }  catch (Exception e) {\n\n            }\n            if (text == null) {\n                return \"剪切板为空\";\n            }\n            return text;\n        }\n        return \"剪切板无文本值\";\n    }\n}\n```\n\n\n\n**在代码中调用：**![img](https://img-blog.csdnimg.cn/img_convert/dab93c7cbfe1e1e221bd34461a849625.png)**效果：**![img](https://img-blog.csdnimg.cn/img_convert/e7922afe5131bb4c6473a67f631a1bbd.png)\n\n### 3 调用百度翻译api\n\n#### 注册账号，开通服务\n\n\n\n\n搜索百度翻译开放平台，注册账号，实名认证后，可以申请高级版用户\n 标准版：注册，未实名\n 高级版：注册，实名\n 尊享版：企业认证![img](https://img-blog.csdnimg.cn/img_convert/a7740099af16cd7b04ed41d02e7cb7db.png)\n 高级版每个月有100万字符的免费调用量，对于个人使用的话绰绰有余了。\n 注册后，在管理控制台中开通文本翻译服务![img](https://img-blog.csdnimg.cn/img_convert/219f1d5ae73f721423c8951356603742.jpeg)**详细见文档**：![img](https://img-blog.csdnimg.cn/img_convert/aa5c02e92d8d851a99ecc9421865d94b.png)\n\n#### 根据文档，编写代码\n\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/1d27860a70ff11627a4ff7df2b0a9fd3.png)\n 其中appid和密钥，在我们的管理控制台中![img](https://img-blog.csdnimg.cn/img_convert/8f8b995eec4b322945d0e67ea0d1b8d4.png)\n 以下是调用方法的代码实现，我们创建一个TransApi类\n\n```java\nimport cn.hutool.crypto.digest.DigestUtil;\nimport cn.hutool.http.HttpUtil;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class TransApi {\n    private static final String TRANS_API_HOST = \"http://api.fanyi.baidu.com/api/trans/vip/translate\";\n    private String appid;\n    private String securityKey;\n\n    /**\n     * 有参构造\n     * @param appid appid\n     * @param securityKey 密钥\n     */\n    public TransApi(String appid, String securityKey) {\n        this.appid = appid;\n        this.securityKey = securityKey;\n    }\n    \n    /**\n     * 调用方法\n     * @param query 翻译内容\n     * @param from 来源语言\n     * @param to 翻译语言\n     * @return 返回参数\n     */\t\n    public String getTransResult(String query, String from, String to) {\n        Map<String, Object> params = this.buildParams(query, from, to);\n        return HttpUtil.get(\"http://api.fanyi.baidu.com/api/trans/vip/translate\", params);\n    }\n\n    /**\n     * 初始化参数\n     * @param query 翻译内容\n     * @param from 来源语言\n     * @param to 翻译语言\n     * @return\n     */\n    private Map<String, Object> buildParams(String query, String from, String to) {\n        Map<String, Object> params = new HashMap();\n        params.put(\"q\", query);\n        params.put(\"from\", from);\n        params.put(\"to\", to);\n        params.put(\"appid\", this.appid);\n        String salt = String.valueOf(System.currentTimeMillis());\n        params.put(\"salt\", salt);\n        String src = this.appid + query + salt + this.securityKey;\n        //MD5加密\n        params.put(\"sign\", DigestUtil.md5Hex(src));\n        return params;\n    }\n}\n```\n\n其中调用接口的HttpUtil和加密的DigestUtil使用的是hutool中的类\n hutool包的地址：\n\n```java\n<dependency>\n  <groupId>cn.hutool</groupId>\n  <artifactId>hutool-all</artifactId>\n  <version>5.8.24</version>\n</dependency>\n```\n\n#### ctrl+c+c获取剪切板内容并调用翻译接口\n\n\n\n在GlobalKeyListenerExample类中添加TransApi类的初始化：![img](https://img-blog.csdnimg.cn/img_convert/ab42880b2223f2a1717257a024e8f792.png)\n 在获取剪切板内容后，将剪切板的内容调用翻译接口，并**处理返回数据**![img](https://img-blog.csdnimg.cn/img_convert/ee7dbbd6929a42dbe278da245d894cea.png)\n\n#### 运行效果\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/daa04cb114e95551f535b18f8735a7f7.png)\n 我们看到这里，已经初步完成了**ctrl+c+c进行翻译**的功能，剩下的就是进行一些小优化，如生成窗口展示数据\n\n### 4 小窗口展示剪切板内容和翻译内容\n\n因为笔者对java的gui窗口不是很了解，这里使用chatgpt工具生成了小窗口，可能有些简陋，读者可以自己美化一下\n 新建一个MyWindows类\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class MyWindow extends JFrame {\n\n    private JTextArea textArea;\n\n    public MyWindow() {\n        setTitle(\"Text Window\");\n        setSize(400, 300);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        textArea = new JTextArea();\n        //设置字体大小\n        textArea.setFont(new Font(\"SimSun\", Font.PLAIN, 16));\n        // 自动换行\n        textArea.setLineWrap(true);\n        // 断行不断字\n        textArea.setWrapStyleWord(true);\n        JPanel panel = new JPanel();\n\n        setVisible(true);\n        add(textArea, \"Center\");\n        add(panel, \"South\");\n    }\n\n    //写入文本\n    public void writeText(String text) {\n        textArea.append(text + \"\\n\");\n    }\n    //清楚文本\n    public void clearText() {\n        textArea.setText(\"\");\n    }\n\n    public static void main(String[] args) {\n        MyWindow window = new MyWindow();\n        window.setVisible(true);\n    }\n}\n```\n\n\n\n\n在GlobalKeyListenerExample类中初始化MyWindow：![img](https://img-blog.csdnimg.cn/img_convert/2dfe3308c6c16d9d99949cf0fde61c29.png)\n 在获取翻译后，清除原来的文字，写入新的文字：![img](https://img-blog.csdnimg.cn/img_convert/56d29b77a5fdc44fcdb76ae08b6d1cd4.png)\n 运行：![img](https://img-blog.csdnimg.cn/img_convert/ff245149703b143ded382a531038fd40.gif)\n\n## 完整代码\n\nClipBoardUtil类，TransApi类，MyWindow类上文已給出完整代码。GlobalKeyListenerExample类：\n\n```java\nimport cn.hutool.core.text.UnicodeUtil;\nimport cn.hutool.json.JSONObject;\nimport cn.hutool.json.JSONUtil;\nimport com.github.kwhat.jnativehook.GlobalScreen;\nimport com.github.kwhat.jnativehook.NativeHookException;\nimport com.github.kwhat.jnativehook.keyboard.NativeKeyEvent;\nimport com.github.kwhat.jnativehook.keyboard.NativeKeyListener;\nimport com.icepeach.Utils.ClipBoardUtil;\nimport com.icepeach.Utils.GUI.MyWindow;\n\n\npublic class GlobalKeyListenerExample implements NativeKeyListener {\n    String key = \"\";\n    private static final String APP_ID = \"你的appid\";\n    private static final String SECURITY_KEY = \"你的密钥\";\n    TransApi api = new TransApi(APP_ID, SECURITY_KEY);\n    MyWindow window = new MyWindow();\n\n    public void nativeKeyPressed(NativeKeyEvent e) {\n\n\n        if (\"Ctrl\".equals(NativeKeyEvent.getKeyText(e.getKeyCode()))) {\n            key = new String(\"Ctrl\");\n        } else {\n            key += NativeKeyEvent.getKeyText(e.getKeyCode());\n        }\n\n        if (\"CtrlCC\".equals(key)) {\n            window.setVisible(true);\n            //打印剪切板内容\n            System.out.println(\"剪切板内容为：\" + ClipBoardUtil.getClipboardText());\n            //调用翻译接口\n            String jsonStr = api.getTransResult(ClipBoardUtil.getClipboardText(), \"auto\", \"zh\");\n            // 解析JSON字符串\n            JSONObject jsonObject = JSONUtil.parseObj(jsonStr);\n            // 获取trans_result数组中的第一个元素\n            JSONObject transResult = jsonObject.getJSONArray(\"trans_result\").getJSONObject(0);\n            // 获取dst中的内容并转换成中文\n            String dst = transResult.getStr(\"dst\");\n            String chineseDst = UnicodeUtil.toString(dst);\n\n            System.out.println(\"翻译:\"+chineseDst);\n\n\n            window.clearText();\n            window.writeText(\"剪切板内容为：\" + ClipBoardUtil.getClipboardText());\n            window.writeText(\"翻译:\"+chineseDst);\n\n        }\n        if (e.getKeyCode() == NativeKeyEvent.VC_ESCAPE) {\n            try {\n                GlobalScreen.unregisterNativeHook();\n            } catch (NativeHookException nativeHookException) {\n                nativeHookException.printStackTrace();\n            }\n        }\n    }\n\n    public void nativeKeyReleased(NativeKeyEvent e) {\n//        System.out.println(\"Key Released: \" + NativeKeyEvent.getKeyText(e.getKeyCode()));\n    }\n\n    public void nativeKeyTyped(NativeKeyEvent e) {\n//        System.out.println(\"Key Typed: \" + e.getKeyText(e.getKeyCode()));\n    }\n\n    public static void main(String[] args) {\n        try {\n            GlobalScreen.registerNativeHook();\n        } catch (NativeHookException ex) {\n            System.err.println(\"There was a problem registering the native hook.\");\n            System.err.println(ex.getMessage());\n\n            System.exit(1);\n        }\n\n        GlobalScreen.addNativeKeyListener(new GlobalKeyListenerExample());\n    }\n}\n```\n\n","tags":["java","java日常","计算机外设","学习"]},{"title":"java全局监听键盘","url":"/2024/01/02/java全局监听键盘/","content":"\n\n## 前言\n\n>在github上看一些开源的项目时，常常有一些英文单词和句子需要翻译，当前的翻译软件以及划词插件，多少都有一些弊端。比如翻译软件过于臃肿，划词插件只能在浏览器中使用，且不需要使用翻译功能时也会出现。\n\n>deepl有一个ctrl+c+c自动悬浮翻译的功能，比较能满足我的需求，但很多时候因为deepl的悬浮翻译框都是在旋转的状态，网络上检索时，说是因为服务器问题。好吧。\n\n>于是想自己写一个小工具，实现deepl ctrl+c+c翻译的功能。\n\njava中的监听键盘的api，必须先创建一个窗口，且鼠标聚焦在该窗口中才能使用，无法实现我全局监听键盘的需求，于是在一番检索之后，找到了以下两个开源项目。system-hook： [https://github.com/kristian/system-hook](https://github.com/kristian/system-hook)jnativehook： [https://github.com/kwhat/jnativehook](https://github.com/kwhat/jnativehook)\n 比较后，我选择了jnativehook,因为这个项目维护的较好，同时还有全局鼠标，全局鼠标滚轮等功能。\n\n>ctrl+c+c翻译实现见这篇笔记：<a href=\"http://t.csdnimg.cn/See4F\" rel=\"nofollow\">http://t.csdnimg.cn/See4F</a><br>\n 本文只介绍全局监听键盘实现方法\n\n## 使用方法\n\n在maven中添加地址：\n\n```java\n<dependency>\n  <groupId>com.github.kwhat</groupId>\n  <artifactId>jnativehook</artifactId>\n  <version>2.2.2</version>\n</dependency>\n```\n\n\n\n在项目主页找到demo代码：![img](https://img-blog.csdnimg.cn/img_convert/107972ecbcd5cab16c2e290374d83fc4.png)![img](https://img-blog.csdnimg.cn/img_convert/2237299f22ea0e1a5a972718ac253250.png)\n\n```java\nimport com.github.kwhat.jnativehook.GlobalScreen;\nimport com.github.kwhat.jnativehook.NativeHookException;\nimport com.github.kwhat.jnativehook.keyboard.NativeKeyEvent;\nimport com.github.kwhat.jnativehook.keyboard.NativeKeyListener;\n\npublic class GlobalKeyListenerExample implements NativeKeyListener {\n\tpublic void nativeKeyPressed(NativeKeyEvent e) {\n\t\tSystem.out.println(\"Key Pressed: \" + NativeKeyEvent.getKeyText(e.getKeyCode()));\n\n\t\tif (e.getKeyCode() == NativeKeyEvent.VC_ESCAPE) {\n            \t\ttry {\n                \t\tGlobalScreen.unregisterNativeHook();\n            \t\t} catch (NativeHookException nativeHookException) {\n                \t\tnativeHookException.printStackTrace();\n            \t\t}\n        \t}\n\t}\n\n\tpublic void nativeKeyReleased(NativeKeyEvent e) {\n\t\tSystem.out.println(\"Key Released: \" + NativeKeyEvent.getKeyText(e.getKeyCode()));\n\t}\n\n\tpublic void nativeKeyTyped(NativeKeyEvent e) {\n\t\tSystem.out.println(\"Key Typed: \" + e.getKeyText(e.getKeyCode()));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tGlobalScreen.registerNativeHook();\n\t\t}\n\t\tcatch (NativeHookException ex) {\n\t\t\tSystem.err.println(\"There was a problem registering the native hook.\");\n\t\t\tSystem.err.println(ex.getMessage());\n\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\tGlobalScreen.addNativeKeyListener(new GlobalKeyListenerExample());\n\t}\n}\n```\n\n\n运行后按键：![img](https://img-blog.csdnimg.cn/img_convert/c00aecbfe6a882f293abf1a8055fc544.png)\n\n## 方法解析\n\n1. nativeKeyPressed:当键盘上的某个键被按下时，这个函数会被调用。它首先打印出被按下的键的文本信息，然后检查是否是\"Escape\"键(即VC_ESCAPE常量的值),如果是，就尝试注销全局键盘钩子。如果在注销过程中发生异常，就会捕获并打印这个异常。\n2. nativeKeyReleased:当键盘上的某个键被释放时，这个函数会被调用。它打印出被释放的键的文本信息。\n3. nativeKeyTyped:当键盘上的某个键被输入时，这个函数会被调用。它打印出被输入的键的文本信息。\n\n## 总结\n\n当可以监听到键盘按键后，就可以实现一些对应的功能，比如开头说的**ctrl+c+c **翻译鼠标选中内容，或者按键模拟乐器等。\n\n","tags":["java","java日常","计算机外设","开发语言"]},{"title":"谁家好人把IO流讲的这么好啊","url":"/2023/12/04/谁家好人把IO流讲的这么好啊/","content":"\n\n>本笔记知识点来源\n\n## 引子\n\nIO流说白了就是对文件的一系列操作，这里我用一个简单的例子展示IO流的使用\n\n**需求：**\n\n把e盘的我是源文件.txt文件复制一份，在e盘创建一个目录：我是一个目录,把源文件粘贴在这个目录中，给新文件起名为我是新文件.txt\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/c8d6ec7d97236718064c725320b249c1.png)\n\n代码：\n\n```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\n\npublic class FileCopyExample {\n    public static void copyFile(String sourcePath, String destinationPath, String newFileName) throws IOException {\n        // 创建目标目录\n        File directory = new File(destinationPath);\n        if (!directory.exists()) {\n            directory.mkdir();\n        }\n\n        // 构建源文件和目标文件路径\n        File sourceFile = new File(sourcePath);\n        File destinationFile = new File(directory.getAbsolutePath() + File.separator + newFileName);\n\n        // 复制文件\n        Path source = sourceFile.toPath();\n        Path destination = destinationFile.toPath();\n        Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);\n\n        System.out.println(\"文件复制成功！\");\n    }\n\n    public static void main(String[] args) {\n        //原来的文件名\n        String sourcePath = \"E:\\\\我是源文件.txt\";\n        //目标目录\n        String destinationPath = \"E:\\\\我是一个目录\";\n        //目标文件名\n        String newFileName = \"我是新文件.txt\";\n\n        try {\n            copyFile(sourcePath, destinationPath, newFileName);\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"文件复制失败！\");\n        }\n    }\n}\n```\n\n**运行结果：**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/6267e5f6a59d065cdf748f90030e1a98.png)\n\n这就是一个基础的io流的应用，读者可以自己运行一下试试，其中源文件名，目标目录和目标文件名都可以自定义。这个例子中的方法将会在后面的章节中讲到。\n\n那么，我们开始吧。\n\n## 1 文件\n\n### 1.1 什么是文件\n\n文件就是用来保存数据的地方，比如excel文件，word文件，mp3文件。可以保存图片，视频，声音等等等\n\n### 1.2 文件流\n\n文件**在程序中**是以流的形式操作的\n\n>流：数据在数据源（文件）和程序（内存）之间的路径\n\n>输入流：数据从数据源（文件）到程序（内存）的路径\n\n>输出流：数据从程序（内存）到数据源（文件）的路径\n\n当然，这里的数据源一般来说是磁盘，但也可以是其他的，比如说可能是来自网络，也有可能是来自数据库。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/3de33e244c41c37efdf752920c631ffc.png)\n\n## 2 常见的文件操作\n\n### 2.1 创建文件对象的构造器和方法\n\n#### 2.1.1 相关方法：\n\n>new File(String pathname)/根据路径字符串构建一个File对象<br>\n new File(File parent,String child)/根据父目录文件对象+子路径字符串构建<br>\n new File(String parent,String child)/根据父目录字符串+子路径字符串构建\n\n**注意**，**创建的File对象仅仅表示你正在操作的文件对象的路径**，并不会在系统文件夹中自动创建该文件。如果你想在指定的路径中创建一个文件，可以使用File对象的方法，如file.createNewFile()。通过这个方法，你可以在指定的路径下创建一个空的新文件。但是请注意，**如果指定路径所在的目录不存在，你需要确保先创建这个目录，然后才能成功创建文件。**（后面会讲解创建目录的方法）\n\n#### 2.1.2 构造方法和创建文件方法使用\n\n1 new File(String pathname)/根据路径字符串构建一个File对象\n\n```java\n@Test\n    public void fileDemo1(){\n        //这里创建了一个File对象，但是并没有在你电脑的文件夹里创建文件\n        //路径为两个反斜杠'\\\\'的原因在2.1.3中\n        File file=new File(\"e:\\\\newfile1.txt\");\n        try {\n            //运行了这个方法后，才正式创建了文件\n             file.createNewFile();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n```\n\n运行结果：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/40e2ba562b1a68554ae486754c769bc4.png)\n\n2 new File(File parent,String child)/根据父目录文件对象+子路径字符串构建\n\n```java\n@Test\n    public void fileDemo12(){\n        File fileParent=new File(\"e:\\\\\");\n        File file=new File(fileParent,\"newFile2.txt\");\n        try {\n             file.createNewFile();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n```\n\n3 new File(String parent,String child)/根据父目录字符串+子路径字符串构建\n\n```java\n@Test\n    public void fileDemo3(){\n        File file=new File(\"e:\\\\\",\"newFile3.txt\");\n        try {\n             file.createNewFile();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n```\n\n#### 2.1.3 小知识：为什么有的路径分隔符是\"\\\\\"，有的是\"/\"\n\n>在windows中，用于表示路径的字符串中，路径分隔符使用的是反斜杠（\\）而不是斜杠（/）。这是因为在Windows操作系统中，使用反斜杠作为路径分隔符。而斜杠在Windows操作系统中通常用作命令行参数的前缀，因此不适合作为路径分隔符。\n\n总结：你可以根据个人喜好和代码需求来选择使用斜杠(/)或双反斜杠(\\\\)作为文件路径分隔符。无论你选择哪个，Java都可以自动处理它们，并在不同的操作系统上正常运行。\n\n### 2.2 获取文件的相关信息\n\n新建File文件后，可以通过File自带的方法获取file的相关信息：\n\n这里我们直接获取上一节中新建的\"newFile1.txt\"文件的信息\n\n```java\n@Test\n    public void fileDemo3(){\n        File file=new File(\"e:/\",\"newFile1.txt\");\n        //调用相应的方法，得到对应信息\n        System.out.println(\"文件名字=\" + file.getName());\n        System.out.println(\"文件绝对路径=\" + file.getAbsolutePath());\n        System.out.println(\"文件父级目录=\" + file.getParent());\n        System.out.println(\"文件大小(字节)=\" + file.length());\n        System.out.println(\"文件是否存在=\" + file.exists());//T\n        System.out.println(\"是不是一个文件=\" + file.isFile());//T\n        System.out.println(\"是不是一个目录=\" + file.isDirectory());//F\n    }\n```\n\n运行结果：\n\n```java\n文件名字=newFile1.txt\n文件绝对路径=e:\\newFile1.txt\n文件父级目录=e:\\\n文件大小(字节)=6\n文件是否存在=true\n是不是一个文件=true\n是不是一个目录=false\n```\n\n如果随便设置一个路径，实际上并不存在这个文件或目录File file=new File(\"e:/\",\"hhhh.txt\");：\n\n运行结果：文件不存在，且不是文件也不是目录\n\n```java\n文件名字=hhhh.txt\n文件绝对路径=e:\\hhhh.txt\n文件父级目录=e:\\\n文件大小(字节)=0\n文件是否存在=false\n是不是一个文件=false\n是不是一个目录=false\n```\n\n### 2.3 目录的操作和文件删除\n\n><strong>目录创建</strong>\n\n><strong>文件，空目录删除</strong>\n\n以下用三个例子来使用上面的方法\n\n1 判断文件是否存在，存在就删除\n\n```java\n//判断文件是否存在，存在就删除\n    @Test\n    public void fileDelete(){\n        File file=new File(\"e:/newfile1.txt\");\n        //调用相应的方法，得到对应信息\n\n        System.out.println(\"文件是否存在=\" + file.exists());//T\n        if(file.exists()){\n            file.delete();\n        }\n    }\n```\n\n执行结束后，文件成功删除\n\n2 判断目录是否存在，存在就删除(**只能删除空白目录**)\n\n```java\n@Test\n    public void directoryDelete(){\n         //由此可见，java把文件夹也看作一个特殊的文件\n        File file=new File(\"e:/newdirectory1\");\n        //调用相应的方法，得到对应信息\n        System.out.println(\"目录是否存在=\" + file.exists());//T\n        if(file.exists()){\n            file.delete();\n        }\n```\n\n3 判断目录是否存在，不存在就创建\n\n创建目录有两种方法，当创建多级目录的时候，需要使用mkdirs()方法，若使用mkdir()会创建失败；\n\n只创建一级目录可以使用mkdir()。\n\n比如现在我们的文件夹中存在e:/newdirectory1文件夹，然后我要创建一个e:/newdirectory1/2文件夹就可以使用mkdir()；若要创建e:/newdirectory1/2/3,则只能用mkdirs()\n\n```java\n//判断目录是否存在，不存在就创建\n    @Test\n    public void directoryCreate(){\n        File file=new File(\"e:/newdirectory1/2/3\");\n        //调用相应的方法，得到对应信息\n\n        System.out.println(\"目录是否存在=\" + file.exists());//T\n        if(!file.exists()){\n            file.mkdirs();\n        }\n        System.out.println(\"目录是否存在=\" + file.exists());//T\n\n    }\n```\n\n## 3 IO 流原理及流的分类\n\n### 3.1 IO流原理及流的分类\n\n1. **I/O**是**Input/Output**的缩写，I/O技术是非常实用的技术，用于处理数据传输**如读/写文件，网络通讯**等。之后我们在学框架，做项目的时候就会有感受（比如上传下载接口）\n2. Java程序中，对于数据的**输入/输出操作以”流(stream)”的方式进行**。\n3. java.io包下提供了各种\"流\"类和接口，用以**获取不同种类的数据**，并通过方法输入或输出数据\n4. 输入input:**读取外部数据**(磁盘、光盘等存储设备的数据)**到程序**（内存）**中**。\n5. 输出output:将程序（内存）数据**输出**到磁盘、光盘等存储设备中\n\n### 3.2 流的分类\n\n按**操作数据单位**不同分为：**字节流**(8bt)(操作效率稍微低一些，但是处理二进制文件，如音频，视频，可以无损传输)，**字符流**（按字符）文本文件(需要考虑文件编码)\n 按**数据流的流向**不同分为：**输入流**，**输出流**\n 按**流的角色**的不同分为：**节点流**，**处理流/包装流**\n\n\n1. Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的\n2. 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。\n\n## 4 IO流体系-常用的类\n\nIO流体系图\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/964319c808c9b84dc561eeae38074054.png)\n\n### 4.1 InputStream 字节输入流·\n\n>InputStream 是所有类字节输入流的超类\n\n常用的子类：\n\n1.**FilelnputStream**: 文件输入流（常用来传输文件）\n 2.**BufferedInputStream**: 缓冲字节输入流（带缓冲的流，当然也可以用来传输文件）\n 3.**ObjectInputStream**: 对象字节输入流（传输对象的流）\n\n#### 4.1.1 FileInputStream 介绍\n\n**构造器：**\n\n><strong>FileInputStream</strong>(File file)\n\n理解：如果把文件比作快递，内存比作人，快递到人手中需要一个物流（快递），这里的物流就相当于流。构造器就相当于物流系统给我们的文件分配了一个快递员。\n\n##### 实例：\n\n**要求**：使用 FileInputStream 读取 helloworld.txt 文件，并将文件内容显示到控制台.\n\n文件位置及内容：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/7f9d3541d4441eec5fa24051931bc86c.png)\n\n\n```java\n@Test\n    public void readDocument() {\n        FileInputStream fileInputStream=null;\n        try {\n            //创建FileInputStream对象，用于读取文件\n            fileInputStream= new FileInputStream(\"e:/helloworld.txt\");\n            int readData = 0;\n            //每次读数据会返回下一个字符的值，如果已经到达文件的结尾，返回-1\n            while ((readData= fileInputStream.read())!=-1){\n                System.out.print((char)readData);\n            }\n        }  catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            try {\n                //这个流用完之后一定要记得关闭，因为流也是一种资源，如果不关闭，会造成资源浪费\n                fileInputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n```\n\n运行结果：\n\n```java\nanddd\n111\n\n233\nff\n```\n\n\n但是，如果我们在文件中存放中文，如：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/f936eeb8f59131017f96994435d9f4e0.png)\n\n输出的结果就是(乱码)：\n\n```java\næµ‹è¯•ä¸­æ–‡ \nanddd\n111\n\n233\nff\n```\n\n**原因：**\n\n默认情况下，Java 使用的是 UTF-8 编码格式，而有些文件可能使用其他编码格式，导致读取时出现乱码。\n\n要解决这个问题，可以在读取文件之前指定文件的编码格式，我们可以使用后面要学到的的InputStreamReader类来指定编码格式，来解决这个问题。\n\n\n我们可以使用InputStream的read(byte[] b)方法来提高传输的效率，之前的read()方法每次只能读取一个字节，而这个方法每次可以读取多个\n\n>read(byte[] b)\n\n**代码**：\n\n```java\n@Test\n    public void readDocument() {\n        FileInputStream fileInputStream=null;\n        try {\n            //创建FileInputStream对象，用于读取文件\n            fileInputStream= new FileInputStream(\"e:/helloworld.txt\");\n            //创建一个字节数组，这样我们每次可以读多个字节，本次是每次读8个字节\n            byte[] byts=new byte[8];\n            //用来存储每次的字节数\n            int bytLength=0;\n            //如果已经到达文件的结尾，返回-1\n            while ((bytLength= fileInputStream.read(byts))!=-1){\n                //三个参数分别代表 数组，开始的索引，解码字符的个数\n                System.out.print(new String(byts,0,bytLength));\n            }\n        }  catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            try {\n                fileInputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n```\n\n### 4.2 OutPutStream 字节输出流\n\n#### 4.2.1 FileOutStream\n\n构造方法：\n\n| FileOutputStream(File file)\n 创建文件输出流以写入由指定的 File\n\n\n创建文件输出流以写入由指定的 File\n 对象表示的文件。 |\n | FileOutputStream(FileDescriptor fdObj)\n 创建文件输出流以写入指定的文件描述符，表示与文件系统中实际文件的现有连接。 |\n | FileOutputStream(String name)\n 创建文件输出流以指定的名称写入文件。 |\n | FileOutputStream(String name, boolean append)\n 创建文件输出流以指定的名称写入文件。 |\n\n咱们直接通过代码来演示构造方法和一些常用方法\n\n##### 在e盘中的a.txt中写入helloworld\n\n**构造方法1** new FileOutputStream(filePath) 该创建方式写入内容时会覆盖原来的内容\n\n```java\n@Test\n    public void createTxt() throws IOException {\n        String filePath = \"e:/a.txt\";\n        FileOutputStream fileOutputStream = null;\n        fileOutputStream = new FileOutputStream(filePath);\n        //方法1：写入一个字节\n\t\tfileOutputStream.write('a');\n\n        //方法2：写入字符串\n        String str = \"hello world\";\n\t\tfileOutputStream.write(str.getBytes());\n\t\t\n        //方法3：写入字节数组的固定个数 write(byte[] b, int off, int len)\n        //从这个字节数组索引为off的字节开始，写入len个字节\n        fileOutputStream.write(str.getBytes(), 0, str.length());\n    }\n```\n\n运行结果：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/28bcdf34748c6a4a96fed1f66ec72d15.png)\n\n如果有一起操作的同学会发现两件事情：\n\n1 文件夹里本来没有a.txt，也没有人为创建，文件夹中就自己出现了这个文件\n\n2 代码不管运行几次，文件中的内容都是这些\n\n1是因为使用FileOutputStream 类时，如果指定要写入的文件路径处没有文件，它将自动创建一个新文件进行写入，当然只能有一级文件夹，多级文件夹就不行了\n\n2是因为我们使用的构造方法写入内容时会覆盖原来的内容\n\n**构造方法2** ：FileOutputStream(File file, boolean append)\n\nappend - 如果 true ，则字节将被写入文件的末尾而不是开头\n\n我们修改原来代码的构造方法\n\n```java\n@Test\n    public void createTxt() throws IOException {\n        String filePath = \"e:/a.txt\";\n        FileOutputStream fileOutputStream = null;\n        fileOutputStream = new FileOutputStream(filePath, true\n        );\n        //方法1：写入一个字节\n        fileOutputStream.write('a');\n\n        //方法2：写入字符串\n        String str = \"hello world\";\n        fileOutputStream.write(str.getBytes());\n\n        //方法3：写入字节数组的固定个数 write(byte[] b, int off, int len)\n        //从这个字节数组索引为off的字节开始，写入len个字节\n        fileOutputStream.write(str.getBytes(), 0, str.length());\n    }\n```\n\n结果：\n\n可以看到，字节被写到了文件的末尾\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/4eaa51a63c74d8456cb9c1c183007971.png)\n\n### 4.3 复制一个文件\n\n现在我们使用刚刚学到的方法，复制一个文件\n\n我们复制e盘下的一张图片a.png,复制到e:/a/copy.png\n\n```java\n@Test\n    public void createTxt() throws IOException {\n        FileInputStream fileInputStream=new FileInputStream(\"e:/a.png\");\n        //如果上级文件夹不存在，创建上级文件夹\n        File copyDir=new File(\"e:/a\");\n        if(!copyDir.exists()){\n            copyDir.mkdirs();\n        }\n        FileOutputStream fileOutputStream=new FileOutputStream(\"e:/a/copy.png\");\n        byte[] bytes=new byte[1024];\n        int bytLength=0;\n        while ((bytLength=fileInputStream.read(bytes)) != -1){\n            //必须要用这个方法，不然可能会出现文件损失\n          fileOutputStream.write(bytes,0,bytLength);\n        }\n        //不要忘了关闭流\n        fileOutputStream.close();\n        fileInputStream.close();\n    }\n```\n\n### 4.4 文件字符流\n\n\n\n**FileReader和FileWriter是字符流，通过字符来操作io**![img](https://img-blog.csdnimg.cn/img_convert/74b302c8e8285c1c75a9cd4e2202cce0.png)![img](https://img-blog.csdnimg.cn/img_convert/4026a116b7de251b0b2fb3004969ace2.png)**FileReader相关方法：**\n\n- new FileReader(file/string) 通过file类或路径来创建\n- read()每次读取单个字符串，返回该字符。如果到文件末尾返回-1；（**因为是字符流，所以如果用的是UTF-8编码，会返回三个字节组成的字符。**）\n- read(char[]) 批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1\n\n相关API：\n\n- new String (char[])\n- new String (char[],off,len) **off:偏移量表示要解码的第一个字节的索引，len长度表示要解码的字节数**\n\n**FileWriter相关方法：**\n\n- new FileWriter(File/String):覆盖摸式，相当于流的指针在首端\n- new FileWriter(File/String,true):追加模式，相当于流的指针在尾端\n- write(int):写入单个字符\n- write(char[]):写入指定数组\n- write(char[],off,len):写入指定数组的指定部分\n- write(string):写入整个字符串\n- write(string,off,len):写入字符串的指定部分\n\n相关APl:\n\n- String类：toCharArray:将String转换成char[]\n\n>注意：<br><strong>FileWriter使用后！必须要关闭(close)或刷新(flush),否则写入不到指定的文件！</strong>\n\n**FileReader使用：**\n\n```java\n//单个字符串读取\n\t@Test\n    public void print1() throws IOException {\n        FileReader fileReader = new FileReader(\"E:\\\\ice.txt\");\n        int readDate = 0;\n        while ((readDate = fileReader.read()) != -1) {\n            System.out.print((char) readDate);\n        }\n    }\n\t//字符数组读取\n    @Test\n    public void print2() throws IOException {\n        FileReader fileReader = new FileReader(\"E:\\\\ice.txt\");\n        int readNum = 0;\n        char[] readDate=new char[8];\n        while ((readNum = fileReader.read(readDate)) != -1) {\n            System.out.print(new String(readDate,0,readNum));\n        }\n    }\n```\n\nFileWriter使用:\n\n```java\n@Test\n    public void print2() throws IOException {\n    \t//带上true，代表追加（在原本文本的后面添加下面的字符）\n        FileWriter fileWriter=new FileWriter(\"E:\\\\ice.txt\",true);\n\t\t//  write(int):写入单个字符\n\t\tfileWriter.write('H');\n\t\t//  write(char[]):写入指定数组\n\t\tfileWriter.write(chars);\n\t\t//  write(char[],off,len):写入指定数组的指定部分\n\t\tfileWriter.write(\"韩顺平教育\".toCharArray(), 0, 3);\n\t\t//  write（string）：写入整个字符串\n\t\tfileWriter.write(\" 你好北京~\");\n\t\tfileWriter.write(\"风雨之后，定见彩虹\");\n        fileWriter.flush();\n\n    }\n```\n\n## 5 节点流和处理流\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/ccb2e7af3b89c908a4a59949ccaf592c.png)\n\n**基本介绍：**\n\n- 节点流可以从特定数据源读取数据，如FileReader、FileWriter\n- 处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。**处理流的构造方法总是要带一个其他的流对象做参数**。一个流对象经过其他流的多次包装，称为流的链接。\n\n**节点流和处理流的区别和联系**\n\n- 节点流是底层流/低级流，直接跟数据源连接。\n- 处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入和输出。\n- 处理流对节点流进行包装，使用了**修饰器设计模式**，不会直接与数据源相连接。\n\n>修饰器设计模式：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。\n\n### 5.1 缓冲流\n\n首先我们来认识认识一下缓冲流,也叫高效流，是对4个FileXxx 流的“增强流”。\n\n**缓冲流的基本原理**：\n\n>1、使用了底层流对象从具体设备上获取数据，并将数据存储到缓冲区的数组内。<br>\n 2、通过缓冲区的read()方法从缓冲区获取具体的字符数据，这样就提高了效率。<br>\n 3、如果用read方法读取字符数据，并存储到另一个容器中，直到读取到了换行符时，将另一个容器临时存储的数据转成字符串返回，就形成了readLine()功能。\n\n也就是说在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n\n缓冲书写格式为BufferedXxx，按照数据类型分类：\n\n- **字节缓冲流**：BufferedInputStream，BufferedOutputStream\n- **字符缓冲流**：BufferedReader，BufferedWriter\n\n#### 5.1.1 字节缓冲流\n\n**构造方法**\n\n- public BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为**InputStream**。\n- public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流，注意参数类型为**OutputStream**。\n\n缓冲流读写的方式和节点流基本上是一致的，不过效率会大大提高\n\n```java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 记录开始时间\n      \tlong start = System.currentTimeMillis();\n\t\t// 创建流对象\n        try (\n         BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"e:\\\\ice.exe\"));\n\t     BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"e:\\\\copyPy.exe\"));\n        ){\n        // 读写数据\n            int b;\n            while ((b = bis.read()) != -1) {\n                bos.write(b);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\t\t// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println(\"缓冲流复制时间:\"+(end - start)+\" 毫秒\");\n    }\n}\n\n缓冲流复制时间:8016 毫秒\n```\n\n```java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n      \t// 记录开始时间\n        long start = System.currentTimeMillis();\n\t\t// 创建流对象\n        try (\n\t\t BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"e:\\\\ice.exe\"));\n\t\t BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"e:\\\\copyPy.exe\"));\n        ){\n          \t// 读写数据\n            int len;\n            byte[] bytes = new byte[8*1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0 , len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\t\t// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println(\"缓冲流使用数组复制时间:\"+(end - start)+\" 毫秒\");\n    }\n}\n缓冲流使用数组复制时间:521 毫秒\n```\n\n#### 5.1.2 字符缓冲流\n\n**构造方法**\n 相同的来看看其构造，其格式以及原理和字节缓冲流是一样一样的！\n\n- public BufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为**Reader**。\n- public BufferedWriter(Writer out)： 创建一个新的缓冲输出流，注意参数类型为**Writer**。\n\n**字符缓冲流特有方法**\n 字符缓冲流的基本方法与普通字符流调用方式一致，这里不再阐述，我们来看字符缓冲流具备的**特有**方法。\n\n- BufferedReader：public String readLine(): **读一行数据**。 **读取到最后返回null**\n- BufferedWriter：public void newLine(): **换行**,由系统属性定义符号。\n\nreadLine方法演示代码如下：、\n\n```java\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException {\n      \t // 创建流对象\n        BufferedReader br = new BufferedReader(new FileReader(\"e:\\\\ice.txt\"));\n\t\t// 定义字符串,保存读取的一行文字\n        String line  = null;\n      \t// 循环读取,读取到最后返回null\n        while ((line = br.readLine())!=null) {\n            System.out.print(line);\n            System.out.println();\n        }\n\t\t// 释放资源\n        br.close();\n    }\n}\n```\n\nnewLine方法演示代码如下：\n\n```java\npublic class BufferedWriterDemo throws IOException {\n  public static void main(String[] args) throws IOException  {\n    \t// 创建流对象\n  \tBufferedWriter bw = new BufferedWriter(new FileWriter(\"e:\\\\ice.txt\"));\n    \t// 写出数据\n      bw.write(\"你好\");\n    \t// 写出换行\n      bw.newLine();\n      bw.write(\"好久\");\n      bw.newLine();\n      bw.write(\"不见\");\n      bw.newLine();\n      bw.write(\"甚是想念？\");\n      bw.newLine();\n  \t// 释放资源\n      bw.close();\n  }\n}\n输出效果:\n你好\n好久\n不见\n甚是想念？\n```\n\n### 5.2 转换流\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/c6771456fcd229d81436e446119f8a83.png)\n\n#### 5.2.1 字符编码和解码\n\n电脑中存放的所有数据，包括图片，音视频，文字，都是以二进制的形式存放的。而我们在屏幕上看到的文字，标点，都是二进制解析出来的。这种将二进制数据通过某种规则转化成字符的过程，叫做**解码**。而将按照某种规则，将字符存储到计算机中，称为**编码**。\n\n简单一点的说就是：\n\n>编码:字符(能看懂的)–字节(看不懂的）<br>\n 解码:字节(看不懂的)–&gt;字符(能看懂的)\n\n- **字符编码** Character Encoding: 就是一套自然语言的字符与二进制数之间的对应规则。\n- **字符集 **Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n\n\n计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。![img](https://img-blog.csdnimg.cn/img_convert/eb7ce47b207fba824239024f4885e86c.png)\n\n#### 5.2.2 编码问题导致乱码\n\n在java开发工具IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取到GBK编码的文本文件时，就会出现乱码。\n\n```java\npublic class ReaderDemo {\n    public static void main(String[] args) throws IOException {\n        FileReader fileReader = new FileReader(\"C:\\\\a.txt\");\n        int read;\n        while ((read = fileReader.read()) != -1) {\n            System.out.print((char)read);\n        }\n        fileReader.close();\n    }\n}\n输出结果：���\n```\n\n那么如何读取GBK编码的文件呢？ 这个时候就得讲讲转换流了！\n\n#### 5.2.3 InputStreamReader-字节流转换成字符流\n\nReader的子类，可以将**InputStream(字节流)转换成Reader(字符流)**\n\n**构造代码：**\n\n><strong>InputStreamReader isr = new InputStreamReader(new FileInputStream(“in.txt”));</strong><br><strong>InputStreamReader isr2 = new InputStreamReader(new FileInputStream(“in.txt”) , “GBK”);</strong>\n\n```java\npublic static void main(String[] args) throws IOException {\n   \t// 定义文件路径,文件为gbk编码\n     String FileName = \"C:\\\\A.txt\";\n   \t// 创建流对象,默认UTF8编码\n     InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n   \t// 创建流对象,指定GBK编码\n     InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\");\n\t// 定义变量,保存字符\n     int read;\n   \t// 使用默认编码字符流读取,乱码\n     while ((read = isr.read()) != -1) {\n         System.out.print((char)read); // �����ʺ      \n     }\n     isr.close();\n   \n   \t// 使用指定编码字符流读取,正常解析\n     while ((read = isr2.read()) != -1) {\n         System.out.print((char)read);// 姐就是女王\n     }\n     isr2.close();\n }\n```\n\n#### 5.2.4 OutputStreamWriter-字符流转换为字节流\n\nWriter的子类，它的作用是将字符流转换为字节流，使得字符流可以以指定格式被写入到输出流中。\n 构造方法：\n\n>OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(“a.txt”));<br>\n OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(“b.txt”) , “GBK”);\n\n```java\npublic static void main(String[] args) throws IOException {\n        String text = \"Hello, world!\";\n        FileOutputStream fos = new FileOutputStream(\"output.txt\");\n        OutputStreamWriter osw = new OutputStreamWriter(fos, \"UTF-8\");\n        osw.write(text);\n        osw.close();\n    }\n```\n\n### 5.3 对象流（序列化流）\n\n#### 详细介绍序列化流\n\n序列化流是一种将对象转换为字节流的过程，以便可以将对象保存到磁盘上，将其传输到网络上，或者将其存储在内存中，以后再进行反序列化，将字节流重新转换为对象。序列化流的作用是实现对象的持久化和跨平台传输。\n\n要使用序列化流，需要**满足以下条件**：\n\n- 对象所属的类必须实现 java.io.Serializable 接口，这是一个标记接口，没有任何方法，只是用于标识类可以被序列化。\n- 对象的所有属性必须是可序列化的，如果有一个属性不是可序列化的，则该属性必须用 transient 关键字修饰，表示该属性不参与序列化。\n- 对象所属的类最好提供一个 serialVersionUID 字段，这是一个长整型常量，用于标识类的版本号，如果没有提供，系统会自动生成一个，但是可能会因为类的修改而变化，导致反序列化失败。\n\n序列化流的使用步骤如下：\n\n- 创建一个 ObjectOutputStream 对象，构造方法的参数是一个 OutputStream 对象，可以是任意的字节输出流，如 FileOutputStream。\n- 调用 ObjectOutputStream 的 writeObject 方法，传入要序列化的对象，该方法会将对象转换为字节流，并写入到指定的输出流中。\n- 关闭 ObjectOutputStream 对象，释放资源。\n\n反序列化流是一种将字节流转换为对象的过程，它是序列化流的逆过程。反序列化流的作用是从文件或网络中读取对象，以便在程序中使用。\n\n反序列化流的使用步骤如下：\n\n- 创建一个 ObjectInputStream 对象，构造方法的参数是一个 InputStream 对象，可以是任意的字节输入流，如 FileInputStream。\n- 调用 ObjectInputStream 的 readObject 方法，该方法会从指定的输入流中读取字节流，并将其转换为对象，返回值是一个 Object 对象，需要强制类型转换为原来的对象类型。\n- 关闭 ObjectInputStream 对象，释放资源。\n\n以下是一个使用序列化流和反序列化流的示例，其中定义了一个 Person 类，实现了 Serializable 接口，并提供了一个 serialVersionUID 字段。然后创建了一个 Person 对象，并使用 ObjectOutputStream 将其序列化到一个文件中，再使用 ObjectInputStream 从文件中反序列化该对象\n\n```java\nimport java.io.*;\n\n// 定义一个 Person 类，实现 Serializable 接口\nclass Person implements Serializable {\n    // 提供一个 serialVersionUID 字段，标识类的版本号\n    private static final long serialVersionUID = 1L;\n    // 定义两个属性，name 和 age\n    private String name;\n    private int age;\n\n    // 提供构造方法，设置属性的值\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // 提供 toString 方法，返回对象的信息\n    public String toString() {\n        return \"Person{name=\" + name + \", age=\" + age + \"}\";\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        // 创建一个 Person 对象\n        Person p = new Person(\"张三\", 18);\n        // 创建一个 ObjectOutputStream 对象，传入一个 FileOutputStream 对象，指定文件名为 person.txt\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"person.txt\"));\n        // 调用 writeObject 方法，将 Person 对象序列化到文件中\n        oos.writeObject(p);\n        // 关闭 ObjectOutputStream 对象\n        oos.close();\n\n        // 创建一个 ObjectInputStream 对象，传入一个 FileInputStream 对象，指定文件名为 person.txt\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"person.txt\"));\n        // 调用 readObject 方法，从文件中反序列化 Person 对象，需要强制类型转换\n        Person p2 = (Person) ois.readObject();\n        // 关闭 ObjectInputStream 对象\n        ois.close();\n        // 打印反序列化得到的对象\n        System.out.println(p2);\n    }\n}\n```\n\n运行结果是：\n\n```java\nPerson{name=张三, age=18}\n```\n\n说明序列化流和反序列化流成功地将对象保存到文件中，并从文件中读取对象。这就是序列化流和反序列化流的基本用法。\n\n#### 一些问题\n\n**为什么要进行序列化的工作，有哪些场景需要进行序列化**\n 一般来说，有以下几种场景需要进行序列化：\n\n- 当你想把内存中的对象保存到文件中，以便在其他时间或其他地方重新加载和使用，例如保存游戏进度，保存用户设置，保存用户数据等。\n- 当你想把对象通过网络传输给其他程序或其他机器，以便在远程进行处理或展示，例如远程方法调用，分布式计算，网络通信等。\n- 当你想把对象存储在内存中，以便在不同的线程或不同的模块之间共享或传递，例如消息队列，缓存系统，事件驱动等。\n\n**当你想把对象通过网络传输给其他程序或其他机器，以便在远程进行处理或展示，例如远程方法调用，分布式计算，网络通信等。 这一条不是很懂，可以说详细一些吗。比如我调用一个接口，调用接收的类需要序列化吗。**\n 好的，我来解释一下这一条的意思。当你想把对象通过网络传输给其他程序或其他机器，就是说你想把一个Java对象从一个JVM（Java虚拟机）发送到另一个JVM，这样你就可以在不同的机器上运行不同的Java程序，但是它们之间可以相互通信和协作。例如，你可以把一个对象发送到一个服务器上，让服务器对这个对象进行一些复杂的计算或处理，然后把结果返回给你，这就是远程方法调用（RMI）的一个应用场景。或者，你可以把一个对象发送到一个客户端上，让客户端显示这个对象的内容或状态，这就是网络通信的一个应用场景。\n 但是，要实现这样的功能，你需要对对象进行序列化和反序列化。序列化就是把对象转换成字节流的过程，反序列化就是把字节流还原成对象的过程。这样，你才能把对象通过网络发送和接收，因为网络只能传输字节数据。所以，如果你想把对象通过网络传输给其他程序或其他机器，你就需要对对象进行序列化和反序列化。\n 你提到的调用一个接口的问题，其实就是RMI的一个例子。如果你调用的接口是一个远程接口，也就是说，这个接口的实现类是在另一个JVM中运行的，那么你就需要对调用的参数和返回值进行序列化和反序列化，因为这些参数和返回值都是对象，它们需要通过网络传输。如果你调用的接口是一个本地接口，也就是说，这个接口的实现类是在同一个JVM中运行的，那么你就不需要对调用的参数和返回值进行序列化和反序列化，因为这些参数和返回值都是在内存中直接传递的，不需要通过网络。\n 希望这样能让你更清楚地理解这一条的意思。如果你还有其他问题，欢迎继续提问。😊\n\n**可是我调用远程接口的时候，并没有将我的类进行序列化，照样可以介绍到对面返回的数据：**\n 你调用远程接口的时候，可能是使用了一些框架或库，它们已经帮你实现了序列化和反序列化的功能，所以你不需要自己去做。例如，如果你使用的是 Java RMI（Remote Method Invocation）框架，它会自动为你处理对象的序列化和反序列化，你只需要关注业务逻辑。或者，如果你使用的是 JSON（JavaScript Object Notation）格式，它是一种常用的数据交换格式，它可以将对象转换为字符串，或者将字符串转换为对象，你可以使用一些库，如 Gson 或 Jackson，来实现对象和 JSON 字符串之间的转换，这也是一种序列化和反序列化的过程。\n 所以，你调用远程接口的时候，并没有将你的类进行序列化，并不是说序列化和反序列化不需要，而是说它们已经被封装在了其他的工具中，你不需要直接操作它们。但是，如果你想了解它们的原理和细节，你还是需要学习序列化流和反序列化流的知识的。😊**所以我使用的框架是springboot，我在调用接口的时候，实际上传输的是json是吗。为什么我的类转化为json，就属于序列化了呢：**\n 是的，你使用的框架是springboot，你在调用接口的时候，实际上传输的是json。json是一种数据交换格式，它可以将对象转换为字符串，或者将字符串转换为对象。这样，你就可以把对象通过网络发送和接收，因为网络只能传输字节数据。这个过程就属于序列化和反序列化。\n 为什么你的类转化为json，就属于序列化了呢？因为序列化的本质就是把对象的状态（属性的值）保存到一个可存储或可传输的媒介中，例如文件，内存，网络等。json就是一种可存储或可传输的媒介，它是一种文本格式，可以用文件或字节流来保存或传输。当你把你的类转化为json时，你就是把你的类的状态保存到了一个json字符串中，这就是序列化。当你把json字符串转化为你的类时，你就是把json字符串中的状态还原到了你的类中，这就是反序列化。所以，你的类转化为json，就属于序列化了。😊\n\n**那为什么我还要实现java.io.Serializable呢，我不是已经转换为json了吗**\n 你不一定要实现java.io.Serializable接口，这取决于你使用的是哪种序列化和反序列化的方式。如果你使用的是json格式，那么你可以使用一些库，如Gson或Jackson，来实现对象和json字符串之间的转换，这些库不需要你的类实现java.io.Serializable接口，它们只需要你的类有一个无参的构造方法，和一些公开的或者有注解的属性或方法，就可以自动地将你的类转化为json，或者将json转化为你的类。但是，如果你使用的是Java自带的序列化和反序列化的方式，也就是使用ObjectOutputStream和ObjectInputStream，那么你就必须让你的类实现java.io.Serializable接口，这是一个标记接口，没有任何方法，只是用于标识类可以被序列化。如果你的类没有实现这个接口，而你试图用ObjectOutputStream或ObjectInputStream对它进行序列化或反序列化，那么你就会抛出一个NotSerializableException异常，表示你的类不可序列化。\n 所以，你是否要实现java.io.Serializable接口，要看你使用的是哪种序列化和反序列化的方式，不同的方式有不同的要求。你可以根据你的需求和喜好，选择合适的方式。😊\n\n**那我怎么知道我使用的是哪种序列化方式呢。或者说，哪些时候是json，哪些时候用ObjectOutputStream和ObjectInputStream呢**\n 至于哪些时候是json，哪些时候用ObjectOutputStream和ObjectInputStream，这没有一个固定的答案，这取决于你的需求和喜好，不同的方式有不同的优缺点。一般来说，json格式比较简单，通用，易读，易传输，可以和其他语言的程序进行交互，但是它不能保存对象的所有信息，例如类的元数据，方法，静态属性等，而且它的转换效率可能不如Java自带的方式高。Java自带的方式比较复杂，专用，不易读，不易传输，只能和Java语言的程序进行交互，但是它可以保存对象的所有信息，而且它的转换效率可能比json格式高。所以，你需要根据你的具体情况，选择合适的方式。😊\n\n**我要使用hutool的网络工具，调用某个api平台的一个post接口，在这种场景应该如何写代码，这个时候需要进行序列化和反序列化吗**\n 你可以使用hutool的网络工具，调用某个api平台的一个post接口，具体的代码如下：\n\n```java\n// 引入hutool的http模块\nimport cn.hutool.http.HttpUtil;\n\n// 创建一个HashMap对象，用于存放请求参数\nHashMap<String, Object> paramMap = new HashMap<>();\n// 添加请求参数，根据具体的api平台的要求，可能需要添加一些认证信息，例如appKey，appSecret等\nparamMap.put(\"param1\", \"value1\");\nparamMap.put(\"param2\", \"value2\");\n\n// 调用HttpUtil的post方法，传入api平台的url和请求参数，返回一个字符串，表示响应的内容\nString result = HttpUtil.post(\"https://api.example.com/post\", paramMap);\n\n// 打印响应的内容\nSystem.out.println(result);\n```\n\n这种场景下，你不需要进行序列化和反序列化，因为hutool的http模块已经帮你实现了这些功能。你只需要传入一个Map对象，hutool会自动将它转换为表单格式或者json格式，根据你的请求头的Content-Type的值。同样，你也不需要解析响应的内容，hutool会自动将它转换为字符串，你可以直接使用。当然，如果你想对响应的内容进行更多的处理，你可以使用hutool的json模块，将字符串转换为json对象，然后进行操作。\n\n**hutool哪里帮我序列化了，我咋没看到**\n hutool在HttpUtil的post方法中帮你序列化了，你可能没有注意到。如果你看一下HttpUtil的源码，你会发现，当你传入一个Map对象作为请求参数时，hutool会根据你的请求头的Content-Type的值，来决定将Map对象转换为什么格式的数据。如果你的Content-Type是application/x-www-form-urlencoded，那么hutool会将Map对象转换为表单格式的数据，也就是key=value&amp;key=value的形式。如果你的Content-Type是application/json，那么hutool会将Map对象转换为json格式的数据，也就是{“key”:“value”,“key”:“value”}的形式。这些转换的过程，其实就是序列化的过程，只不过hutool已经封装好了，你不需要自己去写。😊\n\n### 5.4 打印流\n\n实际上，我们平常使用的System.out.println就是打印流**打印流分类：**\n\n>字节打印流PrintStream，字符打印流PrintWriter\n\n**打印流特点：**\n\n>A:**只操作目的地,不操作数据源 **<br>\n B:可以操作任意类型的数据<br>\n C:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新<br>\n D:可以直接操作文件\n\n```java\npublic static void main(String[] args) throws IOException {\n        BufferedReader br=new BufferedReader(new FileReader(\"e:\\\\ice.txt\"));\n        PrintStream ps=new PrintStream(\"e:\\\\printcopy.txt\");\n        String line;\n        while((line=br.readLine())!=null) {\n            ps.println(line);\n        }\n        br.close();\n        ps.close();\n    }\n```\n\n```java\npublic static void main(String[] args) throws IOException {\n        BufferedReader br=new BufferedReader(new FileReader(\"aa.txt\"));\n        PrintWriter pw=new PrintWriter(\"printcopyaa.txt\");\n        String line;\n        while((line=br.readLine())!=null) {\n            pw.println(line);\n        }\n        br.close();\n        pw.close();\n    }\n```\n\n### 5.4 Properties\n\n**构造方法**\n public Properties() :创建一个空的属性列表。**基本的存储方法**\n public Object setProperty(String key, String value) ： 保存一对属性。\n public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。\n public Set stringPropertyNames() ：所有键的名称的集合。\n\n```java\npublic class ProDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 创建属性集对象\n        Properties properties = new Properties();\n        // 添加键值对元素\n        properties.setProperty(\"filename\", \"a.txt\");\n        properties.setProperty(\"length\", \"209385038\");\n        properties.setProperty(\"location\", \"D:\\\\a.txt\");\n        // 打印属性集对象\n        System.out.println(properties);\n        // 通过键,获取属性值\n        System.out.println(properties.getProperty(\"filename\"));\n        System.out.println(properties.getProperty(\"length\"));\n        System.out.println(properties.getProperty(\"location\"));\n\n        // 遍历属性集,获取所有键的集合\n        Set<String> strings = properties.stringPropertyNames();\n        // 打印键值对\n        for (String key : strings ) {\n            System.out.println(key+\" -- \"+properties.getProperty(key));\n        }\n    }\n}\n输出结果：\n{filename=a.txt, length=209385038, location=D:\\a.txt}\na.txt\n209385038\nD:\\a.txt\nfilename -- a.txt\nlength -- 209385038\nlocation -- D:\\a.txt\n```\n\n**与流相关的方法**\n public void load(InputStream inStream)： 从字节输入流中读取键值对。\n 参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。现在文本数据格式如下:\n\n```java\nilename=Properties.txt\nlength=123\nlocation=C:\\Properties.txt\n```\n\n**加载代码演示：**\n\n```java\n复制代码public class ProDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 创建属性集对象\n        Properties pro = new Properties();\n        // 加载文本中信息到属性集\n        pro.load(new FileInputStream(\"Properties.txt\"));\n        // 遍历集合并打印\n        Set<String> strings = pro.stringPropertyNames();\n        for (String key : strings ) {\n            System.out.println(key+\" -- \"+pro.getProperty(key));\n        }\n    }\n}\n输出结果：\nfilename -- Properties.txt\nlength -- 123\nlocation -- C:\\Properties.txt\n```\n\n文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。\n\n","tags":["java","开发语言","学习","java基础知识"]},{"title":"springboot最全，最完整，最适合小白教程（开发实用篇）","url":"/2023/08/21/springboot最全，最完整，最适合小白教程（开发实用篇）/","content":"\n\n>本文章为黑马的springboot教程的教学文档，具体视频内容移步至bilibili 黑马程序员官方账号<br>\n 教程分为基础篇，运维实用篇，开发实用篇，原理篇\n\n基础篇： [springboot 基础篇](http://t.csdn.cn/yvD99)\n 运维实用篇 ： [springboot 运维实用篇](http://t.csdn.cn/7DPBB)\n 开发实用篇： [springboot 开发实用篇](http://t.csdn.cn/ZHmPq)\n 原理篇： [springboot 原理篇](http://t.csdn.cn/TMiLt)\n\n## SpringBoot开发实用篇\n\n 怀着忐忑的心情，开始了开发实用篇文档的编写。为什么忐忑？特喵的债欠的太多，不知道从何写起。哎，不煽情了，开工。\n\n 运维实用篇完结以后，开发实用篇采用日更新的形式发布给各位小伙伴，基本上是每天一集，目前已经发布完毕。看评论区，好多小伙伴在求文档，所以赶紧来补文档，加班加点把开发实用篇的文档刨出来。\n\n 开发实用篇中因为牵扯到SpringBoot整合各种各样的技术，由于不是每个小伙伴对各种技术都有所掌握，所以在整合每一个技术之前，都会做一个快速的普及，这样的话内容整个开发实用篇所包含的内容就会比较多。各位小伙伴在学习的时候，如果对某一个技术不是很清楚，可以先跳过对应章节，或者先补充一下技术知识，然后再来看对应的课程。开发实用篇具体包含的内容如下：\n\n- 热部署\n- 配置高级\n- 测试\n- 数据层解决方案\n- 整合第三方技术\n- 监控\n\n 看目录感觉内容量并不是很大，但是在数据层解决方案和整合第三方技术中包含了大量的知识，一点一点慢慢学吧。下面开启第一部分热部署相关知识的学习\n\n### KF-1.热部署\n\n 什么是热部署？简单说就是你程序改了，现在要重新启动服务器，嫌麻烦？不用重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。\n\n 热部署的功能是如何实现的呢？这就要分两种情况来说了，非springboot工程和springboot工程的热部署实现方式完全不一样。先说一下原始的非springboot项目是如何实现热部署的。\n\n**非springboot项目热部署实现原理**\n\n 开发非springboot项目时，我们要制作一个web工程并通过tomcat启动，通常需要先安装tomcat服务器到磁盘中，开发的程序配置发布到安装的tomcat服务器上。如果想实现热部署的效果，这种情况其实有两种做法，一种是在tomcat服务器的配置文件中进行配置，这种做法与你使用什么IDE工具无关，不管你使用eclipse还是idea都行。还有一种做法是通过IDE工具进行配置，比如在idea工具中进行设置，这种形式需要依赖IDE工具，每款IDE工具不同，对应的配置也不太一样。但是核心思想是一样的，就是使用服务器去监控其中加载的应用，发现产生了变化就重新加载一次。\n\n 上面所说的非springboot项目实现热部署看上去是一个非常简单的过程，几乎每个小伙伴都能自己写出来。如果你不会写，我给你个最简单的思路，但是实际设计要比这复杂一些。例如启动一个定时任务，任务启动时记录每个文件的大小，以后每5秒比对一下每个文件的大小是否有改变，或者是否有新文件。如果没有改变，放行，如果有改变，刷新当前记录的文件信息，然后重新启动服务器，这就可以实现热部署了。当然，这个过程肯定不能这么做，比如我把一个打印输出的字符串\"abc\"改成\"cba\"，比对大小是没有变化的，但是内容缺实变了，所以这么做肯定不行，只是给大家打个比方，而且重启服务器这就是冷启动了，不能算热部署，领会精神吧。\n\n 看上去这个过程也没多复杂，在springboot项目中难道还有其他的弯弯绕吗？还真有。\n\n**springboot项目热部署实现原理**\n\n 基于springboot开发的web工程其实有一个显著的特征，就是tomcat服务器内置了，还记得内嵌服务器吗？服务器是以一个对象的形式在spring容器中运行的。本来我们期望于tomcat服务器加载程序后由tomcat服务器盯着程序，你变化后我就重新启动重新加载，但是现在tomcat和我们的程序是平级的了，都是spring容器中的组件，这下就麻烦了，缺乏了一个直接的管理权，那该怎么做呢？简单，再搞一个程序X在spring容器中盯着你原始开发的程序A不就行了吗？确实，搞一个盯着程序A的程序X就行了，如果你自己开发的程序A变化了，那么程序X就命令tomcat容器重新加载程序A就OK了。并且这样做有一个好处，spring容器中东西不用全部重新加载一遍，只需要重新加载你开发的程序那一部分就可以了，这下效率又高了，挺好。\n\n 下面就说说，怎么搞出来这么一个程序X，肯定不是我们自己手写了，springboot早就做好了，搞一个坐标导入进去就行了。\n\n#### KF-1-1.手动启动热部署\n\n**步骤①**：导入开发者工具对应的坐标\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n\n**步骤②**：构建项目，可以使用快捷键激活此功能\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/999925611a31ef7378cf413d00e7a5da.png)\n\n 对应的快捷键一定要记得\n\n```java\n<CTR>L+<F9>\n```\n\n 以上过程就实现了springboot工程的热部署，是不是挺简单的。不过这里需要把底层的工作工程给普及一下。\n\n**重启与重载**\n\n 一个springboot项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成base类加载器与restart类加载器。\n\n- base类加载器：用来加载jar包中的类，jar包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化\n- restart类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响\n\n 当springboot项目启动时，base类加载器执行，加载jar包中的信息后，restart类加载器执行，加载开发者制作的内容。当执行构建项目后，由于jar中的信息不会变化，因此base类加载器无需再次执行，所以仅仅运行restart类加载即可，也就是将开发者自己制作的内容重新加载就行了，这就完成了一次热部署的过程，也可以说热部署的过程实际上是重新加载restart类加载器中的信息。\n\n**总结**\n\n1. 使用开发者工具可以为当前项目开启热部署功能\n2. 使用构建项目操作对工程进行热部署\n\n**思考**\n\n 上述过程每次进行热部署都需要开发者手工操作，不管是点击按钮还是快捷键都需要开发者手工执行。这种操作的应用场景主要是在开发调试期，并且调试的代码处于不同的文件中，比如服务器启动了，我需要改4个文件中的内容，然后重启，等4个文件都改完了再执行热部署，使用一个快捷键就OK了。但是如果现在开发者要修改的内容就只有一个文件中的少量代码，这个时候代码修改完毕如果能够让程序自己执行热部署功能，就可以减少开发者的操作，也就是自动进行热部署，能这么做吗？是可以的。咱们下一节再说。\n\n\n\n#### KF-1-2.自动启动热部署\n\n 自动热部署其实就是设计一个开关，打开这个开关后，IDE工具就可以自动热部署。因此这个操作和IDE工具有关，以下以idea为例设置idea中启动热部署\n\n**步骤①**：设置自动构建项目\n\n 打开【File】，选择【settings…】,在面板左侧的菜单中找到【Compile】选项，然后勾选【Build project automatically】，意思是自动构建项目\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/817e75e64856e57c2f2418e03e79cae5.png)\n\n 自动构建项目选项勾选后\n\n**步骤②**：允许在程序运行时进行自动构建\n\n 使用快捷键【Ctrl】+【Alt】+【Shit】+【/】打开维护面板，选择第1项【Registry…】\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/b3d2fd50080956732c578a006dd6b6ba.png)\n\n 在选项中搜索comple，然后勾选对应项即可\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/38bab34bb1d8be809461bafcc7a90980.png)\n\n 这样程序在运行的时候就可以进行自动构建了，实现了热部署的效果。\n\n关注：如果你每敲一个字母，服务器就重新构建一次，这未免有点太频繁了，所以idea设置当idea工具失去焦点5秒后进行热部署。其实就是你从idea工具中切换到其他工具时进行热部署，比如改完程序需要到浏览器上去调试，这个时候idea就自动进行热部署操作。\n\n**总结**\n\n1. 自动热部署要开启自动构建项目\n2. 自动热部署要开启在程序运行时自动构建项目\n\n**思考**\n\n 现在已经实现了热部署了，但是到企业开发的时候你会发现，为了便于管理，在你的程序目录中除了有代码，还有可能有文档，如果你修改了一下文档，这个时候会进行热部署吗？不管是否进行热部署，这个过程我们需要自己控制才比较合理，那这个东西能控制吗？咱们下一节再说。\n\n#### KF-1-3.参与热部署监控的文件范围配置\n\n 通过修改项目中的文件，你可以发现其实并不是所有的文件修改都会激活热部署的，原因在于在开发者工具中有一组配置，当满足了配置中的条件后，才会启动热部署，配置中默认不参与热部署的目录信息如下\n\n- /META-INF/maven\n- /META-INF/resources\n- /resources\n- /static\n- /public\n- /templates\n\n 以上目录中的文件如果发生变化，是不参与热部署的。如果想修改配置，可以通过application.yml文件进行设定哪些文件不参与热部署操作\n\n```java\nspring:\n  devtools:\n    restart:\n      # 设置不参与热部署的文件或文件夹\n      exclude: static/**,public/**,config/application.yml\n```\n\n**总结**\n\n1. 通过配置可以修改不参与热部署的文件或目录\n\n**思考**\n\n 热部署功能是一个典型的开发阶段使用的功能，到了线上环境运行程序时，这个功能就没有意义了。能否关闭热部署功能呢？咱们下一节再说。\n\n#### KF-1-4.关闭热部署\n\n 线上环境运行时是不可能使用热部署功能的，所以需要强制关闭此功能，通过配置可以关闭此功能。\n\n```java\nspring:\n  devtools:\n    restart:\n      enabled: false\n```\n\n 如果当心配置文件层级过多导致相符覆盖最终引起配置失效，可以提高配置的层级，在更高层级中配置关闭热部署。例如在启动容器前通过系统属性设置关闭热部署功能。\n\n```java\n@SpringBootApplication\npublic class SSMPApplication {\n    public static void main(String[] args) {\n        System.setProperty(\"spring.devtools.restart.enabled\",\"false\");\n        SpringApplication.run(SSMPApplication.class);\n    }\n}\n```\n\n 其实上述担心略微有点多余，因为线上环境的维护是不可能出现修改代码的操作的，这么做唯一的作用是降低资源消耗，毕竟那双盯着你项目是不是产生变化的眼睛只要闭上了，就不具有热部署功能了，这个开关的作用就是禁用对应功能。\n\n**总结**\n\n1. 通过配置可以关闭热部署功能降低线上程序的资源消耗\n\n### KF-2.配置高级\n\n 进入开发实用篇第二章内容，配置高级，其实配置在基础篇讲了一部分，在运维实用篇讲了一部分，这里还要讲，讲的东西有什么区别呢？距离开发过程越来越接近，解决的问题也越来越靠近线上环境，下面就开启本章的学习。\n\n#### KF-2-1.@ConfigurationProperties\n\n 在基础篇学习了@ConfigurationProperties注解，此注解的作用是用来为bean绑定属性的。开发者可以在yml配置文件中以对象的格式添加若干属性\n\n```java\nservers:\n  ip-address: 192.168.0.1 \n  port: 2345\n  timeout: -1\n```\n\n 然后再开发一个用来封装数据的实体类，注意要提供属性对应的setter方法\n\n```java\n@Component\n@Data\npublic class ServerConfig {\n    private String ipAddress;\n    private int port;\n    private long timeout;\n}\n```\n\n 使用@ConfigurationProperties注解就可以将配置中的属性值关联到开发的模型类上\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\npublic class ServerConfig {\n    private String ipAddress;\n    private int port;\n    private long timeout;\n}\n```\n\n 这样加载对应bean的时候就可以直接加载配置属性值了。但是目前我们学的都是给自定义的bean使用这种形式加载属性值，如果是第三方的bean呢？能不能用这种形式加载属性值呢？为什么会提出这个疑问？原因就在于当前@ConfigurationProperties注解是写在类定义的上方，而第三方开发的bean源代码不是你自己书写的，你也不可能到源代码中去添加@ConfigurationProperties注解，这种问题该怎么解决呢？下面就来说说这个问题。\n\n 使用@ConfigurationProperties注解其实可以为第三方bean加载属性，格式特殊一点而已。\n\n**步骤①**：使用@Bean注解定义第三方bean\n\n```java\n@Bean\npublic DruidDataSource datasource(){\n    DruidDataSource ds = new DruidDataSource();\n    return ds;\n}\n```\n\n**步骤②**：在yml中定义要绑定的属性，注意datasource此时全小写\n\n```java\ndatasource:\n  driverClassName: com.mysql.jdbc.Driver\n```\n\n**步骤③**：使用@ConfigurationProperties注解为第三方bean进行属性绑定，注意前缀是全小写的datasource\n\n```java\n@Bean\n@ConfigurationProperties(prefix = \"datasource\")\npublic DruidDataSource datasource(){\n    DruidDataSource ds = new DruidDataSource();\n    return ds;\n}\n```\n\n 操作方式完全一样，只不过@ConfigurationProperties注解不仅能添加到类上，还可以添加到方法上，添加到类上是为spring容器管理的当前类的对象绑定属性，添加到方法上是为spring容器管理的当前方法的返回值对象绑定属性，其实本质上都一样。\n\n 做到这其实就出现了一个新的问题，目前我们定义bean不是通过类注解定义就是通过@Bean定义，使用@ConfigurationProperties注解可以为bean进行属性绑定，那在一个业务系统中，哪些bean通过注解@ConfigurationProperties去绑定属性了呢？因为这个注解不仅可以写在类上，还可以写在方法上，所以找起来就比较麻烦了。为了解决这个问题，spring给我们提供了一个全新的注解，专门标注使用@ConfigurationProperties注解绑定属性的bean是哪些。这个注解叫做@EnableConfigurationProperties。具体如何使用呢？\n\n**步骤①**：在配置类上开启@EnableConfigurationProperties注解，并标注要使用@ConfigurationProperties注解绑定属性的类\n\n```java\n@SpringBootApplication\n@EnableConfigurationProperties(ServerConfig.class)\npublic class Springboot13ConfigurationApplication {\n}\n```\n\n**步骤②**：在对应的类上直接使用@ConfigurationProperties进行属性绑定\n\n```java\n@Data\n@ConfigurationProperties(prefix = \"servers\")\npublic class ServerConfig {\n    private String ipAddress;\n    private int port;\n    private long timeout;\n}\n```\n\n 有人感觉这没区别啊？注意观察，现在绑定属性的ServerConfig类并没有声明@Component注解。当使用@EnableConfigurationProperties注解时，spring会默认将其标注的类定义为bean，因此无需再次声明@Component注解了。\n\n 最后再说一个小技巧，使用@ConfigurationProperties注解时，会出现一个提示信息\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/4174963f93c068c504487393b054a65b.png)\n\n 出现这个提示后只需要添加一个坐标此提醒就消失了\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n</dependency>\n```\n\n**总结**\n\n1. 使用@ConfigurationProperties可以为使用@Bean声明的第三方bean绑定属性\n2. 当使用@EnableConfigurationProperties声明进行属性绑定的bean后，无需使用@Component注解再次进行bean声明\n\n#### KF-2-2.宽松绑定/松散绑定\n\n 在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在yml配置文件中将datasource修改为dataSource，如下：\n\n```java\ndataSource:\n  driverClassName: com.mysql.jdbc.Driver\n```\n\n 此时程序可以正常运行，然后又将代码中的前缀datasource修改为dataSource，如下：\n\n```java\n@Bean\n@ConfigurationProperties(prefix = \"dataSource\")\npublic DruidDataSource datasource(){\n    DruidDataSource ds = new DruidDataSource();\n    return ds;\n}\n```\n\n 此时就发生了编译错误，而且并不是idea工具导致的，运行后依然会出现问题，配置属性名dataSource是无效的\n\n```java\nConfiguration property name 'dataSource' is not valid:\n\n    Invalid characters: 'S'\n    Bean: datasource\n    Reason: Canonical names should be kebab-case ('-' separated), lowercase alpha-numeric characters and must start with a letter\n\nAction:\nModify 'dataSource' so that it conforms to the canonical names requirements.\n```\n\n 为什么会出现这种问题，这就要来说一说springboot进行属性绑定时的一个重要知识点了，有关属性名称的宽松绑定，也可以称为宽松绑定。\n\n 什么是宽松绑定？实际上是springboot进行编程时人性化设计的一种体现，即配置文件中的命名格式与变量名的命名格式可以进行格式上的最大化兼容。兼容到什么程度呢？几乎主流的命名格式都支持，例如：\n\n 在ServerConfig中的ipAddress属性名\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\npublic class ServerConfig {\n    private String ipAddress;\n}\n```\n\n 可以与下面的配置属性名规则全兼容\n\n```java\nservers:\n  ipAddress: 192.168.0.2       # 驼峰模式\n  ip_address: 192.168.0.2      # 下划线模式\n  ip-address: 192.168.0.2      # 烤肉串模式\n  IP_ADDRESS: 192.168.0.2      # 常量模式\n```\n\n 也可以说，以上4种模式最终都可以匹配到ipAddress这个属性名。为什么这样呢？原因就是在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与java代码中的属性名进行忽略大小写的等值匹配，以上4种命名去掉下划线中划线忽略大小写后都是一个词ipaddress，java代码中的属性名忽略大小写后也是ipaddress，这样就可以进行等值匹配了，这就是为什么这4种格式都能匹配成功的原因。不过springboot官方推荐使用烤肉串模式，也就是中划线模式。\n\n 到这里我们掌握了一个知识点，就是命名的规范问题。再来看开始出现的编程错误信息\n\n```java\nConfiguration property name 'dataSource' is not valid:\n\n    Invalid characters: 'S'\n    Bean: datasource\n    Reason: Canonical names should be kebab-case ('-' separated), lowercase alpha-numeric characters and must start with a letter\n\nAction:\nModify 'dataSource' so that it conforms to the canonical names requirements.\n```\n\n 其中Reason描述了报错的原因，规范的名称应该是烤肉串(kebab)模式(case)，即使用-分隔，使用小写字母数字作为标准字符，且必须以字母开头。然后再看我们写的名称dataSource，就不满足上述要求。闹了半天，在书写前缀时，这个词不是随意支持的，必须使用上述标准。编程写了这么久，基本上编程习惯都养成了，到这里又被springboot教育了，没辙，谁让人家东西好用呢，按照人家的要求写吧。\n\n 最后说一句，以上规则仅针对springboot中@ConfigurationProperties注解进行属性绑定时有效，对@Value注解进行属性映射无效。有人就说，那我不用你不就行了？不用，你小看springboot的推广能力了，到原理篇我们看源码时，你会发现内部全是这玩意儿，算了，拿人手短吃人嘴短，认怂吧。\n\n**总结**\n\n1. @ConfigurationProperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上\n2. @Value注解不支持松散绑定规则\n3. 绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符\n\n#### KF-2-3.常用计量单位绑定\n\n 在前面的配置中，我们书写了如下配置值，其中第三项超时时间timeout描述了服务器操作超时时间，当前值是-1表示永不超时。\n\n```java\nservers:\n  ip-address: 192.168.0.1 \n  port: 2345\n  timeout: -1\n```\n\n 但是每个人都这个值的理解会产生不同，比如线上服务器完成一次主从备份，配置超时时间240，这个240如果单位是秒就是超时时间4分钟，如果单位是分钟就是超时时间4小时。面对一次线上服务器的主从备份，设置4分钟，简直是开玩笑，别说拷贝过程，备份之前的压缩过程4分钟也搞不定，这个时候问题就来了，怎么解决这个误会？\n\n 除了加强约定之外，springboot充分利用了JDK8中提供的全新的用来表示计量单位的新数据类型，从根本上解决这个问题。以下模型类中添加了两个JDK8中新增的类，分别是Duration和DataSize\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\npublic class ServerConfig {\n    @DurationUnit(ChronoUnit.HOURS)\n    private Duration serverTimeOut;\n    @DataSizeUnit(DataUnit.MEGABYTES)\n    private DataSize dataSize;\n}\n```\n\n**Duration**：表示时间间隔，可以通过@DurationUnit注解描述时间单位，例如上例中描述的单位为小时（ChronoUnit.HOURS）\n\n**DataSize**：表示存储空间，可以通过@DataSizeUnit注解描述存储空间单位，例如上例中描述的单位为MB（DataUnit.MEGABYTES）\n\n 使用上述两个单位就可以有效避免因沟通不同步或文档不健全导致的信息不对称问题，从根本上解决了问题，避免产生误读。\n\nDruation常用单位如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/feed3abc8ca2260e57f08de4685c30a5.png)\n\nDataSize常用单位如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/8a4792d075a4e42fb0ca906bb2b37b1a.png)\n\n#### KF-2-4.校验\n\n 目前我们在进行属性绑定时可以通过松散绑定规则在书写时放飞自我了，但是在书写时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要int类型，配置中给了非法的数值，例如写一个“a\"，这种数据肯定无法有效的绑定，还会引发错误。 SpringBoot给出了强大的数据校验功能，可以有效的避免此类问题的发生。在JAVAEE的JSR303规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架，此处使用Hibernate提供的校验框架来作为实现进行数据校验。书写应用格式非常固定，话不多说，直接上步骤\n\n**步骤①**：开启校验框架\n\n```java\n<!--1.导入JSR303规范-->\n<dependency>\n    <groupId>javax.validation</groupId>\n    <artifactId>validation-api</artifactId>\n</dependency>\n<!--使用hibernate框架提供的校验器做实现-->\n<dependency>\n    <groupId>org.hibernate.validator</groupId>\n    <artifactId>hibernate-validator</artifactId>\n</dependency>\n```\n\n**步骤②**：在需要开启校验功能的类上使用注解@Validated开启校验功能\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\n//开启对当前bean的属性注入校验\n@Validated\npublic class ServerConfig {\n}\n```\n\n**步骤③**：对具体的字段设置校验规则\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"servers\")\n//开启对当前bean的属性注入校验\n@Validated\npublic class ServerConfig {\n    //设置具体的规则\n    @Max(value = 8888,message = \"最大值不能超过8888\")\n    @Min(value = 202,message = \"最小值不能低于202\")\n    private int port;\n}\n```\n\n 通过设置数据格式校验，就可以有效避免非法数据加载，其实使用起来还是挺轻松的，基本上就是一个格式。\n\n**总结**\n\n1. 开启Bean属性校验功能一共3步：导入JSR303与Hibernate校验框架坐标、使用@Validated注解启用校验功能、使用具体校验规则规范数据校验格式\n\n#### KF-2-5.数据类型转换\n\n 有关spring属性注入的问题到这里基本上就讲完了，但是最近一名开发者向我咨询了一个问题，我觉得需要给各位学习者分享一下。在学习阶段其实我们遇到的问题往往复杂度比较低，单一性比较强，但是到了线上开发时，都是综合性的问题，而这个开发者遇到的问题就是由于bean的属性注入引发的灾难。\n\n 先把问题描述一下，这位开发者连接数据库正常操作，但是运行程序后显示的信息是密码错误。\n\n```java\njava.sql.SQLException: Access denied for user 'root'@'localhost' (using password: YES)\n```\n\n 其实看到这个报错，几乎所有的学习者都能分辨出来，这是用户名和密码不匹配，就就是密码输入错了，但是问题就在于密码并没有输入错误，这就比较讨厌了。给的报错信息无法帮助你有效的分析问题，甚至会给你带到沟里。如果是初学者，估计这会心态就崩了，我密码没错啊，你怎么能说我有错误呢？来看看用户名密码的配置是如何写的：\n\n```java\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    username: root\n    password: 0127\n```\n\n 这名开发者的生日是1月27日，所以密码就使用了0127，其实问题就出在这里了。\n\n 之前在基础篇讲属性注入时，提到过类型相关的知识，在整数相关知识中有这么一句话，**支持二进制，八进制，十六进制**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/470025fe2434f6e23f760e11f17e3942.png)\n\n 这个问题就处在这里了，因为0127在开发者眼中是一个字符串“0127”，但是在springboot看来，这就是一个数字，而且是一个八进制的数字。当后台使用String类型接收数据时，如果配置文件中配置了一个整数值，他是先安装整数进行处理，读取后再转换成字符串。巧了，0127撞上了八进制的格式，所以最终以十进制数字87的结果存在了。\n\n 这里提两个注意点，第一，字符串标准书写加上引号包裹，养成习惯，第二，遇到0开头的数据多注意吧。\n\n**总结**\n\n1. yaml文件中对于数字的定义支持进制书写格式，如需使用字符串请使用引号明确标注\n\n### KF-3.测试\n\n 说完bean配置相关的内容，下面要对前面讲过的一个知识做加强了，测试。测试是保障程序正确性的唯一屏障，在企业级开发中更是不可缺少，但是由于测试代码往往不产生实际效益，所以一些小型公司并不是很关注，导致一些开发者从小型公司进入中大型公司后，往往这一块比较短板，所以还是要拿出来把这一块知识好好说说，做一名专业的开发人员。\n\n#### KF-3-1.加载测试专用属性\n\n 测试过程本身并不是一个复杂的过程，但是很多情况下测试时需要模拟一些线上情况，或者模拟一些特殊情况。如果当前环境按照线上环境已经设定好了，例如是下面的配置\n\n```java\nenv:\n  maxMemory: 32GB\n  minMemory: 16GB\n```\n\n 但是你现在想测试对应的兼容性，需要测试如下配置\n\n```java\nenv:\n  maxMemory: 16GB\n  minMemory: 8GB\n```\n\n 这个时候我们能不能每次测试的时候都去修改源码application.yml中的配置进行测试呢？显然是不行的。每次测试前改过来，每次测试后改回去，这太麻烦了。于是我们就想，需要在测试环境中创建一组临时属性，去覆盖我们源码中设定的属性，这样测试用例就相当于是一个独立的环境，能够独立测试，这样就方便多了。\n\n**临时属性**\n\n springboot已经为我们开发者早就想好了这种问题该如何解决，并且提供了对应的功能入口。在测试用例程序中，可以通过对注解@SpringBootTest添加属性来模拟临时属性，具体如下：\n\n```java\n//properties属性可以为当前测试用例添加临时的属性配置\n@SpringBootTest(properties = {\"test.prop=testValue1\"})\npublic class PropertiesAndArgsTest {\n\n    @Value(\"${test.prop}\")\n    private String msg;\n    \n    @Test\n    void testProperties(){\n        System.out.println(msg);\n    }\n}\n```\n\n 使用注解@SpringBootTest的properties属性就可以为当前测试用例添加临时的属性，覆盖源码配置文件中对应的属性值进行测试。\n\n**临时参数**\n\n 除了上述这种情况，在前面讲解使用命令行启动springboot程序时讲过，通过命令行参数也可以设置属性值。而且线上启动程序时，通常都会添加一些专用的配置信息。作为运维人员他们才不懂java，更不懂这些配置的信息具体格式该怎么写，那如果我们作为开发者提供了对应的书写内容后，能否提前测试一下这些配置信息是否有效呢？当时是可以的，还是通过注解@SpringBootTest的另一个属性来进行设定。\n\n```java\n//args属性可以为当前测试用例添加临时的命令行参数\n@SpringBootTest(args={\"--test.prop=testValue2\"})\npublic class PropertiesAndArgsTest {\n    \n    @Value(\"${test.prop}\")\n    private String msg;\n    \n    @Test\n    void testProperties(){\n        System.out.println(msg);\n    }\n}\n```\n\n 使用注解@SpringBootTest的args属性就可以为当前测试用例模拟命令行参数并进行测试。\n\n 说到这里，好奇宝宝们肯定就有新问题了，如果两者共存呢？其实如果思考一下配置属性与命令行参数的加载优先级，这个结果就不言而喻了。在属性加载的优先级设定中，有明确的优先级设定顺序，还记得下面这个顺序吗？\n\n\n&lt;i![img](https://img-blog.csdnimg.cn/img_convert/25de6a465dd96fb95753c588a6476eae.png)\n\n 在这个属性加载优先级的顺序中，明确规定了命令行参数的优先级排序是11，而配置属性的优先级是3，结果不言而喻了，args属性配置优先于properties属性配置加载。\n\n 到这里我们就掌握了如果在测试用例中去模拟临时属性的设定。\n\n**总结**\n\n1. 加载测试临时属性可以通过注解@SpringBootTest的properties和args属性进行设定，此设定应用范围仅适用于当前测试用例\n\n**思考**\n\n 应用于测试环境的临时属性解决了，如果想在测试的时候临时加载一些bean能不做呢？也就是说我测试时，想搞一些独立的bean出来，专门应用于测试环境，能否实现呢？咱们下一节再讲。\n\n#### KF-3-2.加载测试专用配置\n\n 上一节提出了临时配置一些专用于测试环境的bean的需求，这一节我们就来解决这个问题。\n\n 学习过Spring的知识，我们都知道，其实一个spring环境中可以设置若干个配置文件或配置类，若干个配置信息可以同时生效。现在我们的需求就是在测试环境中再添加一个配置类，然后启动测试环境时，生效此配置就行了。其实做法和spring环境中加载多个配置信息的方式完全一样。具体操作步骤如下：\n\n**步骤①**：在测试包test中创建专用的测试环境配置类\n\n```java\n@Configuration\npublic class MsgConfig {\n    @Bean\n    public String msg(){\n        return \"bean msg\";\n    }\n}\n```\n\n 上述配置仅用于演示当前实验效果，实际开发可不能这么注入String类型的数据\n\n**步骤②**：在启动测试环境时，导入测试环境专用的配置类，使用@Import注解即可实现\n\n```java\n@SpringBootTest\n@Import({MsgConfig.class})\npublic class ConfigurationTest {\n\n    @Autowired\n    private String msg;\n\n    @Test\n    void testConfiguration(){\n        System.out.println(msg);\n    }\n}\n```\n\n 到这里就通过@Import属性实现了基于开发环境的配置基础上，对配置进行测试环境的追加操作，实现了1+1的配置环境效果。这样我们就可以实现每一个不同的测试用例加载不同的bean的效果，丰富测试用例的编写，同时不影响开发环境的配置。\n\n**总结**\n\n1. 定义测试环境专用的配置类，然后通过@Import注解在具体的测试中导入临时的配置，例如测试用例，方便测试过程，且上述配置不影响其他的测试类环境\n\n**思考**\n\n 当前我们已经可以实现业务层和数据层的测试，并且通过临时配置，控制每个测试用例加载不同的测试数据。但是实际企业开发不仅要保障业务层与数据层的功能安全有效，也要保障表现层的功能正常。但是我们目的对表现层的测试都是通过postman手工测试的，并没有在打包过程中体现表现层功能被测试通过。能否在测试用例中对表现层进行功能测试呢？还真可以，咱们下一节再讲。\n\n#### KF-3-3.Web环境模拟测试\n\n 在测试中对表现层功能进行测试需要一个基础和一个功能。所谓的一个基础是运行测试程序时，必须启动web环境，不然没法测试web功能。一个功能是必须在测试程序中具备发送web请求的能力，不然无法实现web功能的测试。所以在测试用例中测试表现层接口这项工作就转换成了两件事，一，如何在测试类中启动web测试，二，如何在测试类中发送web请求。下面一件事一件事进行，先说第一个\n\n**测试类中启动web环境**\n\n 每一个springboot的测试类上方都会标准@SpringBootTest注解，而注解带有一个属性，叫做webEnvironment。通过该属性就可以设置在测试用例中启动web环境，具体如下：\n\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class WebTest {\t\n}\n```\n\n 测试类中启动web环境时，可以指定启动的Web环境对应的端口，springboot提供了4种设置值，分别如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/4b838b46302c9d4393fe48db47b4c545.png)\n\n- MOCK：根据当前设置确认是否启动web环境，例如使用了Servlet的API就启动web环境，属于适配性的配置\n- DEFINED_PORT：使用自定义的端口作为web服务器端口\n- RANDOM_PORT：使用随机端口作为web服务器端口\n- NONE：不启动web环境\n\n 通过上述配置，现在启动测试程序时就可以正常启用web环境了，建议大家测试时使用RANDOM_PORT，避免代码中因为写死设定引发线上功能打包测试时由于端口冲突导致意外现象的出现。就是说你程序中写了用8080端口，结果线上环境8080端口被占用了，结果你代码中所有写的东西都要改，这就是写死代码的代价。现在你用随机端口就可以测试出来你有没有这种问题的隐患了。\n\n 测试环境中的web环境已经搭建好了，下面就可以来解决第二个问题了，如何在程序代码中发送web请求。\n\n**测试类中发送请求**\n\n 对于测试类中发送请求，其实java的API就提供对应的功能，只不过平时各位小伙伴接触的比较少，所以较为陌生。springboot为了便于开发者进行对应的功能开发，对其又进行了包装，简化了开发步骤，具体操作如下：\n\n**步骤①**：在测试类中开启web虚拟调用功能，通过注解@AutoConfigureMockMvc实现此功能的开启\n\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n//开启虚拟MVC调用\n@AutoConfigureMockMvc\npublic class WebTest {\n}\n```\n\n**步骤②**：定义发起虚拟调用的对象MockMVC，通过自动装配的形式初始化对象\n\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n//开启虚拟MVC调用\n@AutoConfigureMockMvc\npublic class WebTest {\n\n    @Test\n    void testWeb(@Autowired MockMvc mvc) {\n    }\n}\n```\n\n**步骤③**：创建一个虚拟请求对象，封装请求的路径，并使用MockMVC对象发送对应请求\n\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n//开启虚拟MVC调用\n@AutoConfigureMockMvc\npublic class WebTest {\n\n    @Test\n    void testWeb(@Autowired MockMvc mvc) throws Exception {\n        //http://localhost:8080/books\n        //创建虚拟请求，当前访问/books\n        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n        //执行对应的请求\n        mvc.perform(builder);\n    }\n}\n```\n\n 执行测试程序，现在就可以正常的发送/books对应的请求了，注意访问路径不要写http://localhost:8080/books，因为前面的服务器IP地址和端口使用的是当前虚拟的web环境，无需指定，仅指定请求的具体路径即可。\n\n**总结**\n\n1. 在测试类中测试web层接口要保障测试类启动时启动web容器，使用@SpringBootTest注解的webEnvironment属性可以虚拟web环境用于测试\n2. 为测试方法注入MockMvc对象，通过MockMvc对象可以发送虚拟请求，模拟web请求调用过程\n\n**思考**\n\n 目前已经成功的发送了请求，但是还没有起到测试的效果，测试过程必须出现预计值与真实值的比对结果才能确认测试结果是否通过，虚拟请求中能对哪些请求结果进行比对呢？咱们下一节再讲。\n\n**web环境请求结果比对**\n\n 上一节已经在测试用例中成功的模拟出了web环境，并成功的发送了web请求，本节就来解决发送请求后如何比对发送结果的问题。其实发完请求得到的信息只有一种，就是响应对象。至于响应对象中包含什么，就可以比对什么。常见的比对内容如下：\n\n- \n 响应状态匹配\n @Test\nvoid testStatus(@Autowired MockMvc mvc) throws Exception {\n    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n    ResultActions action = mvc.perform(builder);\n    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n    //定义本次调用的预期值\n    StatusResultMatchers status = MockMvcResultMatchers.status();\n    //预计本次调用时成功的：状态200\n    ResultMatcher ok = status.isOk();\n    //添加预计值到本次调用过程中进行匹配\n    action.andExpect(ok);\n}\n- \n 响应体匹配（非json数据格式）\n @Test\nvoid testBody(@Autowired MockMvc mvc) throws Exception {\n    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n    ResultActions action = mvc.perform(builder);\n    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n    //定义本次调用的预期值\n    ContentResultMatchers content = MockMvcResultMatchers.content();\n    ResultMatcher result = content.string(\"springboot2\");\n    //添加预计值到本次调用过程中进行匹配\n    action.andExpect(result);\n}\n- \n 响应体匹配（json数据格式，开发中的主流使用方式）\n @Test\nvoid testJson(@Autowired MockMvc mvc) throws Exception {\n    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n    ResultActions action = mvc.perform(builder);\n    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n    //定义本次调用的预期值\n    ContentResultMatchers content = MockMvcResultMatchers.content();\n    ResultMatcher result = content.json(\"{\\\"id\\\":1,\\\"name\\\":\\\"springboot2\\\",\\\"type\\\":\\\"springboot\\\"}\");\n    //添加预计值到本次调用过程中进行匹配\n    action.andExpect(result);\n}\n- \n 响应头信息匹配\n @Test\nvoid testContentType(@Autowired MockMvc mvc) throws Exception {\n    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n    ResultActions action = mvc.perform(builder);\n    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败\n    //定义本次调用的预期值\n    HeaderResultMatchers header = MockMvcResultMatchers.header();\n    ResultMatcher contentType = header.string(\"Content-Type\", \"application/json\");\n    //添加预计值到本次调用过程中进行匹配\n    action.andExpect(contentType);\n}\n\n 基本上齐了，头信息，正文信息，状态信息都有了，就可以组合出一个完美的响应结果比对结果了。以下范例就是三种信息同时进行匹配校验，也是一个完整的信息匹配过程。\n\n```java\n@Test\nvoid testGetById(@Autowired MockMvc mvc) throws Exception {\n    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(\"/books\");\n    ResultActions action = mvc.perform(builder);\n\n    StatusResultMatchers status = MockMvcResultMatchers.status();\n    ResultMatcher ok = status.isOk();\n    action.andExpect(ok);\n\n    HeaderResultMatchers header = MockMvcResultMatchers.header();\n    ResultMatcher contentType = header.string(\"Content-Type\", \"application/json\");\n    action.andExpect(contentType);\n\n    ContentResultMatchers content = MockMvcResultMatchers.content();\n    ResultMatcher result = content.json(\"{\\\"id\\\":1,\\\"name\\\":\\\"springboot\\\",\\\"type\\\":\\\"springboot\\\"}\");\n    action.andExpect(result);\n}\n```\n\n**总结**\n\n1. web虚拟调用可以对本地虚拟请求的返回响应信息进行比对，分为响应头信息比对、响应体信息比对、响应状态信息比对\n\n#### KF-3-4.数据层测试回滚\n\n 当前我们的测试程序可以完美的进行表现层、业务层、数据层接口对应的功能测试了，但是测试用例开发完成后，在打包的阶段由于test生命周期属于必须被运行的生命周期，如果跳过会给系统带来极高的安全隐患，所以测试用例必须执行。但是新的问题就呈现了，测试用例如果测试时产生了事务提交就会在测试过程中对数据库数据产生影响，进而产生垃圾数据。这个过程不是我们希望发生的，作为开发者测试用例该运行运行，但是过程中产生的数据不要在我的系统中留痕，这样该如何处理呢？\n\n springboot早就为开发者想到了这个问题，并且针对此问题给出了最简解决方案，在原始测试用例中添加注解@Transactional即可实现当前测试用例的事务不提交。当程序运行后，只要注解@Transactional出现的位置存在注解@SpringBootTest，springboot就会认为这是一个测试程序，无需提交事务，所以也就可以避免事务的提交。\n\n```java\n@SpringBootTest\n@Transactional\n@Rollback(true)\npublic class DaoTest {\n    @Autowired\n    private BookService bookService;\n\n    @Test\n    void testSave(){\n        Book book = new Book();\n        book.setName(\"springboot3\");\n        book.setType(\"springboot3\");\n        book.setDescription(\"springboot3\");\n\n        bookService.save(book);\n    }\n}\n```\n\n 如果开发者想提交事务，也可以，再添加一个@RollBack的注解，设置回滚状态为false即可正常提交事务，是不是很方便？springboot在辅助开发者日常工作这一块展现出了惊人的能力，实在太贴心了。\n\n**总结**\n\n1. 在springboot的测试类中通过添加注解@Transactional来阻止测试用例提交事务\n2. 通过注解@Rollback控制springboot测试类执行结果是否提交事务，需要配合注解@Transactional使用\n\n**思考**\n\n 当前测试程序已经近乎完美了，但是由于测试用例中书写的测试数据属于固定数据，往往失去了测试的意义，开发者可以针对测试用例进行针对性开发，这样就有可能出现测试用例不能完美呈现业务逻辑代码是否真实有效的达成业务目标的现象，解决方案其实很容易想，测试用例的数据只要随机产生就可以了，能实现吗？咱们下一节再讲。\n\n#### KF-3-5.测试用例数据设定\n\n 对于测试用例的数据固定书写肯定是不合理的，springboot提供了在配置中使用随机值的机制，确保每次运行程序加载的数据都是随机的。具体如下：\n\n```java\ntestcase:\n  book:\n    id: ${random.int}\n    id2: ${random.int(10)}\n    type: ${random.int!5,10!}\n    name: ${random.value}\n    uuid: ${random.uuid}\n    publishTime: ${random.long}\n```\n\n 当前配置就可以在每次运行程序时创建一组随机数据，避免每次运行时数据都是固定值的尴尬现象发生，有助于测试功能的进行。数据的加载按照之前加载数据的形式，使用@ConfigurationProperties注解即可\n\n```java\n@Component\n@Data\n@ConfigurationProperties(prefix = \"testcase.book\")\npublic class BookCase {\n    private int id;\n    private int id2;\n    private int type;\n    private String name;\n    private String uuid;\n    private long publishTime;\n}\n```\n\n 对于随机值的产生，还有一些小的限定规则，比如产生的数值性数据可以设置范围等，具体如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/7cd73612de2996b4bec6da576b2dab9c.png)\n\n- ${random.int}表示随机整数\n- ${random.int(10)}表示10以内的随机数\n- ${random.int(10,20)}表示10到20的随机数\n- 其中()可以是任意字符，例如[]，!!均可\n\n**总结**\n\n1. 使用随机数据可以替换测试用例中书写的固定数据，提高测试用例中的测试数据有效性\n\n### KF-4.数据层解决方案\n\n 开发实用篇前三章基本上是开胃菜，从第四章开始，开发实用篇进入到了噩梦难度了，从这里开始，不再是单纯的在springboot内部搞事情了，要涉及到很多相关知识。本章节主要内容都是和数据存储与读取相关，前期学习的知识与数据层有关的技术基本上都围绕在数据库这个层面上，所以本章要讲的第一个大的分支就是SQL解决方案相关的内容，除此之外，数据的来源还可以是非SQL技术相关的数据操作，因此第二部分围绕着NOSQL解决方案讲解。至于什么是NOSQL解决方案，讲到了再说吧。下面就从SQL解决方案说起。\n\n#### KF-4-1.SQL\n\n 回忆一下之前做SSMP整合的时候数据层解决方案涉及到了哪些技术？MySQL数据库与MyBatisPlus框架，后面又学了Druid数据源的配置，所以现在数据层解决方案可以说是Mysql+Druid+MyBatisPlus。而三个技术分别对应了数据层操作的三个层面：\n\n- 数据源技术：Druid\n- 持久化技术：MyBatisPlus\n- 数据库技术：MySQL\n\n 下面的研究就分为三个层面进行研究，对应上面列出的三个方面，咱们就从第一个数据源技术开始说起。\n\n##### 数据源技术\n\n 目前我们使用的数据源技术是Druid，运行时可以在日志中看到对应的数据源初始化信息，具体如下：\n\n```java\nINFO 28600 --- [           main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSource\nINFO 28600 --- [           main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} inited\n```\n\n 如果不使用Druid数据源，程序运行后是什么样子呢？是独立的数据库连接对象还是有其他的连接池技术支持呢？将Druid技术对应的starter去掉再次运行程序可以在日志中找到如下初始化信息：\n\n```java\nINFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\nINFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n```\n\n 虽然没有DruidDataSource相关的信息了，但是我们发现日志中有HikariDataSource这个信息，就算不懂这是个什么技术，看名字也能看出来，以DataSource结尾的名称，这一定是一个数据源技术。我们又没有手工添加这个技术，这个技术哪里来的呢？这就是这一节要讲的知识，springboot内嵌数据源。\n\n 数据层技术是每一个企业级应用程序都会用到的，而其中必定会进行数据库连接的管理。springboot根据开发者的习惯出发，开发者提供了数据源技术，就用你提供的，开发者没有提供，那总不能手工管理一个一个的数据库连接对象啊，怎么办？我给你一个默认的就好了，这样省心又省事，大家都方便。\n\n springboot提供了3款内嵌数据源技术，分别如下：\n\n- HikariCP\n- Tomcat提供DataSource\n- Commons DBCP\n\n 第一种，HikartCP，这是springboot官方推荐的数据源技术，作为默认内置数据源使用。啥意思？你不配置数据源，那就用这个。\n\n 第二种，Tomcat提供的DataSource，如果不想用HikartCP，并且使用tomcat作为web服务器进行web程序的开发，使用这个。为什么是Tomcat，不是其他web服务器呢？因为web技术导入starter后，默认使用内嵌tomcat，既然都是默认使用的技术了，那就一用到底，数据源也用它的。有人就提出怎么才能不使用HikartCP用tomcat提供的默认数据源对象呢？把HikartCP技术的坐标排除掉就OK了。\n\n 第三种，DBCP，这个使用的条件就更苛刻了，既不使用HikartCP也不使用tomcat的DataSource时，默认给你用这个。\n\n springboot这心操的，也是稀碎啊，就怕你自己管不好连接对象，给你一顿推荐，真是开发界的最强辅助。既然都给你奶上了，那就受用吧，怎么配置使用这些东西呢？之前我们配置druid时使用druid的starter对应的配置如下：\n\n```java\nspring:\n  datasource:\n    druid:\t\n   \t  url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n```\n\n 换成是默认的数据源HikariCP后，直接吧druid删掉就行了，如下：\n\n```java\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    username: root\n    password: root\n```\n\n 当然，也可以写上是对hikari做的配置，但是url地址要单独配置，如下：\n\n```java\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    hikari:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n```\n\n 这就是配置hikari数据源的方式。如果想对hikari做进一步的配置，可以继续配置其独立的属性。例如：\n\n```java\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    hikari:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      username: root\n      password: root\n      maximum-pool-size: 50\n```\n\n 如果不想使用hikari数据源，使用tomcat的数据源或者DBCP配置格式也是一样的。学习到这里，以后我们做数据层时，数据源对象的选择就不再是单一的使用druid数据源技术了，可以根据需要自行选择。\n\n**总结**\n\n1. springboot技术提供了3种内置的数据源技术，分别是Hikari、tomcat内置数据源、DBCP\n\n##### 持久化技术\n\n 说完数据源解决方案，再来说一下持久化解决方案。springboot充分发挥其最强辅助的特征，给开发者提供了一套现成的数据层技术，叫做JdbcTemplate。其实这个技术不能说是springboot提供的，因为不使用springboot技术，一样能使用它，谁提供的呢？spring技术提供的，所以在springboot技术范畴中，这个技术也是存在的，毕竟springboot技术是加速spring程序开发而创建的。\n\n 这个技术其实就是回归到jdbc最原始的编程形式来进行数据层的开发，下面直接上操作步骤：\n\n**步骤①**：导入jdbc对应的坐标，记得是starter\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency\n```\n\n**步骤②**：自动装配JdbcTemplate对象\n\n```java\n@SpringBootTest\nclass Springboot15SqlApplicationTests {\n    @Test\n    void testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){\n    }\n}\n```\n\n**步骤③**：使用JdbcTemplate实现查询操作（非实体类封装数据的查询操作）\n\n```java\n@Test\nvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){\n    String sql = \"select * from tbl_book\";\n    List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);\n    System.out.println(maps);\n}\n```\n\n**步骤④**：使用JdbcTemplate实现查询操作（实体类封装数据的查询操作）\n\n```java\n@Test\nvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate){\n\n    String sql = \"select * from tbl_book\";\n    RowMapper<Book> rm = new RowMapper<Book>() {\n        @Override\n        public Book mapRow(ResultSet rs, int rowNum) throws SQLException {\n            Book temp = new Book();\n            temp.setId(rs.getInt(\"id\"));\n            temp.setName(rs.getString(\"name\"));\n            temp.setType(rs.getString(\"type\"));\n            temp.setDescription(rs.getString(\"description\"));\n            return temp;\n        }\n    };\n    List<Book> list = jdbcTemplate.query(sql, rm);\n    System.out.println(list);\n}\n```\n\n**步骤⑤**：使用JdbcTemplate实现增删改操作\n\n```java\n@Test\nvoid testJdbcTemplateSave(@Autowired JdbcTemplate jdbcTemplate){\n    String sql = \"insert into tbl_book values(3,'springboot1','springboot2','springboot3')\";\n    jdbcTemplate.update(sql);\n}\n```\n\n 如果想对JdbcTemplate对象进行相关配置，可以在yml文件中进行设定，具体如下：\n\n```java\nspring:\n  jdbc:\n    template:\n      query-timeout: -1   # 查询超时时间\n      max-rows: 500       # 最大行数\n      fetch-size: -1      # 缓存行数\n```\n\n**总结**\n\n1. SpringBoot内置JdbcTemplate持久化解决方案\n2. 使用JdbcTemplate需要导入spring-boot-starter-jdbc的坐标\n\n##### 数据库技术\n\n 截止到目前，springboot给开发者提供了内置的数据源解决方案和持久化解决方案，在数据层解决方案三件套中还剩下一个数据库，莫非springboot也提供有内置的解决方案？还真有，还不是一个，三个，这一节就来说说内置的数据库解决方案。\n\n springboot提供了3款内置的数据库，分别是\n\n- H2\n- HSQL\n- Derby\n\n 以上三款数据库除了可以独立安装之外，还可以像是tomcat服务器一样，采用内嵌的形式运行在spirngboot容器中。内嵌在容器中运行，那必须是java对象啊，对，这三款数据库底层都是使用java语言开发的。\n\n 我们一直使用MySQL数据库就挺好的，为什么有需求用这个呢？原因就在于这三个数据库都可以采用内嵌容器的形式运行，在应用程序运行后，如果我们进行测试工作，此时测试的数据无需存储在磁盘上，但是又要测试使用，内嵌数据库就方便了，运行在内存中，该测试测试，该运行运行，等服务器关闭后，一切烟消云散，多好，省得你维护外部数据库了。这也是内嵌数据库的最大优点，方便进行功能测试。\n\n 下面以H2数据库为例讲解如何使用这些内嵌数据库，操作步骤也非常简单，简单才好用嘛\n\n**步骤①**：导入H2数据库对应的坐标，一共2个\n\n```java\n<dependency>\n    <groupId>com.h2database</groupId>\n    <artifactId>h2</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n```\n\n**步骤②**：将工程设置为web工程，启动工程时启动H2数据库\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n**步骤③**：通过配置开启H2数据库控制台访问程序，也可以使用其他的数据库连接软件操作\n\n```java\nspring:\n  h2:\n    console:\n      enabled: true\n      path: /h2\n```\n\n web端访问路径/h2，访问密码123456，如果访问失败，先配置下列数据源，启动程序运行后再次访问/h2路径就可以正常访问了\n\n```java\ndatasource:\n  url: jdbc:h2:~/test\n  hikari:\n    driver-class-name: org.h2.Driver\n    username: sa\n    password: 123456\n```\n\n**步骤④**：使用JdbcTemplate或MyBatisPlus技术操作数据库\n\n（略）\n\n 其实我们只是换了一个数据库而已，其他的东西都不受影响。一个重要提醒，别忘了，上线时，把内存级数据库关闭，采用MySQL数据库作为数据持久化方案，关闭方式就是设置enabled属性为false即可。\n\n**总结**\n\n1. H2内嵌式数据库启动方式，添加坐标，添加配置\n2. H2数据库线上运行时请务必关闭\n\n 到这里SQL相关的数据层解决方案就讲完了，现在的可选技术就丰富的多了。\n\n- 数据源技术：Druid、Hikari、tomcat DataSource、DBCP\n- 持久化技术：MyBatisPlus、MyBatis、JdbcTemplate\n- 数据库技术：MySQL、H2、HSQL、Derby\n\n 现在开发程序时就可以在以上技术中任选一种组织成一套数据库解决方案了。\n\n#### KF-4-2.NoSQL\n\n SQL数据层解决方案说完了，下面来说收NoSQL数据层解决方案。这个NoSQL是什么意思呢？从字面来看，No表示否定，NoSQL就是非关系型数据库解决方案，意思就是数据该存存该取取，只是这些数据不放在关系型数据库中了，那放在哪里？自然是一些能够存储数据的其他相关技术中了，比如Redis等。本节讲解的内容就是springboot如何整合这些技术，在springboot官方文档中提供了10种相关技术的整合方案，我们将讲解国内市场上最流行的几款NoSQL数据库整合方案，分别是Redis、MongoDB、ES。\n\n 因为每个小伙伴学习这门课程的时候起点不同，为了便于各位学习者更好的学习，每种技术在讲解整合前都会先讲一下安装和基本使用，然后再讲整合。如果对某个技术比较熟悉的小伙伴可以直接跳过安装的学习过程，直接看整合方案即可。此外上述这些技术最佳使用方案都是在Linux服务器上部署，但是考虑到各位小伙伴的学习起点差异过大，所以下面的课程都是以Windows平台作为安装基础讲解，如果想看Linux版软件安装，可以再找到对应技术的学习文档查阅学习。\n\n##### SpringBoot整合Redis\n\n Redis是一款采用key-value数据存储格式的内存级NoSQL数据库，重点关注数据存储格式，是key-value格式，也就是键值对的存储形式。与MySQL数据库不同，MySQL数据库有表、有字段、有记录，Redis没有这些东西，就是一个名称对应一个值，并且数据以存储在内存中使用为主。什么叫以存储在内存中为主？其实Redis有它的数据持久化方案，分别是RDB和AOF，但是Redis自身并不是为了数据持久化而生的，主要是在内存中保存数据，加速数据访问的，所以说是一款内存级数据库。\n\n Redis支持多种数据存储格式，比如可以直接存字符串，也可以存一个map集合，list集合，后面会涉及到一些不同格式的数据操作，这个需要先学习一下才能进行整合，所以在基本操作中会介绍一些相关操作。下面就先安装，再操作，最后说整合\n\n\n windows版安装包下载地址：https://github.com/tporadowski/redis/releases\n\n 下载的安装包有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，这里就不介绍安装过程了，本课程采用的是msi一键安装的msi文件进行安装的。\n\n 啥是msi，其实就是一个文件安装包，不仅安装软件，还帮你把安装软件时需要的功能关联在一起，打包操作。比如如安装序列、创建和设置安装路径、设置系统依赖项、默认设定安装选项和控制安装过程的属性。说简单点就是一站式服务，安装过程一条龙操作一气呵成，就是为小白用户提供的软件安装程序。\n\n 安装完毕后会得到如下文件，其中有两个文件对应两个命令，是启动Redis的核心命令，需要再CMD命令行模式执行。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/da7d56d4e809e13e78463d23fa02e6d1.png)&gt;\n\n**启动服务器**\n\n```java\nredis-server.exe redis.windows.conf\n```\n\n 初学者无需调整服务器对外服务端口，默认6379。\n\n**启动客户端**\n\n```java\nredis-cli.exe\n```\n\n 如果启动redis服务器失败，可以先启动客户端，然后执行shutdown操作后退出，此时redis服务器就可以正常执行了。\n\n\n 服务器启动后，使用客户端就可以连接服务器，类似于启动完MySQL数据库，然后启动SQL命令行操作数据库。\n\n 放置一个字符串数据到redis中，先为数据定义一个名称，比如name,age等，然后使用命令set设置数据到redis服务器中即可\n\n```java\nset name itheima\nset age 12\n```\n\n 从redis中取出已经放入的数据，根据名称取，就可以得到对应数据。如果没有对应数据就会得到(nil)\n\n```java\nget name\nget age\n```\n\n 以上使用的数据存储是一个名称对应一个值，如果要维护的数据过多，可以使用别的数据存储结构。例如hash，它是一种一个名称下可以存储多个数据的存储模型，并且每个数据也可以有自己的二级存储名称。向hash结构中存储数据格式如下：\n\n```java\nhset a a1 aa1\t\t#对外key名称是a，在名称为a的存储模型中，a1这个key中保存了数据aa1\nhset a a2 aa2\n```\n\n 获取hash结构中的数据命令如下\n\n```java\nhget a a1\t\t\t#得到aa1\nhget a a2\t\t\t#得到aa2\n```\n\n 有关redis的基础操作就普及到这里，需要全面掌握redis技术，请参看相关教程学习。\n\n\n 在进行整合之前先梳理一下整合的思想，springboot整合任何技术其实就是在springboot中使用对应技术的API。如果两个技术没有交集，就不存在整合的概念了。所谓整合其实就是使用springboot技术去管理其他技术，几个问题是躲不掉的。\n\n 第一，需要先导入对应技术的坐标，而整合之后，这些坐标都有了一些变化\n\n 第二，任何技术通常都会有一些相关的设置信息，整合之后，这些信息如何写，写在哪是一个问题\n\n 第三，没有整合之前操作如果是模式A的话，整合之后如果没有给开发者带来一些便捷操作，那整合将毫无意义，所以整合后操作肯定要简化一些，那对应的操作方式自然也有所不同\n\n 按照上面的三个问题去思考springboot整合所有技术是一种通用思想，在整合的过程中会逐步摸索出整合的套路，而且适用性非常强，经过若干种技术的整合后基本上可以总结出一套固定思维。\n\n 下面就开始springboot整合redis，操作步骤如下：\n\n**步骤①**：导入springboot整合redis的starter坐标\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n 上述坐标可以在创建模块的时候通过勾选的形式进行选择，归属NoSQL分类中\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/16432b036726ebfa2f1d745a4d9512b9.png)\n\n**步骤②**：进行基础配置\n\n```java\nspring:\n  redis:\n    host: localhost\n    port: 6379\n```\n\n 操作redis，最基本的信息就是操作哪一台redis服务器，所以服务器地址属于基础配置信息，不可缺少。但是即便你不配置，目前也是可以用的。因为以上两组信息都有默认配置，刚好就是上述配置值。\n\n**步骤③**：使用springboot整合redis的专用客户端接口操作，此处使用的是RedisTemplate\n\n```java\n@SpringBootTest\nclass Springboot16RedisApplicationTests {\n    @Autowired\n    private RedisTemplate redisTemplate;\n    @Test\n    void set() {\n        ValueOperations ops = redisTemplate.opsForValue();\n        ops.set(\"age\",41);\n    }\n    @Test\n    void get() {\n        ValueOperations ops = redisTemplate.opsForValue();\n        Object age = ops.get(\"name\");\n        System.out.println(age);\n    }\n    @Test\n    void hset() {\n        HashOperations ops = redisTemplate.opsForHash();\n        ops.put(\"info\",\"b\",\"bb\");\n    }\n    @Test\n    void hget() {\n        HashOperations ops = redisTemplate.opsForHash();\n        Object val = ops.get(\"info\", \"b\");\n        System.out.println(val);\n    }\n}\n```\n\n 在操作redis时，需要先确认操作何种数据，根据数据种类得到操作接口。例如使用opsForValue()获取string类型的数据操作接口，使用opsForHash()获取hash类型的数据操作接口，剩下的就是调用对应api操作了。各种类型的数据操作接口如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/a8e32763458e8e1ba7f82b4985361e77.png)\n\n**总结**\n\n1. springboot整合redis步骤 \n <ol>\n  1. 导入springboot整合redis的starter坐标\n  1. 进行基础配置\n  1. 使用springboot整合redis的专用客户端接口RedisTemplate操作\n </ol>\n\n**StringRedisTemplate**\n\n 由于redis内部不提供java对象的存储格式，因此当操作的数据以对象的形式存在时，会进行转码，转换成字符串格式后进行操作。为了方便开发者使用基于字符串为数据的操作，springboot整合redis时提供了专用的API接口StringRedisTemplate，你可以理解为这是RedisTemplate的一种指定数据泛型的操作API。\n\n```java\n@SpringBootTest\npublic class StringRedisTemplateTest {\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n    @Test\n    void get(){\n        ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();\n        String name = ops.get(\"name\");\n        System.out.println(name);\n    }\n}\n```\n\n**redis客户端选择**\n\n```java\nspringboot整合redis技术提供了多种客户端兼容模式，默认提供的是lettucs客户端技术，也可以根据需要切换成指定客户端技术，例如jedis客户端技术，切换成jedis客户端技术操作步骤如下：\n```\n\n**步骤①**：导入jedis坐标\n\n```java\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n</dependency>\n```\n\n jedis坐标受springboot管理，无需提供版本号\n\n**步骤②**：配置客户端技术类型，设置为jedis\n\n```java\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    client-type: jedis\n```\n\n**步骤③**：根据需要设置对应的配置\n\n```java\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    client-type: jedis\n    lettuce:\n      pool:\n        max-active: 16\n    jedis:\n      pool:\n        max-active: 16\n```\n\n**lettcus与jedis区别**\n\n- jedis连接Redis服务器是直连模式，当多线程模式下使用jedis会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响\n- lettcus基于Netty框架进行与Redis服务器连接，底层设计中采用StatefulRedisConnection。 StatefulRedisConnection自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然lettcus也支持多连接实例一起工作\n\n**总结**\n\n1. springboot整合redis提供了StringRedisTemplate对象，以字符串的数据格式操作redis\n2. 如果需要切换redis客户端实现技术，可以通过配置的形式进行\n\n##### SpringBoot整合MongoDB\n\n 使用Redis技术可以有效的提高数据访问速度，但是由于Redis的数据格式单一性，无法操作结构化数据，当操作对象型的数据时，Redis就显得捉襟见肘。在保障访问速度的情况下，如果想操作结构化数据，看来Redis无法满足要求了，此时需要使用全新的数据存储结束来解决此问题，本节讲解springboot如何整合MongoDB技术。\n\n MongoDB是一个开源、高性能、无模式的文档型数据库，它是NoSQL数据库产品中的一种，是最像关系型数据库的非关系型数据库。\n\n 上述描述中几个词，其中对于我们最陌生的词是无模式的。什么叫无模式呢？简单说就是作为一款数据库，没有固定的数据存储结构，第一条数据可能有A、B、C一共3个字段，第二条数据可能有D、E、F也是3个字段，第三条数据可能是A、C、E3个字段，也就是说数据的结构不固定，这就是无模式。有人会说这有什么用啊？灵活，随时变更，不受约束。基于上述特点，MongoDB的应用面也会产生一些变化。以下列出了一些可以使用MongoDB作为数据存储的场景，但是并不是必须使用MongoDB的场景：\n\n- 淘宝用户数据 \n <ul>\n  - 存储位置：数据库\n  - 特征：永久性存储，修改频度极低\n </ul>\n- 游戏装备数据、游戏道具数据 \n <ul>\n  - 存储位置：数据库、Mongodb\n  - 特征：永久性存储与临时存储相结合、修改频度较高\n </ul>\n- 直播数据、打赏数据、粉丝数据 \n <ul>\n  - 存储位置：数据库、Mongodb\n  - 特征：永久性存储与临时存储相结合，修改频度极高\n </ul>\n- 物联网数据 \n <ul>\n  - 存储位置：Mongodb\n  - 特征：临时存储，修改频度飞速\n </ul>\n\n 快速了解一下MongoDB，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合\n\n\n windows版安装包下载地址：https://www.mongodb.com/try/download\n\n 下载的安装包也有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，本课程采用解压缩zip文件进行安装。\n\n 解压缩完毕后会得到如下文件，其中bin目录包含了所有mongodb的可执行命令\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/7c777c5c6b2ae5cfe5cb1a7ad84d20a2.png)\n\n mongodb在运行时需要指定一个数据存储的目录，所以创建一个数据存储目录，通常放置在安装目录中，此处创建data的目录用来存储数据，具体如下\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/170dd666bb904447977faeaed4d15e9e.png)\n\n 如果在安装的过程中出现了如下警告信息，就是告诉你，你当前的操作系统缺少了一些系统文件，这个不用担心。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/aa4a49d81705301551746d299bf95d91.png)\n\n 根据下列方案即可解决，在浏览器中搜索提示缺少的名称对应的文件，并下载，将下载的文件拷贝到windows安装目录的system32目录下，然后在命令行中执行regsvr32命令注册此文件。根据下载的文件名不同，执行命令前更改对应名称。\n\n```java\nregsvr32 vcruntime140_1.dll\n```\n\n**启动服务器**\n\n```java\nmongod --dbpath=..\\data\\db\n```\n\n 启动服务器时需要指定数据存储位置，通过参数–dbpath进行设置，可以根据需要自行设置数据存储路径。默认服务端口27017。\n\n**启动客户端**\n\n```java\nmongo --host=127.0.0.1 --port=27017\n```\n\n\n MongoDB虽然是一款数据库，但是它的操作并不是使用SQL语句进行的，因此操作方式各位小伙伴可能比较陌生，好在有一些类似于Navicat的数据库客户端软件，能够便捷的操作MongoDB，先安装一个客户端，再来操作MongoDB。\n\n 同类型的软件较多，本次安装的软件时Robo3t，Robot3t是一款绿色软件，无需安装，解压缩即可。解压缩完毕后进入安装目录双击robot3t.exe即可使用。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/6dc585c26514a9b5881b87cc2fbb6c4b.png)\n\n 打开软件首先要连接MongoDB服务器，选择【File】菜单，选择【Connect…】\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/cefb326743cec265615dd5fc10a780e5.png)\n\n 进入连接管理界面后，选择左上角的【Create】链接，创建新的连接设置\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/37322ea0a08c26b37e79925352b76344.png)\n\n 如果输入设置值即可连接（默认不修改即可连接本机27017端口）\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/126e92d08ffe01c625d9010d3294e702.png)\n\n 连接成功后在命令输入区域输入命令即可操作MongoDB。\n\n 创建数据库：在左侧菜单中使用右键创建，输入数据库名称即可\n\n 创建集合：在Collections上使用右键创建，输入集合名称即可，集合等同于数据库中的表的作用\n\n 新增文档：（文档是一种类似json格式的数据，初学者可以先把数据理解为就是json数据）\n\n```java\ndb.集合名称.insert/save/insertOne(文档)\n```\n\n 删除文档：\n\n```java\ndb.集合名称.remove(条件)\n```\n\n 修改文档：\n\n```java\ndb.集合名称.update(条件，{操作种类:{文档}})\n```\n\n 查询文档：\n\n```java\n基础查询\n查询全部：\t\t   db.集合.find();\n查第一条：\t\t   db.集合.findOne()\n查询指定数量文档：\tdb.集合.find().limit(10)\t\t\t\t\t//查10条文档\n跳过指定数量文档：\tdb.集合.find().skip(20)\t\t\t\t\t//跳过20条文档\n统计：\t\t\t  \tdb.集合.count()\n排序：\t\t\t\tdb.集合.sort({age:1})\t\t\t\t\t\t//按age升序排序\n投影：\t\t\t\tdb.集合名称.find(条件,{name:1,age:1})\t\t //仅保留name与age域\n\n条件查询\n基本格式：\t\t\tdb.集合.find({条件})\n模糊查询：\t\t\tdb.集合.find({域名:/正则表达式/})\t\t  //等同SQL中的like，比like强大，可以执行正则所有规则\n条件比较运算：\t\t   db.集合.find({域名:{$gt:值}})\t\t\t\t//等同SQL中的数值比较操作，例如：name>18\n包含查询：\t\t\tdb.集合.find({域名:{$in:[值1，值2]}})\t\t//等同于SQL中的in\n条件连接查询：\t\t   db.集合.find({$and:[{条件1},{条件2}]})\t   //等同于SQL中的and、or\n```\n\n 有关MongoDB的基础操作就普及到这里，需要全面掌握MongoDB技术，请参看相关教程学习。\n\n\n 使用springboot整合MongDB该如何进行呢？其实springboot为什么使用的开发者这么多，就是因为他的套路几乎完全一样。导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB同样如此。\n\n 第一，先导入对应技术的整合starter坐标\n\n 第二，配置必要信息\n\n 第三，使用提供的API操作即可\n\n 下面就开始springboot整合MongoDB，操作步骤如下：\n\n**步骤①**：导入springboot整合MongoDB的starter坐标\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-mongodb</artifactId>\n</dependency>\n```\n\n 上述坐标也可以在创建模块的时候通过勾选的形式进行选择，同样归属NoSQL分类中\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/0756835825ef36c24663e0eb9c16f7ab.png)\n\n**步骤②**：进行基础配置\n\n```java\nspring:\n  data:\n    mongodb:\n      uri: mongodb://localhost/itheima\n```\n\n 操作MongoDB需要的配置与操作redis一样，最基本的信息都是操作哪一台服务器，区别就是连接的服务器IP地址和端口不同，书写格式不同而已。\n\n**步骤③**：使用springboot整合MongoDB的专用客户端接口MongoTemplate来进行操作\n\n```java\n@SpringBootTest\nclass Springboot17MongodbApplicationTests {\n    @Autowired\n    private MongoTemplate mongoTemplate;\n    @Test\n    void contextLoads() {\n        Book book = new Book();\n        book.setId(2);\n        book.setName(\"springboot2\");\n        book.setType(\"springboot2\");\n        book.setDescription(\"springboot2\");\n        mongoTemplate.save(book);\n    }\n    @Test\n    void find(){\n        List<Book> all = mongoTemplate.findAll(Book.class);\n        System.out.println(all);\n    }\n}\n```\n\n 整合工作到这里就做完了，感觉既熟悉也陌生。熟悉的是这个套路，三板斧，就这三招，导坐标做配置用API操作，陌生的是这个技术，里面具体的操作API可能会不熟悉，有关springboot整合MongoDB我们就讲到这里。有兴趣可以继续学习MongoDB的操作，然后再来这里通过编程的形式操作MongoDB。\n\n**总结**\n\n1. springboot整合MongoDB步骤 \n <ol>\n  1. 导入springboot整合MongoDB的starter坐标\n  1. 进行基础配置\n  1. 使用springboot整合MongoDB的专用客户端接口MongoTemplate操作\n </ol>\n\n##### SpringBoot整合ES\n\n NoSQL解决方案已经讲完了两种技术的整合了，Redis可以使用内存加载数据并实现数据快速访问，MongoDB可以在内存中存储类似对象的数据并实现数据的快速访问，在企业级开发中对于速度的追求是永无止境的。下面要讲的内容也是一款NoSQL解决方案，只不过他的作用不是为了直接加速数据的读写，而是加速数据的查询的，叫做ES技术。\n\n ES（Elasticsearch）是一个分布式全文搜索引擎，重点是全文搜索。\n\n 那什么是全文搜索呢？比如用户要买一本书，以Java为关键字进行搜索，不管是书名中还是书的介绍中，甚至是书的作者名字，只要包含java就作为查询结果返回给用户查看，上述过程就使用了全文搜索技术。搜索的条件不再是仅用于对某一个字段进行比对，而是在一条数据中使用搜索条件去比对更多的字段，只要能匹配上就列入查询结果，这就是全文搜索的目的。而ES技术就是一种可以实现上述效果的技术。\n\n 要实现全文搜索的效果，不可能使用数据库中like操作去进行比对，这种效率太低了。ES设计了一种全新的思想，来实现全文搜索。具体操作过程如下：\n\n1. \n 将被查询的字段的数据全部文本信息进行查分，分成若干个词\n <ul>\n  1. 例如“中华人民共和国”就会被拆分成三个词，分别是“中华”、“人民”、“共和国”，此过程有专业术语叫做分词。分词的策略不同，分出的效果不一样，不同的分词策略称为分词器。\n </ul>\n3. \n 将分词得到的结果存储起来，对应每条数据的id\n <ul>\n  3. \n   例如id为1的数据中名称这一项的值是“中华人民共和国”，那么分词结束后，就会出现“中华”对应id为1，“人民”对应id为1，“共和国”对应id为1\n  3. \n   例如id为2的数据中名称这一项的值是“人民代表大会“，那么分词结束后，就会出现“人民”对应id为2，“代表”对应id为2，“大会”对应id为2\n  3. \n   此时就会出现如下对应结果，按照上述形式可以对所有文档进行分词。需要注意分词的过程不是仅对一个字段进行，而是对每一个参与查询的字段都执行，最终结果汇总到一个表格中\n   <table>\n    <thead>\n     <tr>\n      <th>分词结果关键字</th>\n      <th>对应id</th>\n     </tr>\n    </thead>\n    <tbody>\n     <tr>\n      <td>中华</td>\n      <td>1</td>\n     </tr>\n     <tr>\n      <td>人民</td>\n      <td>1,2</td>\n     </tr>\n     <tr>\n      <td>共和国</td>\n      <td>1</td>\n     </tr>\n     <tr>\n      <td>代表</td>\n      <td>2</td>\n     </tr>\n     <tr>\n      <td>大会</td>\n      <td>2</td>\n     </tr>\n    </tbody>\n   </table>\n </ul>\n7. \n 当进行查询时，如果输入“人民”作为查询条件，可以通过上述表格数据进行比对，得到id值1,2，然后根据id值就可以得到查询的结果数据了。\n\n 上述过程中分词结果关键字内容每一个都不相同，作用有点类似于数据库中的索引，是用来加速数据查询的。但是数据库中的索引是对某一个字段进行添加索引，而这里的分词结果关键字不是一个完整的字段值，只是一个字段中的其中的一部分内容。并且索引使用时是根据索引内容查找整条数据，全文搜索中的分词结果关键字查询后得到的并不是整条的数据，而是数据的id，要想获得具体数据还要再次查询，因此这里为这种分词结果关键字起了一个全新的名称，叫做**倒排索引**。\n\n 通过上述内容的学习，发现使用ES其实准备工作还是挺多的，必须先建立文档的倒排索引，然后才能继续使用。快速了解一下ES的工作原理，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合。\n\n\n windows版安装包下载地址： [https://](https://www.elastic.co/cn/downloads/elasticsearch) [www.elastic.co/cn/downloads/elasticsearch](https://www.elastic.co/cn/downloads/elasticsearch)\n\n 下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/d5db32785f97015bb1603752d4cd89ae.png)\n\n- bin目录：包含所有的可执行命令\n- config目录：包含ES服务器使用的配置文件\n- jdk目录：此目录中包含了一个完整的jdk工具包，版本17，当ES升级时，使用最新版本的jdk确保不会出现版本支持性不足的问题\n- lib目录：包含ES运行的依赖jar文件\n- logs目录：包含ES运行后产生的所有日志文件\n- modules目录：包含ES软件中所有的功能模块，也是一个一个的jar包。和jar目录不同，jar目录是ES运行期间依赖的jar包，modules是ES软件自己的功能jar包\n- plugins目录：包含ES软件安装的插件，默认为空\n\n**启动服务器**\n\n```java\nelasticsearch.bat\n```\n\n 双击elasticsearch.bat文件即可启动ES服务器，默认服务端口9200。通过浏览器访问http://localhost:9200看到如下信息视为ES服务器正常启动\n\n```java\n{\n  \"name\" : \"CZBK-**********\",\n  \"cluster_name\" : \"elasticsearch\",\n  \"cluster_uuid\" : \"j137DSswTPG8U4Yb-0T1Mg\",\n  \"version\" : {\n    \"number\" : \"7.16.2\",\n    \"build_flavor\" : \"default\",\n    \"build_type\" : \"zip\",\n    \"build_hash\" : \"2b937c44140b6559905130a8650c64dbd0879cfb\",\n    \"build_date\" : \"2021-12-18T19:42:46.604893745Z\",\n    \"build_snapshot\" : false,\n    \"lucene_version\" : \"8.10.1\",\n    \"minimum_wire_compatibility_version\" : \"6.8.0\",\n    \"minimum_index_compatibility_version\" : \"6.0.0-beta1\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n```\n\n\n ES中保存有我们要查询的数据，只不过格式和数据库存储数据格式不同而已。在ES中我们要先创建倒排索引，这个索引的功能又点类似于数据库的表，然后将数据添加到倒排索引中，添加的数据称为文档。所以要进行ES的操作要先创建索引，再添加文档，这样才能进行后续的查询操作。\n\n 要操作ES可以通过Rest风格的请求来进行，也就是说发送一个请求就可以执行一个操作。比如新建索引，删除索引这些操作都可以使用发送请求的形式来进行。\n\n- \n 创建索引，books是索引名称，下同\n PUT请求\t\thttp://localhost:9200/books\n 发送请求后，看到如下信息即索引创建成功\n {\n    \"acknowledged\": true,\n    \"shards_acknowledged\": true,\n    \"index\": \"books\"\n}\n 重复创建已经存在的索引会出现错误信息，reason属性中描述错误原因\n {\n    \"error\": {\n        \"root_cause\": [\n            {\n                \"type\": \"resource_already_exists_exception\",\n                \"reason\": \"index [books/VgC_XMVAQmedaiBNSgO2-w] already exists\",\n                \"index_uuid\": \"VgC_XMVAQmedaiBNSgO2-w\",\n                \"index\": \"books\"\n            }\n        ],\n        \"type\": \"resource_already_exists_exception\",\n        \"reason\": \"index [books/VgC_XMVAQmedaiBNSgO2-w] already exists\",\t# books索引已经存在\n        \"index_uuid\": \"VgC_XMVAQmedaiBNSgO2-w\",\n        \"index\": \"book\"\n    },\n    \"status\": 400\n}\n- \n 查询索引\n GET请求\t\thttp://localhost:9200/books\n 查询索引得到索引相关信息，如下\n {\n    \"book\": {\n        \"aliases\": {},\n        \"mappings\": {},\n        \"settings\": {\n            \"index\": {\n                \"routing\": {\n                    \"allocation\": {\n                        \"include\": {\n                            \"_tier_preference\": \"data_content\"\n                        }\n                    }\n                },\n                \"number_of_shards\": \"1\",\n                \"provided_name\": \"books\",\n                \"creation_date\": \"1645768584849\",\n                \"number_of_replicas\": \"1\",\n                \"uuid\": \"VgC_XMVAQmedaiBNSgO2-w\",\n                \"version\": {\n                    \"created\": \"7160299\"\n                }\n            }\n        }\n    }\n}\n 如果查询了不存在的索引，会返回错误信息，例如查询名称为book的索引后信息如下\n {\n    \"error\": {\n        \"root_cause\": [\n            {\n                \"type\": \"index_not_found_exception\",\n                \"reason\": \"no such index [book]\",\n                \"resource.type\": \"index_or_alias\",\n                \"resource.id\": \"book\",\n                \"index_uuid\": \"_na_\",\n                \"index\": \"book\"\n            }\n        ],\n        \"type\": \"index_not_found_exception\",\n        \"reason\": \"no such index [book]\",\t\t# 没有book索引\n        \"resource.type\": \"index_or_alias\",\n        \"resource.id\": \"book\",\n        \"index_uuid\": \"_na_\",\n        \"index\": \"book\"\n    },\n    \"status\": 404\n}\n- \n 删除索引\n DELETE请求\thttp://localhost:9200/books\n 删除所有后，给出删除结果\n {\n    \"acknowledged\": true\n}\n 如果重复删除，会给出错误信息，同样在reason属性中描述具体的错误原因\n {\n    \"error\": {\n        \"root_cause\": [\n            {\n                \"type\": \"index_not_found_exception\",\n                \"reason\": \"no such index [books]\",\n                \"resource.type\": \"index_or_alias\",\n                \"resource.id\": \"book\",\n                \"index_uuid\": \"_na_\",\n                \"index\": \"book\"\n            }\n        ],\n        \"type\": \"index_not_found_exception\",\n        \"reason\": \"no such index [books]\",\t\t# 没有books索引\n        \"resource.type\": \"index_or_alias\",\n        \"resource.id\": \"book\",\n        \"index_uuid\": \"_na_\",\n        \"index\": \"book\"\n    },\n    \"status\": 404\n}\n- \n 创建索引并指定分词器\n 前面创建的索引是未指定分词器的，可以在创建索引时添加请求参数，设置分词器。目前国内较为流行的分词器是IK分词器，使用前先在下对应的分词器，然后使用。IK分词器下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases\n 分词器下载后解压到ES安装目录的plugins目录中即可，安装分词器后需要重新启动ES服务器。使用IK分词器创建索引格式：\n PUT请求\t\thttp://localhost:9200/books\n\n请求参数如下（注意是json格式的参数）\n{\n    \"mappings\":{\t\t\t\t\t\t\t#定义mappings属性，替换创建索引时对应的mappings属性\t\t\n        \"properties\":{\t\t\t\t\t\t#定义索引中包含的属性设置\n            \"id\":{\t\t\t\t\t\t\t#设置索引中包含id属性\n                \"type\":\"keyword\"\t\t\t#当前属性可以被直接搜索\n            },\n            \"name\":{\t\t\t\t\t\t#设置索引中包含name属性\n                \"type\":\"text\",              #当前属性是文本信息，参与分词  \n                \"analyzer\":\"ik_max_word\",   #使用IK分词器进行分词             \n                \"copy_to\":\"all\"\t\t\t\t#分词结果拷贝到all属性中\n            },\n            \"type\":{\n                \"type\":\"keyword\"\n            },\n            \"description\":{\n                \"type\":\"text\",\t                \n                \"analyzer\":\"ik_max_word\",                \n                \"copy_to\":\"all\"\n            },\n            \"all\":{\t\t\t\t\t\t\t#定义属性，用来描述多个字段的分词结果集合，当前属性可以参与查询\n                \"type\":\"text\",\t                \n                \"analyzer\":\"ik_max_word\"\n            }\n        }\n    }\n}\n 创建完毕后返回结果和不使用分词器创建索引的结果是一样的，此时可以通过查看索引信息观察到添加的请求参数mappings已经进入到了索引属性中\n {\n    \"books\": {\n        \"aliases\": {},\n        \"mappings\": {\t\t\t\t\t\t#mappings属性已经被替换\n            \"properties\": {\n                \"all\": {\n                    \"type\": \"text\",\n                    \"analyzer\": \"ik_max_word\"\n                },\n                \"description\": {\n                    \"type\": \"text\",\n                    \"copy_to\": [\n                        \"all\"\n                    ],\n                    \"analyzer\": \"ik_max_word\"\n                },\n                \"id\": {\n                    \"type\": \"keyword\"\n                },\n                \"name\": {\n                    \"type\": \"text\",\n                    \"copy_to\": [\n                        \"all\"\n                    ],\n                    \"analyzer\": \"ik_max_word\"\n                },\n                \"type\": {\n                    \"type\": \"keyword\"\n                }\n            }\n        },\n        \"settings\": {\n            \"index\": {\n                \"routing\": {\n                    \"allocation\": {\n                        \"include\": {\n                            \"_tier_preference\": \"data_content\"\n                        }\n                    }\n                },\n                \"number_of_shards\": \"1\",\n                \"provided_name\": \"books\",\n                \"creation_date\": \"1645769809521\",\n                \"number_of_replicas\": \"1\",\n                \"uuid\": \"DohYKvr_SZO4KRGmbZYmTQ\",\n                \"version\": {\n                    \"created\": \"7160299\"\n                }\n            }\n        }\n    }\n}\n\n目前我们已经有了索引了，但是索引中还没有数据，所以要先添加数据，ES中称数据为文档，下面进行文档操作。\n\n- \n 添加文档，有三种方式\n POST请求\thttp://localhost:9200/books/_doc\t\t#使用系统生成id\nPOST请求\thttp://localhost:9200/books/_create/1\t#使用指定id\nPOST请求\thttp://localhost:9200/books/_doc/1\t\t#使用指定id，不存在创建，存在更新（版本递增）\n\n文档通过请求参数传递，数据格式json\n{\n    \"name\":\"springboot\",\n    \"type\":\"springboot\",\n    \"description\":\"springboot\"\n}\n- \n 查询文档\n GET请求\thttp://localhost:9200/books/_doc/1\t\t #查询单个文档 \t\t\nGET请求\thttp://localhost:9200/books/_search\t\t #查询全部文档\n- \n 条件查询\n GET请求\thttp://localhost:9200/books/_search?q=name:springboot\t# q=查询属性名:查询属性值\n- \n 删除文档\n DELETE请求\thttp://localhost:9200/books/_doc/1\n- \n 修改文档（全量更新）\n PUT请求\thttp://localhost:9200/books/_doc/1\n\n文档通过请求参数传递，数据格式json\n{\n    \"name\":\"springboot\",\n    \"type\":\"springboot\",\n    \"description\":\"springboot\"\n}\n- \n 修改文档（部分更新）\n POST请求\thttp://localhost:9200/books/_update/1\n\n文档通过请求参数传递，数据格式json\n{\t\t\t\n    \"doc\":{\t\t\t\t\t\t#部分更新并不是对原始文档进行更新，而是对原始文档对象中的doc属性中的指定属性更新\n        \"name\":\"springboot\"\t\t#仅更新提供的属性值，未提供的属性值不参与更新操作\n    }\n}\n\n\n 使用springboot整合ES该如何进行呢？老规矩，导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB如此，整合ES依然如此。太没有新意了，其实不是没有新意，这就是springboot的强大之处，所有东西都做成相同规则，对开发者来说非常友好。\n\n 下面就开始springboot整合ES，操作步骤如下：\n\n**步骤①**：导入springboot整合ES的starter坐标\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-elasticsearch</artifactId>\n</dependency>\n```\n\n**步骤②**：进行基础配置\n\n```java\nspring:\n  elasticsearch:\n    rest:\n      uris: http://localhost:9200\n```\n\n 配置ES服务器地址，端口9200\n\n**步骤③**：使用springboot整合ES的专用客户端接口ElasticsearchRestTemplate来进行操作\n\n```java\n@SpringBootTest\nclass Springboot18EsApplicationTests {\n    @Autowired\n    private ElasticsearchRestTemplate template;\n}\n```\n\n 上述操作形式是ES早期的操作方式，使用的客户端被称为Low Level Client，这种客户端操作方式性能方面略显不足，于是ES开发了全新的客户端操作方式，称为High Level Client。高级别客户端与ES版本同步更新，但是springboot最初整合ES的时候使用的是低级别客户端，所以企业开发需要更换成高级别的客户端模式。\n\n 下面使用高级别客户端方式进行springboot整合ES，操作步骤如下：\n\n**步骤①**：导入springboot整合ES高级别客户端的坐标，此种形式目前没有对应的starter\n\n```java\n<dependency>\n    <groupId>org.elasticsearch.client</groupId>\n    <artifactId>elasticsearch-rest-high-level-client</artifactId>\n</dependency>\n```\n\n**步骤②**：使用编程的形式设置连接的ES服务器，并获取客户端对象\n\n```java\n@SpringBootTest\nclass Springboot18EsApplicationTests {\n    private RestHighLevelClient client;\n      @Test\n      void testCreateClient() throws IOException {\n          HttpHost host = HttpHost.create(\"http://localhost:9200\");\n          RestClientBuilder builder = RestClient.builder(host);\n          client = new RestHighLevelClient(builder);\n  \n          client.close();\n      }\n}\n```\n\n 配置ES服务器地址与端口9200，记得客户端使用完毕需要手工关闭。由于当前客户端是手工维护的，因此不能通过自动装配的形式加载对象。\n\n**步骤③**：使用客户端对象操作ES，例如创建索引\n\n```java\n@SpringBootTest\nclass Springboot18EsApplicationTests {\n    private RestHighLevelClient client;\n      @Test\n      void testCreateIndex() throws IOException {\n          HttpHost host = HttpHost.create(\"http://localhost:9200\");\n          RestClientBuilder builder = RestClient.builder(host);\n          client = new RestHighLevelClient(builder);\n          \n          CreateIndexRequest request = new CreateIndexRequest(\"books\");\n          client.indices().create(request, RequestOptions.DEFAULT); \n          \n          client.close();\n      }\n}\n```\n\n 高级别客户端操作是通过发送请求的方式完成所有操作的，ES针对各种不同的操作，设定了各式各样的请求对象，上例中创建索引的对象是CreateIndexRequest，其他操作也会有自己专用的Request对象。\n\n 当前操作我们发现，无论进行ES何种操作，第一步永远是获取RestHighLevelClient对象，最后一步永远是关闭该对象的连接。在测试中可以使用测试类的特性去帮助开发者一次性的完成上述操作，但是在业务书写时，还需要自行管理。将上述代码格式转换成使用测试类的初始化方法和销毁方法进行客户端对象的维护。\n\n```java\n@SpringBootTest\nclass Springboot18EsApplicationTests {\n    @BeforeEach\t\t//在测试类中每个操作运行前运行的方法\n    void setUp() {\n        HttpHost host = HttpHost.create(\"http://localhost:9200\");\n        RestClientBuilder builder = RestClient.builder(host);\n        client = new RestHighLevelClient(builder);\n    }\n\n    @AfterEach\t\t//在测试类中每个操作运行后运行的方法\n    void tearDown() throws IOException {\n        client.close();\n    }\n\n    private RestHighLevelClient client;\n\n    @Test\n    void testCreateIndex() throws IOException {\n        CreateIndexRequest request = new CreateIndexRequest(\"books\");\n        client.indices().create(request, RequestOptions.DEFAULT);\n    }\n}\n```\n\n 现在的书写简化了很多，也更合理。下面使用上述模式将所有的ES操作执行一遍，测试结果\n\n**创建索引（IK分词器）**：\n\n```java\n@Test\nvoid testCreateIndexByIK() throws IOException {\n    CreateIndexRequest request = new CreateIndexRequest(\"books\");\n    String json = \"{\\n\" +\n            \"    \\\"mappings\\\":{\\n\" +\n            \"        \\\"properties\\\":{\\n\" +\n            \"            \\\"id\\\":{\\n\" +\n            \"                \\\"type\\\":\\\"keyword\\\"\\n\" +\n            \"            },\\n\" +\n            \"            \\\"name\\\":{\\n\" +\n            \"                \\\"type\\\":\\\"text\\\",\\n\" +\n            \"                \\\"analyzer\\\":\\\"ik_max_word\\\",\\n\" +\n            \"                \\\"copy_to\\\":\\\"all\\\"\\n\" +\n            \"            },\\n\" +\n            \"            \\\"type\\\":{\\n\" +\n            \"                \\\"type\\\":\\\"keyword\\\"\\n\" +\n            \"            },\\n\" +\n            \"            \\\"description\\\":{\\n\" +\n            \"                \\\"type\\\":\\\"text\\\",\\n\" +\n            \"                \\\"analyzer\\\":\\\"ik_max_word\\\",\\n\" +\n            \"                \\\"copy_to\\\":\\\"all\\\"\\n\" +\n            \"            },\\n\" +\n            \"            \\\"all\\\":{\\n\" +\n            \"                \\\"type\\\":\\\"text\\\",\\n\" +\n            \"                \\\"analyzer\\\":\\\"ik_max_word\\\"\\n\" +\n            \"            }\\n\" +\n            \"        }\\n\" +\n            \"    }\\n\" +\n            \"}\";\n    //设置请求中的参数\n    request.source(json, XContentType.JSON);\n    client.indices().create(request, RequestOptions.DEFAULT);\n}\n```\n\n IK分词器是通过请求参数的形式进行设置的，设置请求参数使用request对象中的source方法进行设置，至于参数是什么，取决于你的操作种类。当请求中需要参数时，均可使用当前形式进行参数设置。\n\n**添加文档**：\n\n```java\n@Test\n//添加文档\nvoid testCreateDoc() throws IOException {\n    Book book = bookDao.selectById(1);\n    IndexRequest request = new IndexRequest(\"books\").id(book.getId().toString());\n    String json = JSON.toJSONString(book);\n    request.source(json,XContentType.JSON);\n    client.index(request,RequestOptions.DEFAULT);\n}\n```\n\n 添加文档使用的请求对象是IndexRequest，与创建索引使用的请求对象不同。\n\n**批量添加文档**：\n\n```java\n@Test\n//批量添加文档\nvoid testCreateDocAll() throws IOException {\n    List<Book> bookList = bookDao.selectList(null);\n    BulkRequest bulk = new BulkRequest();\n    for (Book book : bookList) {\n        IndexRequest request = new IndexRequest(\"books\").id(book.getId().toString());\n        String json = JSON.toJSONString(book);\n        request.source(json,XContentType.JSON);\n        bulk.add(request);\n    }\n    client.bulk(bulk,RequestOptions.DEFAULT);\n}\n```\n\n 批量做时，先创建一个BulkRequest的对象，可以将该对象理解为是一个保存request对象的容器，将所有的请求都初始化好后，添加到BulkRequest对象中，再使用BulkRequest对象的bulk方法，一次性执行完毕。\n\n**按id查询文档**：\n\n```java\n@Test\n//按id查询\nvoid testGet() throws IOException {\n    GetRequest request = new GetRequest(\"books\",\"1\");\n    GetResponse response = client.get(request, RequestOptions.DEFAULT);\n    String json = response.getSourceAsString();\n    System.out.println(json);\n}\n```\n\n 根据id查询文档使用的请求对象是GetRequest。\n\n**按条件查询文档**：\n\n```java\n@Test\n//按条件查询\nvoid testSearch() throws IOException {\n    SearchRequest request = new SearchRequest(\"books\");\n\n    SearchSourceBuilder builder = new SearchSourceBuilder();\n    builder.query(QueryBuilders.termQuery(\"all\",\"spring\"));\n    request.source(builder);\n\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    SearchHits hits = response.getHits();\n    for (SearchHit hit : hits) {\n        String source = hit.getSourceAsString();\n        //System.out.println(source);\n        Book book = JSON.parseObject(source, Book.class);\n        System.out.println(book);\n    }\n}\n```\n\n 按条件查询文档使用的请求对象是SearchRequest，查询时调用SearchRequest对象的termQuery方法，需要给出查询属性名，此处支持使用合并字段，也就是前面定义索引属性时添加的all属性。\n\n springboot整合ES的操作到这里就说完了，与前期进行springboot整合redis和mongodb的差别还是蛮大的，主要原始就是我们没有使用springboot整合ES的客户端对象。至于操作，由于ES操作种类过多，所以显得操作略微有点复杂。有关springboot整合ES就先学习到这里吧。\n\n**总结**\n\n1. springboot整合ES步骤 \n <ol>\n  1. 导入springboot整合ES的High Level Client坐标\n  1. 手工管理客户端对象，包括初始化和关闭操作\n  1. 使用High Level Client根据操作的种类不同，选择不同的Request对象完成对应操作\n </ol>\n\n### KF-5.整合第三方技术\n\n 通过第四章的学习，我们领略到了springboot在整合第三方技术时强大的一致性，在第五章中我们要使用springboot继续整合各种各样的第三方技术，通过本章的学习，可以将之前学习的springboot整合第三方技术的思想贯彻到底，还是那三板斧。导坐标、做配置、调API。\n\n springboot能够整合的技术实在是太多了，可以说是万物皆可整。本章将从企业级开发中常用的一些技术作为出发点，对各种各样的技术进行整合。\n\n#### KF-5-1.缓存\n\n 企业级应用主要作用是信息处理，当需要读取数据时，由于受限于数据库的访问效率，导致整体系统性能偏低。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/fea976b3169f839eaaa23d81979df55b.png)\n\n 应用程序直接与数据库打交道，访问效率低\n\n 为了改善上述现象，开发者通常会在应用程序与数据库之间建立一种临时的数据存储机制，该区域中的数据在内存中保存，读写速度较快，可以有效解决数据库访问效率低下的问题。这一块临时存储数据的区域就是缓存。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/07f1242d7a012e04dfdd6e3fadcc1d15.png)\n\n```java\n使用缓存后，应用程序与缓存打交道，缓存与数据库打交道，数据访问效率提高\n```\n\n 缓存是什么？缓存是一种介于数据永久存储介质与应用程序之间的数据临时存储介质，使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘IO），提高系统性能。此外缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间。而springboot提供了对市面上几乎所有的缓存技术进行整合的方案，下面就一起开启springboot整合缓存之旅。\n\n##### SpringBoot内置缓存解决方案\n\n springboot技术提供有内置的缓存解决方案，可以帮助开发者快速开启缓存技术，并使用缓存技术进行数据的快速操作，例如读取缓存数据和写入数据到缓存。\n\n**步骤①**：导入springboot提供的缓存技术对应的starter\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n```\n\n**步骤②**：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存\n\n```java\n@SpringBootApplication\n//开启缓存功能\n@EnableCaching\npublic class Springboot19CacheApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot19CacheApplication.class, args);\n    }\n}\n```\n\n**步骤③**：设置操作的数据是否使用缓存\n\n```java\n@Service\npublic class BookServiceImpl implements BookService {\n    @Autowired\n    private BookDao bookDao;\n\n    @Cacheable(value=\"cacheSpace\",key=\"#id\")\n    public Book getById(Integer id) {\n        return bookDao.selectById(id);\n    }\n}\n```\n\n 在业务方法上面使用注解@Cacheable声明当前方法的返回值放入缓存中，其中要指定缓存的存储位置，以及缓存中保存当前方法返回值对应的名称。上例中value属性描述缓存的存储位置，可以理解为是一个存储空间名，key属性描述了缓存中保存数据的名称，使用#id读取形参中的id值作为缓存名称。\n\n 使用@Cacheable注解后，执行当前操作，如果发现对应名称在缓存中没有数据，就正常读取数据，然后放入缓存；如果对应名称在缓存中有数据，就终止当前业务方法执行，直接返回缓存中的数据。\n\n##### 手机验证码案例\n\n 为了便于下面演示各种各样的缓存技术，我们创建一个手机验证码的案例环境，模拟使用缓存保存手机验证码的过程。\n\n 手机验证码案例需求如下：\n\n- 输入手机号获取验证码，组织文档以短信形式发送给用户（页面模拟）\n- 输入手机号和验证码验证结果\n\n 为了描述上述操作，我们制作两个表现层接口，一个用来模拟发送短信的过程，其实就是根据用户提供的手机号生成一个验证码，然后放入缓存，另一个用来模拟验证码校验的过程，其实就是使用传入的手机号和验证码进行匹配，并返回最终匹配结果。下面直接制作本案例的模拟代码，先以上例中springboot提供的内置缓存技术来完成当前案例的制作。\n\n**步骤①**：导入springboot提供的缓存技术对应的starter\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n```\n\n**步骤②**：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存\n\n```java\n@SpringBootApplication\n//开启缓存功能\n@EnableCaching\npublic class Springboot19CacheApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot19CacheApplication.class, args);\n    }\n}\n```\n\n**步骤③**：定义验证码对应的实体类，封装手机号与验证码两个属性\n\n```java\n@Data\npublic class SMSCode {\n    private String tele;\n    private String code;\n}\n```\n\n**步骤④**：定义验证码功能的业务层接口与实现类\n\n```java\npublic interface SMSCodeService {\n    public String sendCodeToSMS(String tele);\n    public boolean checkCode(SMSCode smsCode);\n}\n\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @Autowired\n    private CodeUtils codeUtils;\n\n    @CachePut(value = \"smsCode\", key = \"#tele\")\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        return code;\n    }\n\n    public boolean checkCode(SMSCode smsCode) {\n        //取出内存中的验证码与传递过来的验证码比对，如果相同，返回true\n        String code = smsCode.getCode();\n        String cacheCode = codeUtils.get(smsCode.getTele());\n        return code.equals(cacheCode);\n    }\n}\n```\n\n 获取验证码后，当验证码失效时必须重新获取验证码，因此在获取验证码的功能上不能使用@Cacheable注解，@Cacheable注解是缓存中没有值则放入值，缓存中有值则取值。此处的功能仅仅是生成验证码并放入缓存，并不具有从缓存中取值的功能，因此不能使用@Cacheable注解，应该使用仅具有向缓存中保存数据的功能，使用@CachePut注解即可。\n\n 对于校验验证码的功能建议放入工具类中进行。\n\n**步骤⑤**：定义验证码的生成策略与根据手机号读取验证码的功能\n\n```java\n@Component\npublic class CodeUtils {\n    private String [] patch = {\"000000\",\"00000\",\"0000\",\"000\",\"00\",\"0\",\"\"};\n\n    public String generator(String tele){\n        int hash = tele.hashCode();\n        int encryption = 20206666;\n        long result = hash ^ encryption;\n        long nowTime = System.currentTimeMillis();\n        result = result ^ nowTime;\n        long code = result % 1000000;\n        code = code < 0 ? -code : code;\n        String codeStr = code + \"\";\n        int len = codeStr.length();\n        return patch[len] + codeStr;\n    }\n\n    @Cacheable(value = \"smsCode\",key=\"#tele\")\n    public String get(String tele){\n        return null;\n    }\n}\n```\n\n**步骤⑥**：定义验证码功能的web层接口，一个方法用于提供手机号获取验证码，一个方法用于提供手机号和验证码进行校验\n\n```java\n@RestController\n@RequestMapping(\"/sms\")\npublic class SMSCodeController {\n    @Autowired\n    private SMSCodeService smsCodeService;\n    \n    @GetMapping\n    public String getCode(String tele){\n        String code = smsCodeService.sendCodeToSMS(tele);\n        return code;\n    }\n    \n    @PostMapping\n    public boolean checkCode(SMSCode smsCode){\n        return smsCodeService.checkCode(smsCode);\n    }\n}\n```\n\n##### SpringBoot整合Ehcache缓存\n\n 手机验证码的案例已经完成了，下面就开始springboot整合各种各样的缓存技术，第一个整合Ehcache技术。Ehcache是一种缓存技术，使用springboot整合Ehcache其实就是变更一下缓存技术的实现方式，话不多说，直接开整\n\n**步骤①**：导入Ehcache的坐标\n\n```java\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n</dependency>\n```\n\n 此处为什么不是导入Ehcache的starter，而是导入技术坐标呢？其实springboot整合缓存技术做的是通用格式，不管你整合哪种缓存技术，只是实现变化了，操作方式一样。这也体现出springboot技术的优点，统一同类技术的整合方式。\n\n**步骤②**：配置缓存技术实现使用Ehcache\n\n```java\nspring:\n  cache:\n    type: ehcache\n    ehcache:\n      config: ehcache.xml\n```\n\n 配置缓存的类型type为ehcache，此处需要说明一下，当前springboot可以整合的缓存技术中包含有ehcach，所以可以这样书写。其实这个type不可以随便写的，不是随便写一个名称就可以整合的。\n\n 由于ehcache的配置有独立的配置文件格式，因此还需要指定ehcache的配置文件，以便于读取相应配置\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         updateCheck=\"false\">\n    <diskStore path=\"D:\\ehcache\" />\n\n    <!--默认缓存策略 -->\n    <!-- external：是否永久存在，设置为true则不会被清除，此时与timeout冲突，通常设置为false-->\n    <!-- diskPersistent：是否启用磁盘持久化-->\n    <!-- maxElementsInMemory：最大缓存数量-->\n    <!-- overflowToDisk：超过最大缓存数量是否持久化到磁盘-->\n    <!-- timeToIdleSeconds：最大不活动间隔，设置过长缓存容易溢出，设置过短无效果，可用于记录时效性数据，例如验证码-->\n    <!-- timeToLiveSeconds：最大存活时间-->\n    <!-- memoryStoreEvictionPolicy：缓存清除策略-->\n    <defaultCache\n        eternal=\"false\"\n        diskPersistent=\"false\"\n        maxElementsInMemory=\"1000\"\n        overflowToDisk=\"false\"\n        timeToIdleSeconds=\"60\"\n        timeToLiveSeconds=\"60\"\n        memoryStoreEvictionPolicy=\"LRU\" />\n\n    <cache\n        name=\"smsCode\"\n        eternal=\"false\"\n        diskPersistent=\"false\"\n        maxElementsInMemory=\"1000\"\n        overflowToDisk=\"false\"\n        timeToIdleSeconds=\"10\"\n        timeToLiveSeconds=\"10\"\n        memoryStoreEvictionPolicy=\"LRU\" />\n</ehcache>\n```\n\n 注意前面的案例中，设置了数据保存的位置是smsCode\n\n```java\n@CachePut(value = \"smsCode\", key = \"#tele\")\npublic String sendCodeToSMS(String tele) {\n    String code = codeUtils.generator(tele);\n    return code;\n}\n```\n\n 这个设定需要保障ehcache中有一个缓存空间名称叫做smsCode的配置，前后要统一。在企业开发过程中，通过设置不同名称的cache来设定不同的缓存策略，应用于不同的缓存数据。\n\n 到这里springboot整合Ehcache就做完了，可以发现一点，原始代码没有任何修改，仅仅是加了一组配置就可以变更缓存供应商了，这也是springboot提供了统一的缓存操作接口的优势，变更实现并不影响原始代码的书写。\n\n**总结**\n\n1. springboot使用Ehcache作为缓存实现需要导入Ehcache的坐标\n2. 修改设置，配置缓存供应商为ehcache，并提供对应的缓存配置文件\n\n\n\n##### SpringBoot整合Redis缓存\n\n 上节使用Ehcache替换了springboot内置的缓存技术，其实springboot支持的缓存技术还很多，下面使用redis技术作为缓存解决方案来实现手机验证码案例。\n\n 比对使用Ehcache的过程，加坐标，改缓存实现类型为ehcache，做Ehcache的配置。如果还成redis做缓存呢？一模一样，加坐标，改缓存实现类型为redis，做redis的配置。差别之处只有一点，redis的配置可以在yml文件中直接进行配置，无需制作独立的配置文件。\n\n**步骤①**：导入redis的坐标\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n**步骤②**：配置缓存技术实现使用redis\n\n```java\nspring:\n  redis:\n    host: localhost\n    port: 6379\n  cache:\n    type: redis\n```\n\n 如果需要对redis作为缓存进行配置，注意不是对原始的redis进行配置，而是配置redis作为缓存使用相关的配置，隶属于spring.cache.redis节点下，注意不要写错位置了。\n\n```java\nspring:\n  redis:\n    host: localhost\n    port: 6379\n  cache:\n    type: redis\n    redis:\n      use-key-prefix: false\n      key-prefix: sms_\n      cache-null-values: false\n      time-to-live: 10s\n```\n\n**总结**\n\n1. springboot使用redis作为缓存实现需要导入redis的坐标\n2. 修改设置，配置缓存供应商为redis，并提供对应的缓存配置\n\n##### SpringBoot整合Memcached缓存\n\n 目前我们已经掌握了3种缓存解决方案的配置形式，分别是springboot内置缓存，ehcache和redis，本节研究一下国内比较流行的一款缓存memcached。\n\n 按照之前的套路，其实变更缓存并不繁琐，但是springboot并没有支持使用memcached作为其缓存解决方案，也就是说在type属性中没有memcached的配置选项，这里就需要更变一下处理方式了。在整合之前先安装memcached。\n\n**安装**\n\n windows版安装包下载地址：https://www.runoob.com/memcached/window-install-memcached.html\n\n 下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/c4d5b3a5def96ca6ff53a03b7581c48a.png)\n\n 可执行文件只有一个memcached.exe，使用该文件可以将memcached作为系统服务启动，执行此文件时会出现报错信息，如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/be7f4dd65b54a80bf9eb7223c8634d39.png)\n\n 此处出现问题的原因是注册系统服务时需要使用管理员权限，当前账号权限不足导致安装服务失败，切换管理员账号权限启动命令行\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/976b33e3e9f081923544bdaa6ca70592.png)\n\n 然后再次执行安装服务的命令即可，如下：\n\n```java\nmemcached.exe -d install\n```\n\n 服务安装完毕后可以使用命令启动和停止服务，如下：\n\n```java\nmemcached.exe -d start\t\t# 启动服务\nmemcached.exe -d stop\t\t# 停止服务\n```\n\n 也可以在任务管理器中进行服务状态的切换\n\n\n&lt;![img](https://img-blog.csdnimg.cn/img_convert/afe811607969d912bade72a1b64d2422.png)\n\n**变更缓存为Memcached**\n\n 由于memcached未被springboot收录为缓存解决方案，因此使用memcached需要通过手工硬编码的方式来使用，于是前面的套路都不适用了，需要自己写了。\n\n memcached目前提供有三种客户端技术，分别是Memcached Client for Java、SpyMemcached和Xmemcached，其中性能指标各方面最好的客户端是Xmemcached，本次整合就使用这个作为客户端实现技术了。下面开始使用Xmemcached\n\n**步骤①**：导入xmemcached的坐标\n\n```java\n<dependency>\n    <groupId>com.googlecode.xmemcached</groupId>\n    <artifactId>xmemcached</artifactId>\n    <version>2.4.7</version>\n</dependency>\n```\n\n**步骤②**：配置memcached，制作memcached的配置类\n\n```java\n@Configuration\npublic class XMemcachedConfig {\n    @Bean\n    public MemcachedClient getMemcachedClient() throws IOException {\n        MemcachedClientBuilder memcachedClientBuilder = new XMemcachedClientBuilder(\"localhost:11211\");\n        MemcachedClient memcachedClient = memcachedClientBuilder.build();\n        return memcachedClient;\n    }\n}\n```\n\n memcached默认对外服务端口11211。\n\n**步骤③**：使用xmemcached客户端操作缓存，注入MemcachedClient对象\n\n```java\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @Autowired\n    private CodeUtils codeUtils;\n    @Autowired\n    private MemcachedClient memcachedClient;\n\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        try {\n            memcachedClient.set(tele,10,code);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return code;\n    }\n\n    public boolean checkCode(SMSCode smsCode) {\n        String code = null;\n        try {\n            code = memcachedClient.get(smsCode.getTele()).toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return smsCode.getCode().equals(code);\n    }\n}\n```\n\n 设置值到缓存中使用set操作，取值使用get操作，其实更符合我们开发者的习惯。\n\n 上述代码中对于服务器的配置使用硬编码写死到了代码中，将此数据提取出来，做成独立的配置属性。\n\n**定义配置属性**\n\n 以下过程采用前期学习的属性配置方式进行，当前操作有助于理解原理篇中的很多知识。\n\n- \n 定义配置类，加载必要的配置属性，读取配置文件中memcached节点信息\n @Component\n@ConfigurationProperties(prefix = \"memcached\")\n@Data\npublic class XMemcachedProperties {\n    private String servers;\n    private int poolSize;\n    private long opTimeout;\n}\n- \n 定义memcached节点信息\n memcached:\n  servers: localhost:11211\n  poolSize: 10\n  opTimeout: 3000\n- \n 在memcached配置类中加载信息\n\n```java\n@Configuration\npublic class XMemcachedConfig {\n    @Autowired\n    private XMemcachedProperties props;\n    @Bean\n    public MemcachedClient getMemcachedClient() throws IOException {\n        MemcachedClientBuilder memcachedClientBuilder = new XMemcachedClientBuilder(props.getServers());\n        memcachedClientBuilder.setConnectionPoolSize(props.getPoolSize());\n        memcachedClientBuilder.setOpTimeout(props.getOpTimeout());\n        MemcachedClient memcachedClient = memcachedClientBuilder.build();\n        return memcachedClient;\n    }\n}\n```\n\n**总结**\n\n1. memcached安装后需要启动对应服务才可以对外提供缓存功能，安装memcached服务需要基于windows系统管理员权限\n2. 由于springboot没有提供对memcached的缓存整合方案，需要采用手工编码的形式创建xmemcached客户端操作缓存\n3. 导入xmemcached坐标后，创建memcached配置类，注册MemcachedClient对应的bean，用于操作缓存\n4. 初始化MemcachedClient对象所需要使用的属性可以通过自定义配置属性类的形式加载\n\n**思考**\n\n 到这里已经完成了三种缓存的整合，其中redis和mongodb需要安装独立的服务器，连接时需要输入对应的服务器地址，这种是远程缓存，Ehcache是一个典型的内存级缓存，因为它什么也不用安装，启动后导入jar包就有缓存功能了。这个时候就要问了，能不能这两种缓存一起用呢？咱们下节再说。\n\n##### SpringBoot整合jetcache缓存\n\n 目前我们使用的缓存都是要么A要么B，能不能AB一起用呢？这一节就解决这个问题。springboot针对缓存的整合仅仅停留在用缓存上面，如果缓存自身不支持同时支持AB一起用，springboot也没办法，所以要想解决AB缓存一起用的问题，就必须找一款缓存能够支持AB两种缓存一起用，有这种缓存吗？还真有，阿里出品，jetcache。\n\n jetcache严格意义上来说，并不是一个缓存解决方案，只能说他算是一个缓存框架，然后把别的缓存放到jetcache中管理，这样就可以支持AB缓存一起用了。并且jetcache参考了springboot整合缓存的思想，整体技术使用方式和springboot的缓存解决方案思想非常类似。下面咱们就先把jetcache用起来，然后再说它里面的一些小的功能。\n\n 做之前要先明确一下，jetcache并不是随便拿两个缓存都能拼到一起去的。目前jetcache支持的缓存方案本地缓存支持两种，远程缓存支持两种，分别如下：\n\n- 本地缓存（Local） \n <ul>\n  - LinkedHashMap\n  - Caffeine\n </ul>\n- 远程缓存（Remote） \n <ul>\n  - Redis\n  - Tair\n </ul>\n\n 其实也有人问我，为什么jetcache只支持2+2这么4款缓存呢？阿里研发这个技术其实主要是为了满足自身的使用需要。最初肯定只有1+1种，逐步变化成2+2种。下面就以LinkedHashMap+Redis的方案实现本地与远程缓存方案同时使用。\n\n\n**步骤①**：导入springboot整合jetcache对应的坐标starter，当前坐标默认使用的远程方案是redis\n\n```java\n<dependency>\n    <groupId>com.alicp.jetcache</groupId>\n    <artifactId>jetcache-starter-redis</artifactId>\n    <version>2.6.2</version>\n</dependency>\n```\n\n**步骤②**：远程方案基本配置\n\n```java\njetcache:\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n```\n\n 其中poolConfig是必配项，否则会报错\n\n**步骤③**：启用缓存，在引导类上方标注注解@EnableCreateCacheAnnotation配置springboot程序中可以使用注解的形式创建缓存\n\n```java\n@SpringBootApplication\n//jetcache启用缓存的主开关\n@EnableCreateCacheAnnotation\npublic class Springboot20JetCacheApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot20JetCacheApplication.class, args);\n    }\n}\n```\n\n**步骤④**：创建缓存对象Cache，并使用注解@CreateCache标记当前缓存的信息，然后使用Cache对象的API操作缓存，put写缓存，get读缓存。\n\n```java\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @Autowired\n    private CodeUtils codeUtils;\n    \n    @CreateCache(name=\"jetCache_\",expire = 10,timeUnit = TimeUnit.SECONDS)\n    private Cache<String ,String> jetCache;\n\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        jetCache.put(tele,code);\n        return code;\n    }\n\n    public boolean checkCode(SMSCode smsCode) {\n        String code = jetCache.get(smsCode.getTele());\n        return smsCode.getCode().equals(code);\n    }\n}\n```\n\n 通过上述jetcache使用远程方案连接redis可以看出，jetcache操作缓存时的接口操作更符合开发者习惯，使用缓存就先获取缓存对象Cache，放数据进去就是put，取数据出来就是get，更加简单易懂。并且jetcache操作缓存时，可以为某个缓存对象设置过期时间，将同类型的数据放入缓存中，方便有效周期的管理。\n\n 上述方案中使用的是配置中定义的default缓存，其实这个default是个名字，可以随便写，也可以随便加。例如再添加一种缓存解决方案，参照如下配置进行：\n\n```java\njetcache:\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n```\n\n 如果想使用名称是sms的缓存，需要再创建缓存时指定参数area，声明使用对应缓存即可\n\n```java\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @Autowired\n    private CodeUtils codeUtils;\n    \n    @CreateCache(area=\"sms\",name=\"jetCache_\",expire = 10,timeUnit = TimeUnit.SECONDS)\n    private Cache<String ,String> jetCache;\n\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        jetCache.put(tele,code);\n        return code;\n    }\n\n    public boolean checkCode(SMSCode smsCode) {\n        String code = jetCache.get(smsCode.getTele());\n        return smsCode.getCode().equals(code);\n    }\n}\n```\n\n\n 远程方案中，配置中使用remote表示远程，换成local就是本地，只不过类型不一样而已。\n\n**步骤①**：导入springboot整合jetcache对应的坐标starter\n\n```java\n<dependency>\n    <groupId>com.alicp.jetcache</groupId>\n    <artifactId>jetcache-starter-redis</artifactId>\n    <version>2.6.2</version>\n</dependency>\n```\n\n**步骤②**：本地缓存基本配置\n\n```java\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyConvertor: fastjson\n```\n\n 为了加速数据获取时key的匹配速度，jetcache要求指定key的类型转换器。简单说就是，如果你给了一个Object作为key的话，我先用key的类型转换器给转换成字符串，然后再保存。等到获取数据时，仍然是先使用给定的Object转换成字符串，然后根据字符串匹配。由于jetcache是阿里的技术，这里推荐key的类型转换器使用阿里的fastjson。\n\n**步骤③**：启用缓存\n\n```java\n@SpringBootApplication\n//jetcache启用缓存的主开关\n@EnableCreateCacheAnnotation\npublic class Springboot20JetCacheApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot20JetCacheApplication.class, args);\n    }\n}\n```\n\n**步骤④**：创建缓存对象Cache时，标注当前使用本地缓存\n\n```java\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @CreateCache(name=\"jetCache_\",expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.LOCAL)\n    private Cache<String ,String> jetCache;\n\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        jetCache.put(tele,code);\n        return code;\n    }\n\n    public boolean checkCode(SMSCode smsCode) {\n        String code = jetCache.get(smsCode.getTele());\n        return smsCode.getCode().equals(code);\n    }\n}\n```\n\n cacheType控制当前缓存使用本地缓存还是远程缓存，配置cacheType=CacheType.LOCAL即使用本地缓存。\n\n\n 本地和远程方法都有了，两种方案一起使用如何配置呢？其实就是将两种配置合并到一起就可以了。\n\n```java\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyConvertor: fastjson\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n```\n\n 在创建缓存的时候，配置cacheType为BOTH即则本地缓存与远程缓存同时使用。\n\n```java\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @CreateCache(name=\"jetCache_\",expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.BOTH)\n    private Cache<String ,String> jetCache;\n}\n```\n\n cacheType如果不进行配置，默认值是REMOTE，即仅使用远程缓存方案。关于jetcache的配置，参考以下信息\n\n\n 以上方案仅支持手工控制缓存，但是springcache方案中的方法缓存特别好用，给一个方法添加一个注解，方法就会自动使用缓存。jetcache也提供了对应的功能，即方法缓存。\n\n**方法缓存**\n\n jetcache提供了方法缓存方案，只不过名称变更了而已。在对应的操作接口上方使用注解@Cached即可\n\n**步骤①**：导入springboot整合jetcache对应的坐标starter\n\n```java\n<dependency>\n    <groupId>com.alicp.jetcache</groupId>\n    <artifactId>jetcache-starter-redis</artifactId>\n    <version>2.6.2</version>\n</dependency>\n```\n\n**步骤②**：配置缓存\n\n```java\njetcache:\n  local:\n    default:\n      type: linkedhashmap\n      keyConvertor: fastjson\n  remote:\n    default:\n      type: redis\n      host: localhost\n      port: 6379\n      keyConvertor: fastjson\n      valueEncode: java\n      valueDecode: java\n      poolConfig:\n        maxTotal: 50\n    sms:\n      type: redis\n      host: localhost\n      port: 6379\n      poolConfig:\n        maxTotal: 50\n```\n\n 由于redis缓存中不支持保存对象，因此需要对redis设置当Object类型数据进入到redis中时如何进行类型转换。需要配置keyConvertor表示key的类型转换方式，同时标注value的转换类型方式，值进入redis时是java类型，标注valueEncode为java，值从redis中读取时转换成java，标注valueDecode为java。\n\n 注意，为了实现Object类型的值进出redis，需要保障进出redis的Object类型的数据必须实现序列化接口。\n\n```java\n@Data\npublic class Book implements Serializable {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n```\n\n**步骤③**：启用缓存时开启方法缓存功能，并配置basePackages，说明在哪些包中开启方法缓存\n\n```java\n@SpringBootApplication\n//jetcache启用缓存的主开关\n@EnableCreateCacheAnnotation\n//开启方法注解缓存\n@EnableMethodCache(basePackages = \"com.itheima\")\npublic class Springboot20JetCacheApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot20JetCacheApplication.class, args);\n    }\n}\n```\n\n**步骤④**：使用注解@Cached标注当前方法使用缓存\n\n```java\n@Service\npublic class BookServiceImpl implements BookService {\n    @Autowired\n    private BookDao bookDao;\n    \n    @Override\n    @Cached(name=\"book_\",key=\"#id\",expire = 3600,cacheType = CacheType.REMOTE)\n    public Book getById(Integer id) {\n        return bookDao.selectById(id);\n    }\n}\n```\n\n\n 由于远程方案中redis保存的数据可以被多个客户端共享，这就存在了数据同步问题。jetcache提供了3个注解解决此问题，分别在更新、删除操作时同步缓存数据，和读取缓存时定时刷新数据\n\n**更新缓存**\n\n```java\n@CacheUpdate(name=\"book_\",key=\"#book.id\",value=\"#book\")\npublic boolean update(Book book) {\n    return bookDao.updateById(book) > 0;\n}\n```\n\n**删除缓存**\n\n```java\n@CacheInvalidate(name=\"book_\",key = \"#id\")\npublic boolean delete(Integer id) {\n    return bookDao.deleteById(id) > 0;\n}\n```\n\n**定时刷新缓存**\n\n```java\n@Cached(name=\"book_\",key=\"#id\",expire = 3600,cacheType = CacheType.REMOTE)\n@CacheRefresh(refresh = 5)\npublic Book getById(Integer id) {\n    return bookDao.selectById(id);\n}\n```\n\n\n jetcache还提供有简单的数据报表功能，帮助开发者快速查看缓存命中信息，只需要添加一个配置即可\n\n```java\njetcache:\n  statIntervalMinutes: 1\n```\n\n 设置后，每1分钟在控制台输出缓存数据命中信息\n\n```java\n[DefaultExecutor] c.alicp.jetcache.support.StatInfoLogger  : jetcache stat from 2022-02-28 09:32:15,892 to 2022-02-28 09:33:00,003\ncache    |    qps|   rate|   get|    hit|   fail|   expire|   avgLoadTime|   maxLoadTime\n---------+-------+-------+------+-------+-------+---------+--------------+--------------\nbook_    |   0.66| 75.86%|    29|     22|      0|        0|          28.0|           188\n---------+-------+-------+------+-------+-------+---------+--------------+--------------\n```\n\n**总结**\n\n1. jetcache是一个类似于springcache的缓存解决方案，自身不具有缓存功能，它提供有本地缓存与远程缓存多级共同使用的缓存解决方案\n2. jetcache提供的缓存解决方案受限于目前支持的方案，本地缓存支持两种，远程缓存支持两种\n3. 注意数据进入远程缓存时的类型转换问题\n4. jetcache提供方法缓存，并提供了对应的缓存更新与刷新功能\n5. jetcache提供有简单的缓存信息命中报表方便开发者即时监控缓存数据命中情况\n\n**思考**\n\n jetcache解决了前期使用缓存方案单一的问题，但是仍然不能灵活的选择缓存进行搭配使用，是否存在一种技术可以灵活的搭配各种各样的缓存使用呢？有，咱们下一节再讲。\n\n##### SpringBoot整合j2cache缓存\n\n jetcache可以在限定范围内构建多级缓存，但是灵活性不足，不能随意搭配缓存，本节介绍一种可以随意搭配缓存解决方案的缓存整合框架，j2cache。下面就来讲解如何使用这种缓存框架，以Ehcache与redis整合为例：\n\n**步骤①**：导入j2cache、redis、ehcache坐标\n\n```java\n<dependency>\n    <groupId>net.oschina.j2cache</groupId>\n    <artifactId>j2cache-core</artifactId>\n    <version>2.8.4-release</version>\n</dependency>\n<dependency>\n    <groupId>net.oschina.j2cache</groupId>\n    <artifactId>j2cache-spring-boot2-starter</artifactId>\n    <version>2.8.0-release</version>\n</dependency>\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n</dependency>\n```\n\n j2cache的starter中默认包含了redis坐标，官方推荐使用redis作为二级缓存，因此此处无需导入redis坐标\n\n**步骤②**：配置一级与二级缓存，并配置一二级缓存间数据传递方式，配置书写在名称为j2cache.properties的文件中。如果使用ehcache还需要单独添加ehcache的配置文件\n\n```java\n# 1级缓存\nj2cache.L1.provider_class = ehcache\nehcache.configXml = ehcache.xml\n\n# 2级缓存\nj2cache.L2.provider_class = net.oschina.j2cache.cache.support.redis.SpringRedisProvider\nj2cache.L2.config_section = redis\nredis.hosts = localhost:6379\n\n# 1级缓存中的数据如何到达二级缓存\nj2cache.broadcast = net.oschina.j2cache.cache.support.redis.SpringRedisPubSubPolicy\n```\n\n 此处配置不能乱配置，需要参照官方给出的配置说明进行。例如1级供应商选择ehcache，供应商名称仅仅是一个ehcache，但是2级供应商选择redis时要写专用的Spring整合Redis的供应商类名SpringRedisProvider，而且这个名称并不是所有的redis包中能提供的，也不是spring包中提供的。因此配置j2cache必须参照官方文档配置，而且还要去找专用的整合包，导入对应坐标才可以使用。\n\n 一级与二级缓存最重要的一个配置就是两者之间的数据沟通方式，此类配置也不是随意配置的，并且不同的缓存解决方案提供的数据沟通方式差异化很大，需要查询官方文档进行设置。\n\n**步骤③**：使用缓存\n\n```java\n@Service\npublic class SMSCodeServiceImpl implements SMSCodeService {\n    @Autowired\n    private CodeUtils codeUtils;\n\n    @Autowired\n    private CacheChannel cacheChannel;\n\n    public String sendCodeToSMS(String tele) {\n        String code = codeUtils.generator(tele);\n        cacheChannel.set(\"sms\",tele,code);\n        return code;\n    }\n\n    public boolean checkCode(SMSCode smsCode) {\n        String code = cacheChannel.get(\"sms\",smsCode.getTele()).asString();\n        return smsCode.getCode().equals(code);\n    }\n}\n```\n\n j2cache的使用和jetcache比较类似，但是无需开启使用的开关，直接定义缓存对象即可使用，缓存对象名CacheChannel。\n\n j2cache的使用不复杂，配置是j2cache的核心，毕竟是一个整合型的缓存框架。缓存相关的配置过多，可以查阅j2cache-core核心包中的j2cache.properties文件中的说明。如下：\n\n```java\n#J2Cache configuration\n#########################################\n# Cache Broadcast Method\n# values:\n# jgroups -> use jgroups's multicast\n# redis -> use redis publish/subscribe mechanism (using jedis)\n# lettuce -> use redis publish/subscribe mechanism (using lettuce, Recommend)\n# rabbitmq -> use RabbitMQ publisher/consumer mechanism\n# rocketmq -> use RocketMQ publisher/consumer mechanism\n# none -> don't notify the other nodes in cluster\n# xx.xxxx.xxxx.Xxxxx your own cache broadcast policy classname that implement net.oschina.j2cache.cluster.ClusterPolicy\n#########################################\nj2cache.broadcast = redis\n\n# jgroups properties\njgroups.channel.name = j2cache\njgroups.configXml = /network.xml\n\n# RabbitMQ properties\nrabbitmq.exchange = j2cache\nrabbitmq.host = localhost\nrabbitmq.port = 5672\nrabbitmq.username = guest\nrabbitmq.password = guest\n\n# RocketMQ properties\nrocketmq.name = j2cache\nrocketmq.topic = j2cache\n# use ; to split multi hosts\nrocketmq.hosts = 127.0.0.1:9876\n\n#########################################\n# Level 1&2 provider\n# values:\n# none -> disable this level cache\n# ehcache -> use ehcache2 as level 1 cache\n# ehcache3 -> use ehcache3 as level 1 cache\n# caffeine -> use caffeine as level 1 cache(only in memory)\n# redis -> use redis as level 2 cache (using jedis)\n# lettuce -> use redis as level 2 cache (using lettuce)\n# readonly-redis -> use redis as level 2 cache ,but never write data to it. if use this provider, you must uncomment `j2cache.L2.config_section` to make the redis configurations available.\n# memcached -> use memcached as level 2 cache (xmemcached),\n# [classname] -> use custom provider\n#########################################\n\nj2cache.L1.provider_class = caffeine\nj2cache.L2.provider_class = redis\n\n# When L2 provider isn't `redis`, using `L2.config_section = redis` to read redis configurations\n# j2cache.L2.config_section = redis\n\n# Enable/Disable ttl in redis cache data (if disabled, the object in redis will never expire, default:true)\n# NOTICE: redis hash mode (redis.storage = hash) do not support this feature)\nj2cache.sync_ttl_to_redis = true\n\n# Whether to cache null objects by default (default false)\nj2cache.default_cache_null_object = true\n\n#########################################\n# Cache Serialization Provider\n# values:\n# fst -> using fast-serialization (recommend)\n# kryo -> using kryo serialization\n# json -> using fst's json serialization (testing)\n# fastjson -> using fastjson serialization (embed non-static class not support)\n# java -> java standard\n# fse -> using fse serialization\n# [classname implements Serializer]\n#########################################\n\nj2cache.serialization = json\n#json.map.person = net.oschina.j2cache.demo.Person\n\n#########################################\n# Ehcache configuration\n#########################################\n\n# ehcache.configXml = /ehcache.xml\n\n# ehcache3.configXml = /ehcache3.xml\n# ehcache3.defaultHeapSize = 1000\n\n#########################################\n# Caffeine configuration\n# caffeine.region.[name] = size, xxxx[s|m|h|d]\n#\n#########################################\ncaffeine.properties = /caffeine.properties\n\n#########################################\n# Redis connection configuration\n#########################################\n\n#########################################\n# Redis Cluster Mode\n#\n# single -> single redis server\n# sentinel -> master-slaves servers\n# cluster -> cluster servers (数据库配置无效，使用 database = 0）\n# sharded -> sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）\n#\n#########################################\n\nredis.mode = single\n\n#redis storage mode (generic|hash)\nredis.storage = generic\n\n## redis pub/sub channel name\nredis.channel = j2cache\n## redis pub/sub server (using redis.hosts when empty)\nredis.channel.host =\n\n#cluster name just for sharded\nredis.cluster_name = j2cache\n\n## redis cache namespace optional, default[empty]\nredis.namespace =\n\n## redis command scan parameter count, default[1000]\n#redis.scanCount = 1000\n\n## connection\n# Separate multiple redis nodes with commas, such as 192.168.0.10:6379,192.168.0.11:6379,192.168.0.12:6379\n\nredis.hosts = 127.0.0.1:6379\nredis.timeout = 2000\nredis.password =\nredis.database = 0\nredis.ssl = false\n\n## redis pool properties\nredis.maxTotal = 100\nredis.maxIdle = 10\nredis.maxWaitMillis = 5000\nredis.minEvictableIdleTimeMillis = 60000\nredis.minIdle = 1\nredis.numTestsPerEvictionRun = 10\nredis.lifo = false\nredis.softMinEvictableIdleTimeMillis = 10\nredis.testOnBorrow = true\nredis.testOnReturn = false\nredis.testWhileIdle = true\nredis.timeBetweenEvictionRunsMillis = 300000\nredis.blockWhenExhausted = false\nredis.jmxEnabled = false\n\n#########################################\n# Lettuce scheme\n#\n# redis -> single redis server\n# rediss -> single redis server with ssl\n# redis-sentinel -> redis sentinel\n# redis-cluster -> cluster servers\n#\n#########################################\n\n#########################################\n# Lettuce Mode\n#\n# single -> single redis server\n# sentinel -> master-slaves servers\n# cluster -> cluster servers (数据库配置无效，使用 database = 0）\n# sharded -> sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）\n#\n#########################################\n\n## redis command scan parameter count, default[1000]\n#lettuce.scanCount = 1000\nlettuce.mode = single\nlettuce.namespace =\nlettuce.storage = hash\nlettuce.channel = j2cache\nlettuce.scheme = redis\nlettuce.hosts = 127.0.0.1:6379\nlettuce.password =\nlettuce.database = 0\nlettuce.sentinelMasterId =\nlettuce.maxTotal = 100\nlettuce.maxIdle = 10\nlettuce.minIdle = 10\n# timeout in milliseconds\nlettuce.timeout = 10000\n# redis cluster topology refresh interval in milliseconds\nlettuce.clusterTopologyRefresh = 3000\n\n#########################################\n# memcached server configurations\n# refer to https://gitee.com/mirrors/XMemcached\n#########################################\n\nmemcached.servers = 127.0.0.1:11211\nmemcached.username =\nmemcached.password =\nmemcached.connectionPoolSize = 10\nmemcached.connectTimeout = 1000\nmemcached.failureMode = false\nmemcached.healSessionInterval = 1000\nmemcached.maxQueuedNoReplyOperations = 100\nmemcached.opTimeout = 100\nmemcached.sanitizeKeys = false\n```\n\n**总结**\n\n1. j2cache是一个缓存框架，自身不具有缓存功能，它提供多种缓存整合在一起使用的方案\n2. j2cache需要通过复杂的配置设置各级缓存，以及缓存之间数据交换的方式\n3. j2cache操作接口通过CacheChannel实现\n\n#### KF-5-2.任务\n\n springboot整合第三方技术第二部分我们来说说任务系统，其实这里说的任务系统指的是定时任务。定时任务是企业级开发中必不可少的组成部分，诸如长周期业务数据的计算，例如年度报表，诸如系统脏数据的处理，再比如系统性能监控报告，还有抢购类活动的商品上架，这些都离不开定时任务。本节将介绍两种不同的定时任务技术。\n\n##### Quartz\n\n Quartz技术是一个比较成熟的定时任务框架，怎么说呢？有点繁琐，用过的都知道，配置略微复杂。springboot对其进行整合后，简化了一系列的配置，将很多配置采用默认设置，这样开发阶段就简化了很多。再学习springboot整合Quartz前先普及几个Quartz的概念。\n\n- 工作（Job）：用于定义具体执行的工作\n- 工作明细（JobDetail）：用于描述定时工作相关的信息\n- 触发器（Trigger）：描述了工作明细与调度器的对应关系\n- 调度器（Scheduler）：用于描述触发工作的执行规则，通常使用cron表达式定义规则\n\n 简单说就是你定时干什么事情，这就是工作，工作不可能就是一个简单的方法，还要设置一些明细信息。工作啥时候执行，设置一个调度器，可以简单理解成设置一个工作执行的时间。工作和调度都是独立定义的，它们两个怎么配合到一起呢？用触发器。完了，就这么多。下面开始springboot整合Quartz。\n\n**步骤①**：导入springboot整合Quartz的starter\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-quartz</artifactId>\n</dependency>\n```\n\n**步骤②**：定义任务Bean，按照Quartz的开发规范制作，继承QuartzJobBean\n\n```java\npublic class MyQuartz extends QuartzJobBean {\n    @Override\n    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {\n        System.out.println(\"quartz task run...\");\n    }\n}\n```\n\n**步骤③**：创建Quartz配置类，定义工作明细（JobDetail）与触发器的（Trigger）bean\n\n```java\n@Configuration\npublic class QuartzConfig {\n    @Bean\n    public JobDetail printJobDetail(){\n        //绑定具体的工作\n        return JobBuilder.newJob(MyQuartz.class).storeDurably().build();\n    }\n    @Bean\n    public Trigger printJobTrigger(){\n        ScheduleBuilder schedBuilder = CronScheduleBuilder.cronSchedule(\"0/5 * * * * ?\");\n        //绑定对应的工作明细\n        return TriggerBuilder.newTrigger().forJob(printJobDetail()).withSchedule(schedBuilder).build();\n    }\n}\n```\n\n 工作明细中要设置对应的具体工作，使用newJob()操作传入对应的工作任务类型即可。\n\n 触发器需要绑定任务，使用forJob()操作传入绑定的工作明细对象。此处可以为工作明细设置名称然后使用名称绑定，也可以直接调用对应方法绑定。触发器中最核心的规则是执行时间，此处使用调度器定义执行时间，执行时间描述方式使用的是cron表达式。有关cron表达式的规则，各位小伙伴可以去参看相关课程学习，略微复杂，而且格式不能乱设置，不是写个格式就能用的，写不好就会出现冲突问题。\n\n**总结**\n\n1. springboot整合Quartz就是将Quartz对应的核心对象交给spring容器管理，包含两个对象，JobDetail和Trigger对象\n2. JobDetail对象描述的是工作的执行信息，需要绑定一个QuartzJobBean类型的对象\n3. Trigger对象定义了一个触发器，需要为其指定绑定的JobDetail是哪个，同时要设置执行周期调度器\n\n**思考**\n\n 上面的操作看上去不多，但是Quartz将其中的对象划分粒度过细，导致开发的时候有点繁琐，spring针对上述规则进行了简化，开发了自己的任务管理组件——Task，如何用呢？咱们下节再说。\n\n##### Task\n\n spring根据定时任务的特征，将定时任务的开发简化到了极致。怎么说呢？要做定时任务总要告诉容器有这功能吧，然后定时执行什么任务直接告诉对应的bean什么时间执行就行了，就这么简单，一起来看怎么做\n\n**步骤①**：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解@EnableScheduling\n\n```java\n@SpringBootApplication\n//开启定时任务功能\n@EnableScheduling\npublic class Springboot22TaskApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot22TaskApplication.class, args);\n    }\n}\n```\n\n**步骤②**：定义Bean，在对应要定时执行的操作上方，使用注解@Scheduled定义执行的时间，执行时间的描述方式还是cron表达式\n\n```java\n@Component\npublic class MyBean {\n    @Scheduled(cron = \"0/1 * * * * ?\")\n    public void print(){\n        System.out.println(Thread.currentThread().getName()+\" :spring task run...\");\n    }\n}\n```\n\n 完事，这就完成了定时任务的配置。总体感觉其实什么东西都没少，只不过没有将所有的信息都抽取成bean，而是直接使用注解绑定定时执行任务的事情而已。\n\n 如何想对定时任务进行相关配置，可以通过配置文件进行\n\n```java\nspring:\n  task:\n   \tscheduling:\n      pool:\n       \tsize: 1\t\t\t\t\t\t\t# 任务调度线程池大小 默认 1\n      thread-name-prefix: ssm_      \t# 调度线程名称前缀 默认 scheduling-      \n        shutdown:\n          await-termination: false\t\t# 线程池关闭时等待所有任务完成\n          await-termination-period: 10s\t# 调度线程关闭前最大等待时间，确保最后一定关闭\n```\n\n**总结**\n\n1. \n spring task需要使用注解@EnableScheduling开启定时任务功能\n2. \n 为定时执行的的任务设置执行周期，描述方式cron表达式\n\n#### KF-5-3.邮件\n\n springboot整合第三方技术第三部分我们来说说邮件系统，发邮件是java程序的基本操作，springboot整合javamail其实就是简化开发。不熟悉邮件的小伙伴可以先学习完javamail的基础操作，再来看这一部分内容才能感触到springboot整合javamail究竟简化了哪些操作。简化的多码？其实不多，差别不大，只是还个格式而已。\n\n 学习邮件发送之前先了解3个概念，这些概念规范了邮件操作过程中的标准。\n\n- SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于**发送**电子邮件的传输协议\n- POP3（Post Office Protocol - Version 3）：用于**接收**电子邮件的标准协议\n- IMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议\n\n 简单说就是SMPT是发邮件的标准，POP3是收邮件的标准，IMAP是对POP3的升级。我们制作程序中操作邮件，通常是发邮件，所以SMTP是使用的重点，收邮件大部分都是通过邮件客户端完成，所以开发收邮件的代码极少。除非你要读取邮件内容，然后解析，做邮件功能的统一处理。例如HR的邮箱收到求职者的简历，可以读取后统一处理。但是为什么不制作独立的投递简历的系统呢？所以说，好奇怪的需求，因为要想收邮件就要规范发邮件的人的书写格式，这个未免有点强人所难，并且极易收到外部攻击，你不可能使用白名单来收邮件。如果能使用白名单来收邮件然后解析邮件，还不如开发个系统给白名单中的人专用呢，更安全，总之就是鸡肋了。下面就开始学习springboot如何整合javamail发送邮件。\n\n##### 发送简单邮件\n\n**步骤①**：导入springboot整合javamail的starter\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n```\n\n**步骤②**：配置邮箱的登录信息\n\n```java\nspring:\n  mail:\n    host: smtp.126.com\n    username: test@126.com\n    password: test\n```\n\n java程序仅用于发送邮件，邮件的功能还是邮件供应商提供的，所以这里是用别人的邮件服务，要配置对应信息。\n\n host配置的是提供邮件服务的主机协议，当前程序仅用于发送邮件，因此配置的是smtp的协议。\n\n password并不是邮箱账号的登录密码，是邮件供应商提供的一个加密后的密码，也是为了保障系统安全性。不然外部人员通过地址访问下载了配置文件，直接获取到了邮件密码就会有极大的安全隐患。有关该密码的获取每个邮件供应商提供的方式都不一样，此处略过。可以到邮件供应商的设置页面找POP3或IMAP这些关键词找到对应的获取位置。下例仅供参考：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/1430c59062667f57d04273ba5195d295.png)\n\n**步骤③**：使用JavaMailSender接口发送邮件\n\n```java\n@Service\npublic class SendMailServiceImpl implements SendMailService {\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    //发送人\n    private String from = \"test@qq.com\";\n    //接收人\n    private String to = \"test@126.com\";\n    //标题\n    private String subject = \"测试邮件\";\n    //正文\n    private String context = \"测试邮件正文内容\";\n\n    @Override\n    public void sendMail() {\n        SimpleMailMessage message = new SimpleMailMessage();\n        message.setFrom(from+\"(小甜甜)\");\n        message.setTo(to);\n        message.setSubject(subject);\n        message.setText(context);\n        javaMailSender.send(message);\n    }\n}\n```\n\n 将发送邮件的必要信息（发件人、收件人、标题、正文）封装到SimpleMailMessage对象中，可以根据规则设置发送人昵称等。\n\n##### 发送多组件邮件（附件、复杂正文）\n\n 发送简单邮件仅需要提供对应的4个基本信息就可以了，如果想发送复杂的邮件，需要更换邮件对象。使用MimeMessage可以发送特殊的邮件。\n\n**发送网页正文邮件**\n\n```java\n@Service\npublic class SendMailServiceImpl2 implements SendMailService {\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    //发送人\n    private String from = \"test@qq.com\";\n    //接收人\n    private String to = \"test@126.com\";\n    //标题\n    private String subject = \"测试邮件\";\n    //正文\n    private String context = \"<img src='ABC.JPG'/><a href='https://www.itcast.cn'>点开有惊喜</a>\";\n\n    public void sendMail() {\n        try {\n            MimeMessage message = javaMailSender.createMimeMessage();\n            MimeMessageHelper helper = new MimeMessageHelper(message);\n            helper.setFrom(to+\"(小甜甜)\");\n            helper.setTo(from);\n            helper.setSubject(subject);\n            helper.setText(context,true);\t\t//此处设置正文支持html解析\n\n            javaMailSender.send(message);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**发送带有附件的邮件**\n\n```java\n@Service\npublic class SendMailServiceImpl2 implements SendMailService {\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    //发送人\n    private String from = \"test@qq.com\";\n    //接收人\n    private String to = \"test@126.com\";\n    //标题\n    private String subject = \"测试邮件\";\n    //正文\n    private String context = \"测试邮件正文\";\n\n    public void sendMail() {\n        try {\n            MimeMessage message = javaMailSender.createMimeMessage();\n            MimeMessageHelper helper = new MimeMessageHelper(message,true);\t\t//此处设置支持附件\n            helper.setFrom(to+\"(小甜甜)\");\n            helper.setTo(from);\n            helper.setSubject(subject);\n            helper.setText(context);\n\n            //添加附件\n            File f1 = new File(\"springboot_23_mail-0.0.1-SNAPSHOT.jar\");\n            File f2 = new File(\"resources\\\\logo.png\");\n\n            helper.addAttachment(f1.getName(),f1);\n            helper.addAttachment(\"最靠谱的培训结构.png\",f2);\n\n            javaMailSender.send(message);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**总结**\n\n1. springboot整合javamail其实就是简化了发送邮件的客户端对象JavaMailSender的初始化过程，通过配置的形式加载信息简化开发过程\n\n#### KF-5-4.消息\n\n springboot整合第三方技术最后一部分我们来说说消息中间件，首先先介绍一下消息的应用。\n\n##### 消息的概念\n\n 从广义角度来说，消息其实就是信息，但是和信息又有所不同。信息通常被定义为一组数据，而消息除了具有数据的特征之外，还有消息的来源与接收的概念。通常发送消息的一方称为消息的生产者，接收消息的一方称为消息的消费者。这样比较后，发现其实消息和信息差别还是很大的。\n\n 为什么要设置生产者和消费者呢？这就是要说到消息的意义了。信息通常就是一组数据，但是消息由于有了生产者和消费者，就出现了消息中所包含的信息可以被二次解读，生产者发送消息，可以理解为生产者发送了一个信息，也可以理解为生产者发送了一个命令；消费者接收消息，可以理解为消费者得到了一个信息，也可以理解为消费者得到了一个命令。对比一下我们会发现信息是一个基本数据，而命令则可以关联下一个行为动作，这样就可以理解为基于接收的消息相当于得到了一个行为动作，使用这些行为动作就可以组织成一个业务逻辑，进行进一步的操作。总的来说，消息其实也是一组信息，只是为其赋予了全新的含义，因为有了消息的流动，并且是有方向性的流动，带来了基于流动的行为产生的全新解读。开发者就可以基于消息的这种特殊解，将其换成代码中的指令。\n\n 对于消息的理解，初学者总认为消息内部的数据非常复杂，这是一个误区。比如我发送了一个消息，要求接受者翻译发送过去的内容。初学者会认为消息中会包含被翻译的文字，已经本次操作要执行翻译操作而不是打印操作。其实这种现象有点过度解读了，发送的消息中仅仅包含被翻译的文字，但是可以通过控制不同的人接收此消息来确认要做的事情。例如发送被翻译的文字仅到A程序，而A程序只能进行翻译操作，这样就可以发送简单的信息完成复杂的业务了，是通过接收消息的主体不同，进而执行不同的操作，而不会在消息内部定义数据的操作行为，当然如果开发者希望消息中包含操作种类信息也是可以的，只是提出消息的内容可以更简单，更单一。\n\n 对于消息的生产者与消费者的工作模式，还可以将消息划分成两种模式，同步消费与异步消息。\n\n 所谓同步消息就是生产者发送完消息，等待消费者处理，消费者处理完将结果告知生产者，然后生产者继续向下执行业务。这种模式过于卡生产者的业务执行连续性，在现在的企业级开发中，上述这种业务场景通常不会采用消息的形式进行处理。\n\n 所谓异步消息就是生产者发送完消息，无需等待消费者处理完毕，生产者继续向下执行其他动作。比如生产者发送了一个日志信息给日志系统，发送过去以后生产者就向下做其他事情了，无需关注日志系统的执行结果。日志系统根据接收到的日志信息继续进行业务执行，是单纯的记录日志，还是记录日志并报警，这些和生产者无关，这样生产者的业务执行效率就会大幅度提升。并且可以通过添加多个消费者来处理同一个生产者发送的消息来提高系统的高并发性，改善系统工作效率，提高用户体验。一旦某一个消费者由于各种问题宕机了，也不会对业务产生影响，提高了系统的高可用性。\n\n 以上简单的介绍了一下消息这种工作模式存在的意义，希望对各位学习者有所帮助。\n\n##### Java处理消息的标准规范\n\n 目前企业级开发中广泛使用的消息处理技术共三大类，具体如下：\n\n- JMS\n- AMQP\n- MQTT\n\n 为什么是三大类，而不是三个技术呢？因为这些都是规范，就想JDBC技术，是个规范，开发针对规范开发，运行还要靠实现类，例如MySQL提供了JDBC的实现，最终运行靠的还是实现。并且这三类规范都是针对异步消息进行处理的，也符合消息的设计本质，处理异步的业务。对以上三种消息规范做一下普及\n\n\n JMS（Java Message Service）,这是一个规范，作用等同于JDBC规范，提供了与消息服务相关的API接口。\n\n**JMS消息模型**\n\n JMS规范中规范了消息有两种模型。分别是**点对点模型**和**发布订阅模型**。\n\n **点对点模型**：peer-2-peer，生产者会将消息发送到一个保存消息的容器中，通常使用队列模型，使用队列保存消息。一个队列的消息只能被一个消费者消费，或未被及时消费导致超时。这种模型下，生产者和消费者是一对一绑定的。\n\n **发布订阅模型**：publish-subscribe，生产者将消息发送到一个保存消息的容器中，也是使用队列模型来保存。但是消息可以被多个消费者消费，生产者和消费者完全独立，相互不需要感知对方的存在。\n\n 以上这种分类是从消息的生产和消费过程来进行区分，针对消息所包含的信息不同，还可以进行不同类别的划分。\n\n**JMS消息种类**\n\n 根据消息中包含的数据种类划分，可以将消息划分成6种消息。\n\n- TextMessage\n- MapMessage\n- BytesMessage\n- StreamMessage\n- ObjectMessage\n- Message （只有消息头和属性）\n\n JMS主张不同种类的消息，消费方式不同，可以根据使用需要选择不同种类的消息。但是这一点也成为其诟病之处，后面再说。整体上来说，JMS就是典型的保守派，什么都按照J2EE的规范来，做一套规范，定义若干个标准，每个标准下又提供一大批API。目前对JMS规范实现的消息中间件技术还是挺多的，毕竟是皇家御用，肯定有人舔，例如ActiveMQ、Redis、HornetMQ。但是也有一些不太规范的实现，参考JMS的标准设计，但是又不完全满足其规范，例如：RabbitMQ、RocketMQ。\n\n\n JMS的问世为消息中间件提供了很强大的规范性支撑，但是使用的过程中就开始被人诟病，比如JMS设置的极其复杂的多种类消息处理机制。本来分门别类处理挺好的，为什么会被诟病呢？原因就在于JMS的设计是J2EE规范，站在Java开发的角度思考问题。但是现实往往是复杂度很高的。比如我有一个.NET开发的系统A，有一个Java开发的系统B，现在要从A系统给B系统发业务消息，结果两边数据格式不统一，没法操作。JMS不是可以统一数据格式吗？提供了6种数据种类，总有一款适合你啊。NO，一个都不能用。因为A系统的底层语言不是Java语言开发的，根本不支持那些对象。这就意味着如果想使用现有的业务系统A继续开发已经不可能了，必须推翻重新做使用Java语言开发的A系统。\n\n 这时候有人就提出说，你搞那么复杂，整那么多种类干什么？找一种大家都支持的消息数据类型不就解决这个跨平台的问题了吗？大家一想，对啊，于是AMQP孕育而生。\n\n 单从上面的说明中其实可以明确感知到，AMQP的出现解决的是消息传递时使用的消息种类的问题，化繁为简，但是其并没有完全推翻JMS的操作API，所以说AMQP仅仅是一种协议，规范了数据传输的格式而已。\n\n AMQP（advanced message queuing protocol）：一种协议（高级消息队列协议，也是消息代理规范），规范了网络交换的数据格式，兼容JMS操作。**优点**\n\n 具有跨平台性，服务器供应商，生产者，消费者可以使用不同的语言来实现\n\n**JMS消息种类**\n\n AMQP消息种类：byte[]\n\n AMQP在JMS的消息模型基础上又进行了进一步的扩展，除了点对点和发布订阅的模型，开发了几种全新的消息模型，适应各种各样的消息发送。\n\n**AMQP消息模型**\n\n- direct exchange\n- fanout exchange\n- topic exchange\n- headers exchange\n- system exchange\n\n 目前实现了AMQP协议的消息中间件技术也很多，而且都是较为流行的技术，例如：RabbitMQ、StormMQ、RocketMQ\n\n\n MQTT（Message Queueing Telemetry Transport）消息队列遥测传输，专为小设备设计，是物联网（IOT）生态系统中主要成分之一。由于与JavaEE企业级开发没有交集，此处不作过多的说明。\n\n 除了上述3种J2EE企业级应用中广泛使用的三种异步消息传递技术，还有一种技术也不能忽略，Kafka。\n\n\n Kafka，一种高吞吐量的分布式发布订阅消息系统，提供实时消息功能。Kafka技术并不是作为消息中间件为主要功能的产品，但是其拥有发布订阅的工作模式，也可以充当消息中间件来使用，而且目前企业级开发中其身影也不少见。\n\n 本节内容讲围绕着上述内容中的几种实现方案讲解springboot整合各种各样的消息中间件。由于各种消息中间件必须先安装再使用，下面的内容采用Windows系统安装，降低各位学习者的学习难度，基本套路和之前学习NoSQL解决方案一样，先安装再整合。\n\n##### 购物订单发送手机短信案例\n\n 为了便于下面演示各种各样的消息中间件技术，我们创建一个购物过程生成订单时为用户发送短信的案例环境，模拟使用消息中间件实现发送手机短信的过程。\n\n 手机验证码案例需求如下：\n\n- \n 执行下单业务时（模拟此过程），调用消息服务，将要发送短信的订单id传递给消息中间件\n- \n 消息处理服务接收到要发送的订单id后输出订单id（模拟发短信）\n 由于不涉及数据读写，仅开发业务层与表现层，其中短信处理的业务代码独立开发，代码如下：\n\n**订单业务**\n\n **业务层接口**\n\n```java\npublic interface OrderService {\n    void order(String id);\n}\n```\n\n 模拟传入订单id，执行下订单业务，参数为虚拟设定，实际应为订单对应的实体类\n\n **业务层实现**\n\n```java\n@Service\npublic class OrderServiceImpl implements OrderService {\n    @Autowired\n    private MessageService messageService;\n    \n    @Override\n    public void order(String id) {\n        //一系列操作，包含各种服务调用，处理各种业务\n        System.out.println(\"订单处理开始\");\n        //短信消息处理\n        messageService.sendMessage(id);\n        System.out.println(\"订单处理结束\");\n        System.out.println();\n    }\n}\n```\n\n 业务层转调短信处理的服务MessageService\n\n **表现层服务**\n\n```java\n@RestController\n@RequestMapping(\"/orders\")\npublic class OrderController {\n\n    @Autowired\n    private OrderService orderService;\n\n    @PostMapping(\"{id}\")\n    public void order(@PathVariable String id){\n        orderService.order(id);\n    }\n}\n```\n\n 表现层对外开发接口，传入订单id即可（模拟）\n\n**短信处理业务**\n\n **业务层接口**\n\n```java\npublic interface MessageService {\n    void sendMessage(String id);\n    String doMessage();\n}\n```\n\n 短信处理业务层接口提供两个操作，发送要处理的订单id到消息中间件，另一个操作目前暂且设计成处理消息，实际消息的处理过程不应该是手动执行，应该是自动执行，到具体实现时再进行设计\n\n **业务层实现**\n\n```java\n@Service\npublic class MessageServiceImpl implements MessageService {\n    private ArrayList<String> msgList = new ArrayList<String>();\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println(\"待发送短信的订单已纳入处理队列，id：\"+id);\n        msgList.add(id);\n    }\n\n    @Override\n    public String doMessage() {\n        String id = msgList.remove(0);\n        System.out.println(\"已完成短信发送业务，id：\"+id);\n        return id;\n    }\n}\n```\n\n 短信处理业务层实现中使用集合先模拟消息队列，观察效果\n\n **表现层服务**\n\n```java\n@RestController\n@RequestMapping(\"/msgs\")\npublic class MessageController {\n\n    @Autowired\n    private MessageService messageService;\n\n    @GetMapping\n    public String doMessage(){\n        String id = messageService.doMessage();\n        return id;\n    }\n}\n```\n\n 短信处理表现层接口暂且开发出一个处理消息的入口，但是此业务是对应业务层中设计的模拟接口，实际业务不需要设计此接口。\n\n 下面开启springboot整合各种各样的消息中间件，从严格满足JMS规范的ActiveMQ开始\n\n##### SpringBoot整合ActiveMQ\n\n ActiveMQ是MQ产品中的元老级产品，早期标准MQ产品之一，在AMQP协议没有出现之前，占据了消息中间件市场的绝大部分份额，后期因为AMQP系列产品的出现，迅速走弱，目前仅在一些线上运行的产品中出现，新产品开发较少采用。\n\n\n windows版安装包下载地址： [https://activemq.apache.org/components/classic/download](https://activemq.apache.org/components/classic/download/) [/](https://activemq.apache.org/components/classic/download/)\n\n 下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/6b4f90d349a4df41a105f10f5c200c10.png)\n\n**启动服务器**\n\n```java\nactivemq.bat\n```\n\n 运行bin目录下的win32或win64目录下的activemq.bat命令即可，根据自己的操作系统选择即可，默认对外服务端口61616。\n\n**访问web管理服务**\n\n ActiveMQ启动后会启动一个Web控制台服务，可以通过该服务管理ActiveMQ。\n\n```java\nhttp://127.0.0.1:8161/\n```\n\n web管理服务默认端口8161，访问后可以打开ActiveMQ的管理界面，如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/cdd2e4bf7738a0d479861b542b47eaed.png)\n\n 首先输入访问用户名和密码，初始化用户名和密码相同，均为：admin，成功登录后进入管理后台界面，如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/1ae2cc2d57b5c7356fb5fa4e868f44e3.png)\n\n 看到上述界面视为启动ActiveMQ服务成功。\n\n**启动失败**\n\n 在ActiveMQ启动时要占用多个端口，以下为正常启动信息：\n\n```java\nwrapper  | --> Wrapper Started as Console\nwrapper  | Launching a JVM...\njvm 1    | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.org\njvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.\njvm 1    |\njvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\\soft\\jdk1.8.0_172\\jre\njvm 1    |   Heap sizes: current=249344k  free=235037k  max=932352k\njvm 1    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.net.ssl.keyStorePassword=password -Djavax.net.ssl.trustStorePassword=password -Djavax.net.ssl.keyStore=../../conf/broker.ks -Djavax.net.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.path=../../bin/win64 -Dwrapper.key=7ySrCD75XhLCpLjd -Dwrapper.port=32000 -Dwrapper.jvm.port.min=31000 -Dwrapper.jvm.port.max=31999 -Dwrapper.pid=9364 -Dwrapper.version=3.2.3 -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=10 -Dwrapper.jvmid=1\njvm 1    | Extensions classpath:\njvm 1    |   [..\\..\\lib,..\\..\\lib\\camel,..\\..\\lib\\optional,..\\..\\lib\\web,..\\..\\lib\\extra]\njvm 1    | ACTIVEMQ_HOME: ..\\..\njvm 1    | ACTIVEMQ_BASE: ..\\..\njvm 1    | ACTIVEMQ_CONF: ..\\..\\conf\njvm 1    | ACTIVEMQ_DATA: ..\\..\\data\njvm 1    | Loading message broker from: xbean:activemq.xml\njvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@5f3ebfe0: startup date [Mon Feb 28 16:07:48 CST 2022]; root of context hierarchy\njvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb]\njvm 1    |  INFO | KahaDB is version 7\njvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] started\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) is starting\njvm 1    |  INFO | Listening for connections at: tcp://CZBK-20210302VL:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector openwire started\njvm 1    |  INFO | Listening for connections at: amqp://CZBK-20210302VL:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector amqp started\njvm 1    |  INFO | Listening for connections at: stomp://CZBK-20210302VL:61613?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector stomp started\njvm 1    |  INFO | Listening for connections at: mqtt://CZBK-20210302VL:1883?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector mqtt started\njvm 1    |  INFO | Starting Jetty server\njvm 1    |  INFO | Creating Jetty connector\njvm 1    |  WARN | ServletContext@o.e.j.s.ServletContextHandler@7350746f{/,null,STARTING} has uncovered http methods for path: /\njvm 1    |  INFO | Listening for connections at ws://CZBK-20210302VL:61614?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector ws started\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) started\njvm 1    |  INFO | For help or more information please see: http://activemq.apache.org\njvm 1    |  WARN | Store limit is 102400 mb (current store usage is 0 mb). The data directory: D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb only has 68936 mb of usable space. - resetting to maximum available disk space: 68936 mb\njvm 1    |  INFO | ActiveMQ WebConsole available at http://127.0.0.1:8161/\njvm 1    |  INFO | ActiveMQ Jolokia REST API available at http://127.0.0.1:8161/api/jolokia/\n```\n\n 其中占用的端口有：61616、5672、61613、1883、61614，如果启动失败，请先管理对应端口即可。以下就是某个端口占用的报错信息，可以从抛出异常的位置看出，启动5672端口时端口被占用，显示java.net.BindException: Address already in use: JVM_Bind。Windows系统中终止端口运行的操作参看 [【命令行启动常见问题及解决方案】](#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)\n\n```java\nwrapper  | --> Wrapper Started as Console\nwrapper  | Launching a JVM...\njvm 1    | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.org\njvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.\njvm 1    |\njvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\\soft\\jdk1.8.0_172\\jre\njvm 1    |   Heap sizes: current=249344k  free=235038k  max=932352k\njvm 1    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.net.ssl.keyStorePassword=password -Djavax.net.ssl.trustStorePassword=password -Djavax.net.ssl.keyStore=../../conf/broker.ks -Djavax.net.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.path=../../bin/win64 -Dwrapper.key=QPJoy9ZoXeWmmwTS -Dwrapper.port=32000 -Dwrapper.jvm.port.min=31000 -Dwrapper.jvm.port.max=31999 -Dwrapper.pid=14836 -Dwrapper.version=3.2.3 -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=10 -Dwrapper.jvmid=1\njvm 1    | Extensions classpath:\njvm 1    |   [..\\..\\lib,..\\..\\lib\\camel,..\\..\\lib\\optional,..\\..\\lib\\web,..\\..\\lib\\extra]\njvm 1    | ACTIVEMQ_HOME: ..\\..\njvm 1    | ACTIVEMQ_BASE: ..\\..\njvm 1    | ACTIVEMQ_CONF: ..\\..\\conf\njvm 1    | ACTIVEMQ_DATA: ..\\..\\data\njvm 1    | Loading message broker from: xbean:activemq.xml\njvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchy\njvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb]\njvm 1    |  INFO | KahaDB is version 7\njvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] started\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is starting\njvm 1    |  INFO | Listening for connections at: tcp://CZBK-20210302VL:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600\njvm 1    |  INFO | Connector openwire started\njvm 1    | ERROR | Failed to start Apache ActiveMQ (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1)\njvm 1    | java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bind\njvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:28)\njvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2288)\njvm 1    |      at org.apache.activemq.broker.BrokerService.startTransportConnector(BrokerService.java:2769)\njvm 1    |      at org.apache.activemq.broker.BrokerService.startAllConnectors(BrokerService.java:2665)\njvm 1    |      at org.apache.activemq.broker.BrokerService.doStartBroker(BrokerService.java:780)\njvm 1    |      at org.apache.activemq.broker.BrokerService.startBroker(BrokerService.java:742)\njvm 1    |      at org.apache.activemq.broker.BrokerService.start(BrokerService.java:645)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:73)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1748)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1685)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1615)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)\njvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:481)\njvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312)\njvm 1    |      at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\njvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308)\njvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)\njvm 1    |      at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:756)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)\njvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)\njvm 1    |      at java.lang.Thread.run(Thread.java:748)\njvm 1    | Caused by: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bind\njvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:34)\njvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:146)\njvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportFactory.doBind(TcpTransportFactory.java:62)\njvm 1    |      at org.apache.activemq.transport.TransportFactorySupport.bind(TransportFactorySupport.java:40)\njvm 1    |      at org.apache.activemq.broker.TransportConnector.createTransportServer(TransportConnector.java:335)\njvm 1    |      at org.apache.activemq.broker.TransportConnector.getServer(TransportConnector.java:145)\njvm 1    |      at org.apache.activemq.broker.TransportConnector.asManagedConnector(TransportConnector.java:110)\njvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2283)\njvm 1    |      ... 46 more\njvm 1    | Caused by: java.net.BindException: Address already in use: JVM_Bind\njvm 1    |      at java.net.DualStackPlainSocketImpl.bind0(Native Method)\njvm 1    |      at java.net.DualStackPlainSocketImpl.socketBind(DualStackPlainSocketImpl.java:106)\njvm 1    |      at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:387)\njvm 1    |      at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:190)\njvm 1    |      at java.net.ServerSocket.bind(ServerSocket.java:375)\njvm 1    |      at java.net.ServerSocket.<init>(ServerSocket.java:237)\njvm 1    |      at javax.net.DefaultServerSocketFactory.createServerSocket(ServerSocketFactory.java:231)\njvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:143)\njvm 1    |      ... 52 more\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutting down\njvm 1    |  INFO | socketQueue interrupted - stopping\njvm 1    |  INFO | Connector openwire stopped\njvm 1    |  INFO | Could not accept connection during shutdown  : null (null)\njvm 1    |  INFO | Connector amqp stopped\njvm 1    |  INFO | Connector stomp stopped\njvm 1    |  INFO | Connector mqtt stopped\njvm 1    |  INFO | Connector ws stopped\njvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] stopped\njvm 1    |  INFO | Stopping async queue tasks\njvm 1    |  INFO | Stopping async topic tasks\njvm 1    |  INFO | Stopped KahaDB\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) uptime 0.426 seconds\njvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutdown\njvm 1    |  INFO | Closing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchy\njvm 1    |  WARN | Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.apache.activemq.xbean.XBeanBrokerService#0' defined in class path resource [activemq.xml]: Invocation of init method failed; nested exception is java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bind\njvm 1    | ERROR: java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContext\njvm 1    | java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContext\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:91)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)\njvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)\njvm 1    |      at java.lang.Thread.run(Thread.java:748)\njvm 1    | Caused by: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContext\njvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)\njvm 1    |      ... 16 more\njvm 1    | ERROR: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContext\njvm 1    | java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContext\njvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)\njvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)\njvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)\njvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)\njvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)\njvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)\njvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)\njvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)\njvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\njvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)\njvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)\njvm 1    |      at java.lang.Thread.run(Thread.java:748)\nwrapper  | <-- Wrapper Stopped\n请按任意键继续. . .\n```\n\n\n 做了这么多springboot整合第三方技术，已经摸到门路了，加坐标，做配置，调接口，直接开工\n\n**步骤①**：导入springboot整合ActiveMQ的starter\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n```\n\n**步骤②**：配置ActiveMQ的服务器地址\n\n```java\nspring:\n  activemq:\n    broker-url: tcp://localhost:61616\n```\n\n**步骤③**：使用JmsMessagingTemplate操作ActiveMQ\n\n```java\n@Service\npublic class MessageServiceActivemqImpl implements MessageService {\n    @Autowired\n    private JmsMessagingTemplate messagingTemplate;\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println(\"待发送短信的订单已纳入处理队列，id：\"+id);\n        messagingTemplate.convertAndSend(\"order.queue.id\",id);\n    }\n\n    @Override\n    public String doMessage() {\n        String id = messagingTemplate.receiveAndConvert(\"order.queue.id\",String.class);\n        System.out.println(\"已完成短信发送业务，id：\"+id);\n        return id;\n    }\n}\n```\n\n 发送消息需要先将消息的类型转换成字符串，然后再发送，所以是convertAndSend，定义消息发送的位置，和具体的消息内容，此处使用id作为消息内容。\n\n 接收消息需要先将消息接收到，然后再转换成指定的数据类型，所以是receiveAndConvert，接收消息除了提供读取的位置，还要给出转换后的数据的具体类型。\n\n**步骤④**：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n```java\n@Component\npublic class MessageListener {\n    @JmsListener(destination = \"order.queue.id\")\n    @SendTo(\"order.other.queue.id\")\n    public String receive(String id){\n        System.out.println(\"已完成短信发送业务，id：\"+id);\n        return \"new:\"+id;\n    }\n}\n```\n\n 使用注解@JmsListener定义当前方法监听ActiveMQ中指定名称的消息队列。\n\n 如果当前消息队列处理完还需要继续向下传递当前消息到另一个队列中使用注解@SendTo即可，这样即可构造连续执行的顺序消息队列。\n\n**步骤⑤**：切换消息模型由点对点模型到发布订阅模型，修改jms配置即可\n\n```java\nspring:\n  activemq:\n    broker-url: tcp://localhost:61616\n  jms:\n    pub-sub-domain: true\n```\n\n pub-sub-domain默认值为false，即点对点模型，修改为true后就是发布订阅模型。\n\n**总结**\n\n1. springboot整合ActiveMQ提供了JmsMessagingTemplate对象作为客户端操作消息队列\n2. 操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口61616\n3. 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@JmsListener\n4. 配置jms的pub-sub-domain属性可以在点对点模型和发布订阅模型间切换消息模型\n\n##### SpringBoot整合RabbitMQ\n\n RabbitMQ是MQ产品中的目前较为流行的产品之一，它遵从AMQP协议。RabbitMQ的底层实现语言使用的是Erlang，所以安装RabbitMQ需要先安装Erlang。\n\n**Erlang安装**\n\n windows版安装包下载地址： [https](https://www.erlang.org/downloads) [😕/www.erlang.org/downloads](https://www.erlang.org/downloads)\n\n 下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕需要重启，需要重启，需要重启。\n\n 安装的过程中可能会出现依赖Windows组件的提示，根据提示下载安装即可，都是自动执行的，如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/8dadc4a2f3d73340eac36d722b75a8b9.png)\n\n Erlang安装后需要配置环境变量，否则RabbitMQ将无法找到安装的Erlang。需要配置项如下，作用等同JDK配置环境变量的作用。\n\n- ERLANG_HOME\n- PATH\n\n\n windows版安装包下载地址： [https://](https://rabbitmq.com/install-windows.html) [rabbitmq.com/install-windows.html](https://rabbitmq.com/install-windows.html)\n\n 下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕后会得到如下文件\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/10e7ae2007191f35acbb53dab9cb37c9.png)\n\n**启动服务器**\n\n```java\nrabbitmq-service.bat start\t\t# 启动服务\nrabbitmq-service.bat stop\t\t# 停止服务\nrabbitmqctl status\t\t\t\t# 查看服务状态\n```\n\n 运行sbin目录下的rabbitmq-service.bat命令即可，start参数表示启动，stop参数表示退出，默认对外服务端口5672。\n\n 注意：启动rabbitmq的过程实际上是开启rabbitmq对应的系统服务，需要管理员权限方可执行。\n\n 说明：有没有感觉5672的服务端口很熟悉？activemq与rabbitmq有一个端口冲突问题，学习阶段无论操作哪一个？请确保另一个处于关闭状态。\n\n 说明：不喜欢命令行的小伙伴可以使用任务管理器中的服务页，找到RabbitMQ服务，使用鼠标右键菜单控制服务的启停。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/bb9b1dad8d68e9b2c7ad4997f8255a68.png)\n\n**访问web管理服务**\n\n RabbitMQ也提供有web控制台服务，但是此功能是一个插件，需要先启用才可以使用。\n\n```java\nrabbitmq-plugins.bat list\t\t\t\t\t\t\t# 查看当前所有插件的运行状态\nrabbitmq-plugins.bat enable rabbitmq_management\t\t# 启动rabbitmq_management插件\n```\n\n 启动插件后可以在插件运行状态中查看是否运行，运行后通过浏览器即可打开服务后台管理界面\n\n```java\nhttp://localhost:15672\n```\n\n web管理服务默认端口15672，访问后可以打开RabbitMQ的管理界面，如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/75459869a3ffe9c5086bbe79fcec9006.png)\n\n 首先输入访问用户名和密码，初始化用户名和密码相同，均为：guest，成功登录后进入管理后台界面，如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/c5a233aeab70b2a8ef264961ea8b9a18.png)\n\n\n RabbitMQ满足AMQP协议，因此不同的消息模型对应的制作不同，先使用最简单的direct模型开发。\n\n**步骤①**：导入springboot整合amqp的starter，amqp协议默认实现为rabbitmq方案\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n**步骤②**：配置RabbitMQ的服务器地址\n\n```java\nspring:\n  rabbitmq:\n    host: localhost\n    port: 5672\n```\n\n**步骤③**：初始化直连模式系统设置\n\n 由于RabbitMQ不同模型要使用不同的交换机，因此需要先初始化RabbitMQ相关的对象，例如队列，交换机等\n\n```java\n@Configuration\npublic class RabbitConfigDirect {\n    @Bean\n    public Queue directQueue(){\n        return new Queue(\"direct_queue\");\n    }\n    @Bean\n    public Queue directQueue2(){\n        return new Queue(\"direct_queue2\");\n    }\n    @Bean\n    public DirectExchange directExchange(){\n        return new DirectExchange(\"directExchange\");\n    }\n    @Bean\n    public Binding bindingDirect(){\n        return BindingBuilder.bind(directQueue()).to(directExchange()).with(\"direct\");\n    }\n    @Bean\n    public Binding bindingDirect2(){\n        return BindingBuilder.bind(directQueue2()).to(directExchange()).with(\"direct2\");\n    }\n}\n```\n\n 队列Queue与直连交换机DirectExchange创建后，还需要绑定他们之间的关系Binding，这样就可以通过交换机操作对应队列。\n\n**步骤④**：使用AmqpTemplate操作RabbitMQ\n\n```java\n@Service\npublic class MessageServiceRabbitmqDirectImpl implements MessageService {\n    @Autowired\n    private AmqpTemplate amqpTemplate;\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println(\"待发送短信的订单已纳入处理队列（rabbitmq direct），id：\"+id);\n        amqpTemplate.convertAndSend(\"directExchange\",\"direct\",id);\n    }\n}\n```\n\n amqp协议中的操作API接口名称看上去和jms规范的操作API接口很相似，但是传递参数差异很大。\n\n**步骤⑤**：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n```java\n@Component\npublic class MessageListener {\n    @RabbitListener(queues = \"direct_queue\")\n    public void receive(String id){\n        System.out.println(\"已完成短信发送业务(rabbitmq direct)，id：\"+id);\n    }\n}\n```\n\n 使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。\n\n\n**步骤①**：同上\n\n**步骤②**：同上\n\n**步骤③**：初始化主题模式系统设置\n\n```java\n@Configuration\npublic class RabbitConfigTopic {\n    @Bean\n    public Queue topicQueue(){\n        return new Queue(\"topic_queue\");\n    }\n    @Bean\n    public Queue topicQueue2(){\n        return new Queue(\"topic_queue2\");\n    }\n    @Bean\n    public TopicExchange topicExchange(){\n        return new TopicExchange(\"topicExchange\");\n    }\n    @Bean\n    public Binding bindingTopic(){\n        return BindingBuilder.bind(topicQueue()).to(topicExchange()).with(\"topic.*.id\");\n    }\n    @Bean\n    public Binding bindingTopic2(){\n        return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(\"topic.orders.*\");\n    }\n}\n```\n\n 主题模式支持routingKey匹配模式，*表示匹配一个单词，#表示匹配任意内容，这样就可以通过主题交换机将消息分发到不同的队列中，详细内容请参看RabbitMQ系列课程。\n\n\n**步骤④**：使用AmqpTemplate操作RabbitMQ\n\n```java\n@Service\npublic class MessageServiceRabbitmqTopicImpl implements MessageService {\n    @Autowired\n    private AmqpTemplate amqpTemplate;\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println(\"待发送短信的订单已纳入处理队列（rabbitmq topic），id：\"+id);\n        amqpTemplate.convertAndSend(\"topicExchange\",\"topic.orders.id\",id);\n    }\n}\n```\n\n 发送消息后，根据当前提供的routingKey与绑定交换机时设定的routingKey进行匹配，规则匹配成功消息才会进入到对应的队列中。\n\n**步骤⑤**：使用消息监听器在服务器启动后，监听指定队列\n\n```java\n@Component\npublic class MessageListener {\n    @RabbitListener(queues = \"topic_queue\")\n    public void receive(String id){\n        System.out.println(\"已完成短信发送业务(rabbitmq topic 1)，id：\"+id);\n    }\n    @RabbitListener(queues = \"topic_queue2\")\n    public void receive2(String id){\n        System.out.println(\"已完成短信发送业务(rabbitmq topic 22222222)，id：\"+id);\n    }\n}\n```\n\n 使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。\n\n**总结**\n\n1. springboot整合RabbitMQ提供了AmqpTemplate对象作为客户端操作消息队列\n2. 操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口5672\n3. 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RabbitListener\n4. RabbitMQ有5种消息模型，使用的队列相同，但是交换机不同。交换机不同，对应的消息进入的策略也不同\n\n##### SpringBoot整合RocketMQ\n\n RocketMQ由阿里研发，后捐赠给apache基金会，目前是apache基金会顶级项目之一，也是目前市面上的MQ产品中较为流行的产品之一，它遵从AMQP协议。\n\n\n windows版安装包下载地址： [https://rocketmq.apache.org](https://rocketmq.apache.org/) [/](https://rocketmq.apache.org/)\n\n 下载完毕后得到zip压缩文件，解压缩即可使用，解压后得到如下文件\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/47f956f4aee0dd9c237197e7efcf4d03.png)\n\n RocketMQ安装后需要配置环境变量，具体如下：\n\n- ROCKETMQ_HOME\n- PATH\n- NAMESRV_ADDR （建议）： 127.0.0.1:9876\n\n 关于NAMESRV_ADDR对于初学者来说建议配置此项，也可以通过命令设置对应值，操作略显繁琐，建议配置。系统学习RocketMQ知识后即可灵活控制该项。\n\n**RocketMQ工作模式**\n\n 在RocketMQ中，处理业务的服务器称为broker，生产者与消费者不是直接与broker联系的，而是通过命名服务器进行通信。broker启动后会通知命名服务器自己已经上线，这样命名服务器中就保存有所有的broker信息。当生产者与消费者需要连接broker时，通过命名服务器找到对应的处理业务的broker，因此命名服务器在整套结构中起到一个信息中心的作用。并且broker启动前必须保障命名服务器先启动。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/b230379026ae17a5df2bc43f6fc3e3c6.png)\n\n**启动服务器**\n\n```java\nmqnamesrv\t\t# 启动命名服务器\nmqbroker\t\t# 启动broker\n```\n\n 运行bin目录下的mqnamesrv命令即可启动命名服务器，默认对外服务端口9876。\n\n 运行bin目录下的mqbroker命令即可启动broker服务器，如果环境变量中没有设置NAMESRV_ADDR则需要在运行mqbroker指令前通过set指令设置NAMESRV_ADDR的值，并且每次开启均需要设置此项。\n\n**测试服务器启动状态**\n\n RocketMQ提供有一套测试服务器功能的测试程序，运行bin目录下的tools命令即可使用。\n\n```java\ntools org.apache.rocketmq.example.quickstart.Producer\t\t# 生产消息\ntools org.apache.rocketmq.example.quickstart.Consumer\t\t# 消费消息\n```\n\n\n**步骤①**：导入springboot整合RocketMQ的starter，此坐标不由springboot维护版本\n\n```java\n<dependency>\n    <groupId>org.apache.rocketmq</groupId>\n    <artifactId>rocketmq-spring-boot-starter</artifactId>\n    <version>2.2.1</version>\n</dependency>\n```\n\n**步骤②**：配置RocketMQ的服务器地址\n\n```java\nrocketmq:\n  name-server: localhost:9876\n  producer:\n    group: group_rocketmq\n```\n\n 设置默认的生产者消费者所属组group。\n\n**步骤③**：使用RocketMQTemplate操作RocketMQ\n\n```java\n@Service\npublic class MessageServiceRocketmqImpl implements MessageService {\n    @Autowired\n    private RocketMQTemplate rocketMQTemplate;\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println(\"待发送短信的订单已纳入处理队列（rocketmq），id：\"+id);\n        SendCallback callback = new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                System.out.println(\"消息发送成功\");\n            }\n            @Override\n            public void onException(Throwable e) {\n                System.out.println(\"消息发送失败！！！！！\");\n            }\n        };\n        rocketMQTemplate.asyncSend(\"order_id\",id,callback);\n    }\n}\n```\n\n 使用asyncSend方法发送异步消息。\n\n**步骤④**：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n```java\n@Component\n@RocketMQMessageListener(topic = \"order_id\",consumerGroup = \"group_rocketmq\")\npublic class MessageListener implements RocketMQListener<String> {\n    @Override\n    public void onMessage(String id) {\n        System.out.println(\"已完成短信发送业务(rocketmq)，id：\"+id);\n    }\n}\n```\n\n RocketMQ的监听器必须按照标准格式开发，实现RocketMQListener接口，泛型为消息类型。\n\n 使用注解@RocketMQMessageListener定义当前类监听RabbitMQ中指定组、指定名称的消息队列。\n\n**总结**\n\n1. springboot整合RocketMQ使用RocketMQTemplate对象作为客户端操作消息队列\n2. 操作RocketMQ需要配置RocketMQ服务器地址，默认端口9876\n3. 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RocketMQMessageListener\n\n##### SpringBoot整合Kafka\n\n\n windows版安装包下载地址： [https://](https://kafka.apache.org/downloads) [kafka.apache.org/downloads](https://kafka.apache.org/downloads)\n\n 下载完毕后得到tgz压缩文件，使用解压缩软件解压缩即可使用，解压后得到如下文件\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/629a7ad582631aca11043609bbf30755.png)\n\n 建议使用windows版2.8.1版本。\n\n**启动服务器**\n\n kafka服务器的功能相当于RocketMQ中的broker，kafka运行还需要一个类似于命名服务器的服务。在kafka安装目录中自带一个类似于命名服务器的工具，叫做zookeeper，它的作用是注册中心，相关知识请到对应课程中学习。\n\n```java\nzookeeper-server-start.bat ..\\..\\config\\zookeeper.properties\t\t# 启动zookeeper\nkafka-server-start.bat ..\\..\\config\\server.properties\t\t\t\t# 启动kafka\n```\n\n 运行bin目录下的windows目录下的zookeeper-server-start命令即可启动注册中心，默认对外服务端口2181。\n\n 运行bin目录下的windows目录下的kafka-server-start命令即可启动kafka服务器，默认对外服务端口9092。\n\n**创建主题**\n\n 和之前操作其他MQ产品相似，kakfa也是基于主题操作，操作之前需要先初始化topic。\n\n```java\n# 创建topic\nkafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic itheima\n# 查询topic\nkafka-topics.bat --zookeeper 127.0.0.1:2181 --list\t\t\t\t\t\n# 删除topic\nkafka-topics.bat --delete --zookeeper localhost:2181 --topic itheima\n```\n\n**测试服务器启动状态**\n\n Kafka提供有一套测试服务器功能的测试程序，运行bin目录下的windows目录下的命令即可使用。\n\n```java\nkafka-console-producer.bat --broker-list localhost:9092 --topic itheima\t\t\t\t\t\t\t# 测试生产消息\nkafka-console-consumer.bat --bootstrap-server localhost:9092 --topic itheima --from-beginning\t# 测试消息消费\n```\n\n\n**步骤①**：导入springboot整合Kafka的starter，此坐标由springboot维护版本\n\n```java\n<dependency>\n    <groupId>org.springframework.kafka</groupId>\n    <artifactId>spring-kafka</artifactId>\n</dependency>\n```\n\n**步骤②**：配置Kafka的服务器地址\n\n```java\nspring:\n  kafka:\n    bootstrap-servers: localhost:9092\n    consumer:\n      group-id: order\n```\n\n 设置默认的生产者消费者所属组id。\n\n**步骤③**：使用KafkaTemplate操作Kafka\n\n```java\n@Service\npublic class MessageServiceKafkaImpl implements MessageService {\n    @Autowired\n    private KafkaTemplate<String,String> kafkaTemplate;\n\n    @Override\n    public void sendMessage(String id) {\n        System.out.println(\"待发送短信的订单已纳入处理队列（kafka），id：\"+id);\n        kafkaTemplate.send(\"itheima2022\",id);\n    }\n}\n```\n\n 使用send方法发送消息，需要传入topic名称。\n\n**步骤④**：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n\n```java\n@Component\npublic class MessageListener {\n    @KafkaListener(topics = \"itheima2022\")\n    public void onMessage(ConsumerRecord<String,String> record){\n        System.out.println(\"已完成短信发送业务(kafka)，id：\"+record.value());\n    }\n}\n```\n\n 使用注解@KafkaListener定义当前方法监听Kafka中指定topic的消息，接收到的消息封装在对象ConsumerRecord中，获取数据从ConsumerRecord对象中获取即可。\n\n**总结**\n\n1. \n springboot整合Kafka使用KafkaTemplate对象作为客户端操作消息队列\n2. \n 操作Kafka需要配置Kafka服务器地址，默认端口9092\n3. \n 企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@KafkaListener。接收消息保存在形参ConsumerRecord对象中\n\n### KF-6.监控\n\n 在说监控之前，需要回顾一下软件业的发展史。最早的软件完成一些非常简单的功能，代码不多，错误也少。随着软件功能的逐步完善，软件的功能变得越来越复杂，功能不能得到有效的保障，这个阶段出现了针对软件功能的检测，也就是软件测试。伴随着计算机操作系统的逐步升级，软件的运行状态也变得开始让人捉摸不透，出现了不稳定的状况。伴随着计算机网络的发展，程序也从单机状态切换成基于计算机网络的程序，应用于网络的程序开始出现，由于网络的不稳定性，程序的运行状态让使用者更加堪忧。互联网的出现彻底打破了软件的思维模式，随之而来的互联网软件就更加凸显出应对各种各样复杂的网络情况之下的弱小。计算机软件的运行状况已经成为了软件运行的一个大话题，针对软件的运行状况就出现了全新的思维，建立起了初代的软件运行状态监控。\n\n 什么是监控？就是通过软件的方式展示另一个软件的运行情况，运行的情况则通过各种各样的指标数据反馈给监控人员。例如网络是否顺畅、服务器是否在运行、程序的功能是否能够整百分百运行成功，内存是否够用，等等等等。\n\n 本章要讲解的监控就是对软件的运行情况进行监督，但是springboot程序与非springboot程序的差异还是很大的，为了方便监控软件的开发，springboot提供了一套功能接口，为开发者加速开发过程。\n\n#### KF-6-1.监控的意义\n\n 对于现代的互联网程序来说，规模越来越大，功能越来越复杂，还要追求更好的客户体验，因此要监控的信息量也就比较大了。由于现在的互联网程序大部分都是基于微服务的程序，一个程序的运行需要若干个服务来保障，因此第一个要监控的指标就是服务是否正常运行，也就是**监控服务状态是否处理宕机状态**。一旦发现某个服务宕机了，必须马上给出对应的解决方案，避免整体应用功能受影响。其次，由于互联网程序服务的客户量是巨大的，当客户的请求在短时间内集中达到服务器后，就会出现各种程序运行指标的波动。比如内存占用严重，请求无法及时响应处理等，这就是第二个要监控的重要指标，**监控服务运行指标**。虽然软件是对外提供用户的访问需求，完成对应功能的，但是后台的运行是否平稳，是否出现了不影响客户使用的功能隐患，这些也是要密切监控的，此时就需要在不停机的情况下，监控系统运行情况，日志是一个不错的手段。如果在众多日志中找到开发者或运维人员所关注的日志信息，简单快速有效的过滤出要看的日志也是监控系统需要考虑的问题，这就是第三个要监控的指标，**监控程序运行日志**。虽然我们期望程序一直平稳运行，但是由于突发情况的出现，例如服务器被攻击、服务器内存溢出等情况造成了服务器宕机，此时当前服务不能满足使用需要，就要将其重启甚至关闭，如果快速控制服务器的启停也是程序运行过程中不可回避的问题，这就是第四个监控项，**管理服务状态**。以上这些仅仅是从大的方面来思考监控这个问题，还有很多的细节点，例如上线了一个新功能，定时提醒用户续费，这种功能不是上线后马上就运行的，但是当前功能是否真的启动，如果快速的查询到这个功能已经开启，这也是监控中要解决的问题，等等。看来监控真的是一项非常重要的工作。\n\n 通过上述描述，可以看出监控很重要。那具体的监控要如何开展呢？还要从实际的程序运行角度出发。比如现在有3个服务支撑着一个程序的运行，每个服务都有自己的运行状态。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/e3b4ec43fdf099e35878fdd5d99054fd.png)\n\n 此时被监控的信息就要在三个不同的程序中去查询并展示，但是三个服务是服务于一个程序的运行的，如果不能合并到一个平台上展示，监控工作量巨大，而且信息对称性差，要不停的在三个监控端查看数据。如果将业务放大成30个，300个，3000个呢？看来必须有一个单独的平台，将多个被监控的服务对应的监控指标信息汇总在一起，这样更利于监控工作的开展。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/d6cb1292af31386aa6f29bf829b883da.png)\n\n 新的程序专门用来监控，新的问题就出现了，是被监控程序主动上报信息还是监控程序主动获取信息？如果监控程序不能主动获取信息，这就意味着监控程序有可能看到的是很久之前被监控程序上报的信息，万一被监控程序宕机了，监控程序就无法区分究竟是好久没法信息了，还是已经下线了。所以监控程序必须具有主动发起请求获取被监控服务信息的能力。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/9fa5d9e2678b99ccf1ea11746bfd7cee.png)\n\n 如果监控程序要监控服务时，主动获取对方的信息。那监控程序如何知道哪些程序被自己监控呢？不可能在监控程序中设置我监控谁，这样互联网上的所有程序岂不是都可以被监控到，这样的话信息安全将无法得到保障。合理的做法只能是在被监控程序启动时上报监控程序，告诉监控程序你可以监控我了。看来需要在被监控程序端做主动上报的操作，这就要求被监控程序中配置对应的监控程序是谁。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/6f65acab5a1cffcfeeacb12b1aa07ec1.png)\n\n 被监控程序可以提供各种各样的指标数据给监控程序看，但是每一个指标都代表着公司的机密信息，并不是所有的指标都可以给任何人看的，乃至运维人员，所以对被监控指标的是否开放出来给监控系统看，也需要做详细的设定。\n\n 以上描述的整个过程就是一个监控系统的基本流程。\n\n**总结**\n\n1. 监控是一个非常重要的工作，是保障程序正常运行的基础手段\n2. 监控的过程通过一个监控程序进行，它汇总所有被监控的程序的信息集中统一展示\n3. 被监控程序需要主动上报自己被监控，同时要设置哪些指标被监控\n\n**思考**\n\n 下面就要开始做监控了，新的问题就来了，监控程序怎么做呢？难道要自己写吗？肯定是不现实的，如何进行监控，咱们下节再讲。\n\n#### KF-6-2.可视化监控平台\n\n springboot抽取了大部分监控系统的常用指标，提出了监控的总思想。然后就有好心的同志根据监控的总思想，制作了一个通用性很强的监控系统，因为是基于springboot监控的核心思想制作的，所以这个程序被命名为**Spring Boot Admin**。\n\n Spring Boot Admin，这是一个开源社区项目，用于管理和监控SpringBoot应用程序。这个项目中包含有客户端和服务端两部分，而监控平台指的就是服务端。我们做的程序如果需要被监控，将我们做的程序制作成客户端，然后配置服务端地址后，服务端就可以通过HTTP请求的方式从客户端获取对应的信息，并通过UI界面展示对应信息。\n\n 下面就来开发这套监控程序，先制作服务端，其实服务端可以理解为是一个web程序，收到一些信息后展示这些信息。\n\n**服务端开发**\n\n**步骤①**：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程\n\n```java\n<dependency>\n    <groupId>de.codecentric</groupId>\n    <artifactId>spring-boot-admin-starter-server</artifactId>\n    <version>2.5.4</version>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n 上述过程可以通过创建项目时使用勾选的形式完成。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/d782c98a0fe92eb58d53547de62151a1.png)\n\n**步骤②**：在引导类上添加注解@EnableAdminServer，声明当前应用启动后作为SpringBootAdmin的服务器使用\n\n```java\n@SpringBootApplication\n@EnableAdminServer\npublic class Springboot25AdminServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot25AdminServerApplication.class, args);\n    }\n}\n```\n\n 做到这里，这个服务器就开发好了，启动后就可以访问当前程序了，界面如下。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/20bee05585bf243dc7d37926891061c0.png)\n\n 由于目前没有启动任何被监控的程序，所以里面什么信息都没有。下面制作一个被监控的客户端程序。\n\n**客户端开发**\n\n 客户端程序开发其实和服务端开发思路基本相似，多了一些配置而已。\n\n**步骤①**：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程\n\n```java\n<dependency>\n    <groupId>de.codecentric</groupId>\n    <artifactId>spring-boot-admin-starter-client</artifactId>\n    <version>2.5.4</version>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n 上述过程也可以通过创建项目时使用勾选的形式完成，不过一定要小心，端口配置成不一样的，否则会冲突。\n\n**步骤②**：设置当前客户端将信息上传到哪个服务器上，通过yml文件配置\n\n```java\nspring:\n  boot:\n    admin:\n      client:\n        url: http://localhost:8080\n```\n\n 做到这里，这个客户端就可以启动了。启动后再次访问服务端程序，界面如下。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/53d975c333cec3a8bf5da154452def6a.png)\n\n 可以看到，当前监控了1个程序，点击进去查看详细信息。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/22c6b324a0ac4cd5b838699c2e196535.png)\n\n 由于当前没有设置开放哪些信息给监控服务器，所以目前看不到什么有效的信息。下面需要做两组配置就可以看到信息了。\n\n1. \n 开放指定信息给服务器看\n2. \n 允许服务器以HTTP请求的方式获取对应的信息\n 配置如下：\n\n```java\nserver:\n  port: 80\nspring:\n  boot:\n    admin:\n      client:\n        url: http://localhost:8080\nmanagement:\n  endpoint:\n    health:\n      show-details: always\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n```\n\n 上述配置对于初学者来说比较容易混淆。简单解释一下，到下一节再做具体的讲解。springbootadmin的客户端默认开放了13组信息给服务器，但是这些信息除了一个之外，其他的信息都不让通过HTTP请求查看。所以你看到的信息基本上就没什么内容了，只能看到一个内容，就是下面的健康信息。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/8c7d7d56763b17f71888123b4aa94577.png)\n\n 但是即便如此我们看到健康信息中也没什么内容，原因在于健康信息中有一些信息描述了你当前应用使用了什么技术等信息，如果无脑的对外暴露功能会有安全隐患。通过配置就可以开放所有的健康信息明细查看了。\n\n```java\nmanagement:\n  endpoint:\n    health:\n      show-details: always\n```\n\n 健康明细信息如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/68543b37b36e1e289a7714da1ea4ca0b.png)\n\n 目前除了健康信息，其他信息都查阅不了。原因在于其他12种信息是默认不提供给服务器通过HTTP请求查阅的，所以需要开启查阅的内容项，使用*表示查阅全部。记得带引号。\n\n```java\nendpoints:\n  web:\n    exposure:\n      include: \"*\"\n```\n\n 配置后再刷新服务器页面，就可以看到所有的信息了。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/7006c4cf15f540d3f342c4da4a166cae.png)\n\n 以上界面中展示的信息量就非常大了，包含了13组信息，有性能指标监控，加载的bean列表，加载的系统属性，日志的显示控制等等。\n\n**配置多个客户端**\n\n 可以通过配置客户端的方式在其他的springboot程序中添加客户端坐标，这样当前服务器就可以监控多个客户端程序了。每个客户端展示不同的监控信息。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/0f416d2396883d31aa30bf55efcfac7d.png)\n\n 进入监控面板，如果你加载的应用具有功能，在监控面板中可以看到3组信息展示的与之前加载的空工程不一样。\n\n- 类加载面板中可以查阅到开发者自定义的类，如左图\n\n\n\n ![img](https://img-blog.csdnimg.cn/img_convert/9c7ed38401bfc2a80c68992baf4c046d.png)![img](https://img-blog.csdnimg.cn/img_convert/bc38a64673a682daa154c7c8932f2773.png)\n\n- 映射中可以查阅到当前应用配置的所有请求\n\n\n\n ![img](https://img-blog.csdnimg.cn/img_convert/106a9a7ce7782514150ef6b43de4791d.png)![img](https://img-blog.csdnimg.cn/img_convert/ab5d925f3ef776c6ba86209bf6cb0acc.png)\n\n- 性能指标中可以查阅当前应用独有的请求路径统计数据\n\n\n\n ![img](https://img-blog.csdnimg.cn/img_convert/17193726d49e81519e58e04f650fa23c.png)![img](https://img-blog.csdnimg.cn/img_convert/4b580b088c4510e8e52b228a583d71e3.png)\n\n**总结**\n\n1. 开发监控服务端需要导入坐标，然后在引导类上添加注解@EnableAdminServer，并将其配置成web程序即可\n2. 开发被监控的客户端需要导入坐标，然后配置服务端服务器地址，并做开放指标的设定即可\n3. 在监控平台中可以查阅到各种各样被监控的指标，前提是客户端开放了被监控的指标\n\n**思考**\n\n 之前说过，服务端要想监控客户端，需要主动的获取到对应信息并展示出来。但是目前我们并没有在客户端开发任何新的功能，但是服务端确可以获取监控信息，谁帮我们做的这些功能呢？咱们下一节再讲。\n\n#### KF-6-3.监控原理\n\n 通过查阅监控中的映射指标，可以看到当前系统中可以运行的所有请求路径，其中大部分路径以/actuator开头\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/74c582070b36bd876539947ca975c063.png)\n\n 首先这些请求路径不是开发者自己编写的，其次这个路径代表什么含义呢？既然这个路径可以访问，就可以通过浏览器发送该请求看看究竟可以得到什么信息。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/eb7198b30d3b7f9e954dd1738e4cfb0c.png)\n\n 通过发送请求，可以得到一组json信息，如下\n\n```java\n{\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:81/actuator\",\n            \"templated\": false\n        },\n        \"beans\": {\n            \"href\": \"http://localhost:81/actuator/beans\",\n            \"templated\": false\n        },\n        \"caches-cache\": {\n            \"href\": \"http://localhost:81/actuator/caches/{cache}\",\n            \"templated\": true\n        },\n        \"caches\": {\n            \"href\": \"http://localhost:81/actuator/caches\",\n            \"templated\": false\n        },\n        \"health\": {\n            \"href\": \"http://localhost:81/actuator/health\",\n            \"templated\": false\n        },\n        \"health-path\": {\n            \"href\": \"http://localhost:81/actuator/health/{*path}\",\n            \"templated\": true\n        },\n        \"info\": {\n            \"href\": \"http://localhost:81/actuator/info\",\n            \"templated\": false\n        },\n        \"conditions\": {\n            \"href\": \"http://localhost:81/actuator/conditions\",\n            \"templated\": false\n        },\n        \"shutdown\": {\n            \"href\": \"http://localhost:81/actuator/shutdown\",\n            \"templated\": false\n        },\n        \"configprops\": {\n            \"href\": \"http://localhost:81/actuator/configprops\",\n            \"templated\": false\n        },\n        \"configprops-prefix\": {\n            \"href\": \"http://localhost:81/actuator/configprops/{prefix}\",\n            \"templated\": true\n        },\n        \"env\": {\n            \"href\": \"http://localhost:81/actuator/env\",\n            \"templated\": false\n        },\n        \"env-toMatch\": {\n            \"href\": \"http://localhost:81/actuator/env/{toMatch}\",\n            \"templated\": true\n        },\n        \"loggers\": {\n            \"href\": \"http://localhost:81/actuator/loggers\",\n            \"templated\": false\n        },\n        \"loggers-name\": {\n            \"href\": \"http://localhost:81/actuator/loggers/{name}\",\n            \"templated\": true\n        },\n        \"heapdump\": {\n            \"href\": \"http://localhost:81/actuator/heapdump\",\n            \"templated\": false\n        },\n        \"threaddump\": {\n            \"href\": \"http://localhost:81/actuator/threaddump\",\n            \"templated\": false\n        },\n        \"metrics-requiredMetricName\": {\n            \"href\": \"http://localhost:81/actuator/metrics/{requiredMetricName}\",\n            \"templated\": true\n        },\n        \"metrics\": {\n            \"href\": \"http://localhost:81/actuator/metrics\",\n            \"templated\": false\n        },\n        \"scheduledtasks\": {\n            \"href\": \"http://localhost:81/actuator/scheduledtasks\",\n            \"templated\": false\n        },\n        \"mappings\": {\n            \"href\": \"http://localhost:81/actuator/mappings\",\n            \"templated\": false\n        }\n    }\n}\n```\n\n 其中每一组数据都有一个请求路径，而在这里请求路径中有之前看到过的health，发送此请求又得到了一组信息\n\n```java\n{\n    \"status\": \"UP\",\n    \"components\": {\n        \"diskSpace\": {\n            \"status\": \"UP\",\n            \"details\": {\n                \"total\": 297042808832,\n                \"free\": 72284409856,\n                \"threshold\": 10485760,\n                \"exists\": true\n            }\n        },\n        \"ping\": {\n            \"status\": \"UP\"\n        }\n    }\n}\n```\n\n 当前信息与监控面板中的数据存在着对应关系\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/a3ab875f11b6f1f7196c2708063cefb9.png)\n\n 原来监控中显示的信息实际上是通过发送请求后得到json数据，然后展示出来。按照上述操作，可以发送更多的以/actuator开头的链接地址，获取更多的数据，这些数据汇总到一起组成了监控平台显示的所有数据。\n\n 到这里我们得到了一个核心信息，监控平台中显示的信息实际上是通过对被监控的应用发送请求得到的。那这些请求谁开发的呢？打开被监控应用的pom文件，其中导入了springboot admin的对应的client，在这个资源中导入了一个名称叫做actuator的包。被监控的应用之所以可以对外提供上述请求路径，就是因为添加了这个包。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/a00df318816d5d9d9584d36ad755b5e6.png)\n\n 这个actuator是什么呢？这就是本节要讲的核心内容，监控的端点。\n\n Actuator，可以称为端点，描述了一组监控信息，SpringBootAdmin提供了多个内置端点，通过访问端点就可以获取对应的监控信息，也可以根据需要自定义端点信息。通过发送请求路劲**/actuator**可以访问应用所有端点信息，如果端点中还有明细信息可以发送请求**/actuator/端点名称**来获取详细信息。以下列出了所有端点信息说明：\n\n\n 上述端点每一项代表被监控的指标，如果对外开放则监控平台可以查询到对应的端点信息，如果未开放则无法查询对应的端点信息。通过配置可以设置端点是否对外开放功能。使用enable属性控制端点是否对外开放。其中health端点为默认端点，不能关闭。\n\n```java\nmanagement:\n  endpoint:\n    health:\t\t\t\t\t\t# 端点名称\n      show-details: always\n    info:\t\t\t\t\t\t# 端点名称\n      enabled: true\t\t\t\t# 是否开放\n```\n\n 为了方便开发者快速配置端点，springboot admin设置了13个较为常用的端点作为默认开放的端点，如果需要控制默认开放的端点的开放状态，可以通过配置设置，如下：\n\n```java\nmanagement:\n  endpoints:\n    enabled-by-default: true\t# 是否开启默认端点，默认值true\n```\n\n 上述端点开启后，就可以通过端点对应的路径查看对应的信息了。但是此时还不能通过HTTP请求查询此信息，还需要开启通过HTTP请求查询的端点名称，使用“*”可以简化配置成开放所有端点的WEB端HTTP请求权限。\n\n```java\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n```\n\n 整体上来说，对于端点的配置有两组信息，一组是endpoints开头的，对所有端点进行配置，一组是endpoint开头的，对具体端点进行配置。\n\n```java\nmanagement:\n  endpoint:\t\t# 具体端点的配置\n    health:\n      show-details: always\n    info:\n      enabled: true\n  endpoints:\t# 全部端点的配置\n    web:\n      exposure:\n        include: \"*\"\n    enabled-by-default: true\n```\n\n**总结**\n\n1. \n 被监控客户端通过添加actuator的坐标可以对外提供被访问的端点功能\n2. \n 端点功能的开放与关闭可以通过配置进行控制\n3. \n web端默认无法获取所有端点信息，通过配置开放端点功能\n\n#### KF-6-4.自定义监控指标\n\n 端点描述了被监控的信息，除了系统默认的指标，还可以自行添加显示的指标，下面就通过3种不同的端点的指标自定义方式来学习端点信息的二次开发。\n\n**INFO端点**\n\n info端点描述了当前应用的基本信息，可以通过两种形式快速配置info端点的信息\n\n- \n 配置形式\n 在yml文件中通过设置info节点的信息就可以快速配置端点信息\n info:\n  appName: @project.artifactId@\n  version: @project.version@\n  company: 传智教育\n  author: itheima\n 配置完毕后，对应信息显示在监控平台上\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/57cc7988cdddd0bc71bd645304c15ab8.png)\n\n也可以通过请求端点信息路径获取对应json信息\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/2c6f4583914feb4b236018ca3fbe7efa.png)\n\n- \n 编程形式\n 通过配置的形式只能添加固定的数据，如果需要动态数据还可以通过配置bean的方式为info端点添加信息，此信息与配置信息共存\n @Component\npublic class InfoConfig implements InfoContributor {\n    @Override\n    public void contribute(Info.Builder builder) {\n        builder.withDetail(\"runTime\",System.currentTimeMillis());\t\t//添加单个信息\n        Map infoMap = new HashMap();\t\t\n        infoMap.put(\"buildTime\",\"2006\");\n        builder.withDetails(infoMap);\t\t\t\t\t\t\t\t\t//添加一组信息\n    }\n}\n\n**Health端点**\n\n health端点描述当前应用的运行健康指标，即应用的运行是否成功。通过编程的形式可以扩展指标信息。\n\n```java\n@Component\npublic class HealthConfig extends AbstractHealthIndicator {\n    @Override\n    protected void doHealthCheck(Health.Builder builder) throws Exception {\n        boolean condition = true;\n        if(condition) {\n            builder.status(Status.UP);\t\t\t\t\t//设置运行状态为启动状态\n            builder.withDetail(\"runTime\", System.currentTimeMillis());\n            Map infoMap = new HashMap();\n            infoMap.put(\"buildTime\", \"2006\");\n            builder.withDetails(infoMap);\n        }else{\n            builder.status(Status.OUT_OF_SERVICE);\t\t//设置运行状态为不在服务状态\n            builder.withDetail(\"上线了吗？\",\"你做梦\");\n        }\n    }\n}\n```\n\n 当任意一个组件状态不为UP时，整体应用对外服务状态为非UP状态。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/5e1be6e6ae9c547b58001fd2fc44fde6.png)\n\n**Metrics端点**\n\n metrics端点描述了性能指标，除了系统自带的监控性能指标，还可以自定义性能指标。\n\n```java\n@Service\npublic class BookServiceImpl extends ServiceImpl<BookDao, Book> implements IBookService {\n    @Autowired\n    private BookDao bookDao;\n\n    private Counter counter;\n\n    public BookServiceImpl(MeterRegistry meterRegistry){\n        counter = meterRegistry.counter(\"用户付费操作次数：\");\n    }\n\n    @Override\n    public boolean delete(Integer id) {\n        //每次执行删除业务等同于执行了付费业务\n        counter.increment();\n        return bookDao.deleteById(id) > 0;\n    }\n}\n```\n\n 在性能指标中就出现了自定义的性能指标监控项\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/ffc108d6d81b276d966923449c57767a.png)\n\n**自定义端点**\n\n 可以根据业务需要自定义端点，方便业务监控\n\n```java\n@Component\n@Endpoint(id=\"pay\",enableByDefault = true)\npublic class PayEndpoint {\n    @ReadOperation\n    public Object getPay(){\n        Map payMap = new HashMap();\n        payMap.put(\"level 1\",\"300\");\n        payMap.put(\"level 2\",\"291\");\n        payMap.put(\"level 3\",\"666\");\n        return payMap;\n    }\n}\n```\n\n 由于此端点数据spirng boot admin无法预知该如何展示，所以通过界面无法看到此数据，通过HTTP请求路径可以获取到当前端点的信息，但是需要先开启当前端点对外功能，或者设置当前端点为默认开发的端点。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/4c0bbc2e3ff5d9ceecc2c811b2d712c0.png)\n\n**总结**\n\n1. 端点的指标可以自定义，但是每种不同的指标根据其功能不同，自定义方式不同\n2. info端点通过配置和编程的方式都可以添加端点指标\n3. health端点通过编程的方式添加端点指标，需要注意要为对应指标添加启动状态的逻辑设定\n4. metrics指标通过在业务中添加监控操作设置指标\n5. 可以自定义端点添加更多的指标\n\n### 开发实用篇完结\n\n 开发实用篇到这里就暂时完结了，在开发实用篇中我们讲解了大量的第三方技术的整合方案，选择的方案都是市面上比较流行的常用方案，还有一些国内流行度较低的方案目前还没讲，留到番外篇中慢慢讲吧。\n\n 整体开发实用篇中讲解的内容可以分为两大类知识：实用性知识与经验性知识。\n\n 实用性知识就是新知识了，springboot整合各种技术，每种技术整合中都有一些特殊操作，整体来说其实就是三句话。加坐标做配置调接口。经验性知识是对前面两篇中出现的一些知识的补充，在学习基础篇时如果将精力放在这些东西上就有点学偏了，容易钻牛角尖，放到实用开发篇中结合实际开发说一些不常见的但是对系统功能又危害的操作解决方案，提升理解。\n\n 开发实用篇做到这里就告一段落，下面就要着手准备原理篇了。市面上很多课程原理篇讲的过于高深莫测，在新手还没明白123的时候就开始讲微积分了，着实让人看了着急。至于原理篇我讲成什么样子？一起期待吧。\n\n","tags":["springboot","java","spring","spring boot"]},{"title":"springboot最全，最完整，最适合小白教程（运维实用篇）","url":"/2023/08/21/springboot最全，最完整，最适合小白教程（运维实用篇）/","content":"\n\n>本文章为黑马的springboot教程的教学文档，具体视频内容移步至bilibili 黑马程序员官方账号<br>\n 教程分为基础篇，运维实用篇，开发实用篇，原理篇\n\n基础篇： [springboot 基础篇](http://t.csdn.cn/yvD99)\n 运维实用篇 ： [springboot 运维实用篇](http://t.csdn.cn/7DPBB)\n 开发实用篇： [springboot 开发实用篇](http://t.csdn.cn/ZHmPq)\n 原理篇： [springboot 原理篇](http://t.csdn.cn/TMiLt)\n\n## SpringBoot运维实用篇\n\n 基础篇发布以后，看到了很多小伙伴在网上的留言，也帮助超过100位小伙伴解决了一些遇到的问题，并且已经发现了部分问题具有典型性，预计将有些问题在后面篇章的合适位置添加到本套课程中，作为解决方案提供给大家。\n\n 从此刻开始，咱们就要进入到实用篇的学习了。实用篇是在基础篇的根基之上，补全SpringBoot的知识图谱。比如在基础篇中只给大家讲了yaml的语法格式，但是具体写yaml文件的时候还有很多实用开发过程中的坑，这些在实用篇中都要进行学习。\n\n 实用篇共分为两块内容，分别是运维实用篇和开发实用篇。其实划分的标准是我自己制定的，因为这里面的知识有一些还是比较散的，做两个阶段的划分是为了更好的将同类知识点进行归类，帮助学习者找到知识之间的关联性，这样有助于知识的记忆存储转换，经过一系列的知识反复出现与强化练习，将临时记忆转换成永久性记忆。做课程嘛，不能仅以讲完为目标，要以学习者的学习收获为目标，这也是我这么多年教学秉承的基本理念。\n\n 下面就从运维实用篇开始讲，在运维实用篇中，我给学习者的定位是玩转配置，为开发实用篇中做各种技术的整合做好准备工作。与开发实用篇相比，运维实用篇的内容显得略微单薄，并且有部分知识模块在运维实用篇和开发实用篇中都要讲一部分，这些内容都后置到开发实用篇中了。废话不说了，先看看运维实用篇中都包含哪些内容：\n\n- SpringBoot程序的打包与运行\n- 配置高级\n- 多环境开发\n- 日志\n\n 下面开启第一部分SpringBoot程序打包与运行的学习\n\n### YW-1.SpringBoot程序的打包与运行\n\n 刚开始做开发学习的小伙伴可能在有一个知识上面有错误的认知，我们天天写程序是在Idea下写的，运行也是在Idea下运行的。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/776c3c87287373413342558f314a6ca9.png)\n\n 但是实际开发完成后，我们的项目是不可能运行在自己的电脑上的。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/c490804d3c1efd5661a795dac0b4a332.png)\n\n 我们以后制作的程序是运行在专用的服务器上的，简单说就是将你做的程序放在一台独立运行的电脑上，这台电脑要比你开发使用的计算机更专业，并且安全等级各个方面要远超过你现在的电脑。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/4cc84aa610bae69d8d28dd419a6af6f7.png)\n\n 那我们的程序如何放置在这台专用的电脑上呢，这就要将我们的程序先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。\n\n温馨提示\n\n 企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。\n\n1. 开发部门使用Git、SVN等版本控制工具上传工程到版本服务器\n2. 服务器使用版本控制工具下载工程\n3. 服务器上使用Maven工具在当前真机环境下重新构建项目\n4. 启动服务\n\n 继续说我们的打包和运行过程。所谓打包指将程序转换成一个可执行的文件，所谓运行指不依赖开发环境执行打包产生的文件。上述两个操作都有对应的命令可以快速执行。\n\n#### 程序打包\n\n SpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。本操作可以在Idea环境下执行。\n\n```java\nmvn package\n```\n\n 打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的。\n\n#### 程序运行\n\n 程序包打好以后，就可以直接执行了。在程序包所在路径下，执行指令。\n\n```java\njava -jar 工程包名.jar\n```\n\n 执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别。\n\n 特别关注：如果你的计算机中没有安装java的jdk环境，是无法正确执行上述操作的，因为程序执行使用的是java指令。\n\n 特别关注：在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。\n\n```java\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n\n**总结**\n\n1. SpringBoot工程可以基于java环境下独立运行jar文件启动服务\n2. SpringBoot工程执行mvn命令package进行打包\n3. 执行jar命令：java –jar 工程名.jar\n\n#### SpringBoot程序打包失败处理\n\n 有些小伙伴打包以后执行会出现一些问题，导致程序无法正常执行，例如下面的现象\n\n\n&lt;![img](https://img-blog.csdnimg.cn/img_convert/b005363c0c6aca3aaff2f4811dab8abf.png)\n\n 要想搞清楚这个问题就要说说.jar文件的工作机制了，知道了这个东西就知道如何避免此类问题的发生了。\n\n 搞java开发平时会接触很多jar包，比如mysql的驱动jar包，而上面我们打包程序后得到的也是一个jar文件。这个时候如果你使用上面的java -jar指令去执行mysql的驱动jar包就会出现上述不可执行的现象，而我们的SpringBoot项目为什么能执行呢？其实是因为打包方式不一样。\n\n 在SpringBoot工程的pom.xml中有下面这组配置，这组配置决定了打包出来的程序包是否可以执行。\n\n```java\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n\n 我们分别开启这段配置和注释掉这段配置分别执行两次打包，然后观察两次打包后的程序包的差别，共有3处比较明显的特征\n\n- 打包后文件的大小不同\n- 打包后所包含的内容不同\n- 打包程序中个别文件内容不同\n\n 先看第一个现象，文件大小不同。带有配置时打包生成的程序包大小如下：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/0a6119fb26a3d8c0b67bc7aa80cca9f1.png)\n\n 不难看出，带有配置的程序包体积比不带配置的大了30倍，那这里面都有什么呢？能差这么多？下面看看里面的内容有什么区别。\n\n\n\n ![img](https://img-blog.csdnimg.cn/img_convert/f47cea9d01acb9888174be7d9565b6ed.png)![img](https://img-blog.csdnimg.cn/img_convert/ca25ee0ab061b731c1cbba58a96a88db.png)\n\n 我们发现内容也完全不一样，仅有一个目录是一样的，叫做META-INF。打开容量大的程序包中的BOOT-INF目录下的classes目录，我们发现其中的内容居然和容量小的程序包中的内容完全一样。\n\n\n\n ![img](https://img-blog.csdnimg.cn/img_convert/7f51a53872a926b64d6b896337b6e2b5.png)![img](https://img-blog.csdnimg.cn/img_convert/aa67fe854572f616d8b5584eb440dedc.png)\n\n 原来大的程序包中除了包含小的程序包中的内容，还有别的东西。都有什么呢？回到BOOT-INF目录下，打开lib目录，里面显示了很多个jar文件。\n\n\n ![img](https://img-blog.csdnimg.cn/img_convert/47ee69ba35dc86fba5378fae2c6ffe4b.png)\n\n 仔细翻阅不难发现，这些jar文件都是我们制作这个工程时导入的坐标对应的文件。大概可以想明白了，SpringBoot程序为了让自己打包生成的程序可以独立运行，不仅将项目中自己开发的内容进行了打包，还把当前工程运行需要使用的jar包全部打包进来了。为什么这样做呢？就是为了可以独立运行。不依赖程序包外部的任何资源可以独立运行当前程序。这也是为什么大的程序包容量是小的程序包容量的30倍的主要原因。\n\n 再看看大程序包还有什么不同之处，在最外层目录包含一个org目录，进入此目录，目录名是org\\springframework\\boot\\loader，在里面可以找到一个JarLauncher.class的文件，先记得这个文件。再看这套目录名，明显是一个Spring的目录名，为什么要把Spring框架的东西打包到这个程序包中呢？不清楚。\n\n 回到两个程序包的最外层目录，查看名称相同的文件夹META-INF下都有一个叫做MANIFEST.MF的文件，但是大小不同，打开文件，比较内容区别\n\n- \n 小容量文件的MANIFEST.MF\n Manifest-Version: 1.0\nImplementation-Title: springboot_08_ssmp\nImplementation-Version: 0.0.1-SNAPSHOT\nBuild-Jdk-Spec: 1.8\nCreated-By: Maven Jar Plugin 3.2.0\n- \n 大容量文件的MANIFEST.MF\n Manifest-Version: 1.0\nSpring-Boot-Classpath-Index: BOOT-INF/classpath.idx\nImplementation-Title: springboot_08_ssmp\nImplementation-Version: 0.0.1-SNAPSHOT\nSpring-Boot-Layers-Index: BOOT-INF/layers.idx\nStart-Class: com.itheima.SSMPApplication\nSpring-Boot-Classes: BOOT-INF/classes/\nSpring-Boot-Lib: BOOT-INF/lib/\nBuild-Jdk-Spec: 1.8\nSpring-Boot-Version: 2.5.4\nCreated-By: Maven Jar Plugin 3.2.0\nMain-Class: org.springframework.boot.loader.JarLauncher\n\n 大文件中明显比小文件中多了几行信息，其中最后一行信息是Main-Class: org.springframework.boot.loader.JarLauncher。这句话什么意思呢？如果使用java -jar执行此程序包，将执行Main-Class属性配置的类，这个类恰巧就是前面看到的那个文件。原来SpringBoot打包程序中出现Spring框架的东西是为这里服务的。而这个org.springframework.boot.loader.JarLauncher类内部要查找Start-Class属性中配置的类，并执行对应的类。这个属性在当前配置中也存在，对应的就是我们的引导类类名。\n\n 现在这组设定的作用就搞清楚了\n\n1. SpringBoot程序添加配置后会打出一个特殊的包，包含Spring框架部分功能，原始工程内容，原始工程依赖的jar包\n2. 首先读取MANIFEST.MF文件中的Main-Class属性，用来标记执行java -jar命令后运行的类\n3. JarLauncher类执行时会找到Start-Class属性，也就是启动类类名\n4. 运行启动类时会运行当前工程的内容\n5. 运行当前工程时会使用依赖的jar包，从lib目录中查找\n\n 看来SpringBoot打出来了包为了能够独立运行，简直是煞费苦心，将所有需要使用的资源全部都添加到了这个包里。这就是为什么这个jar包能独立运行的原因。\n\n 再来看之前的报错信息：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/c3a0137bbea32c9cde2780436debd17f.png)\n\n 由于打包时没有使用那段配置，结果打包后形成了一个普通的jar包，在MANIFEST.MF文件中也就没有了Main-Class对应的属性了，所以运行时提示找不到主清单属性，这就是报错的原因。\n\n 上述内容搞清楚对我们编程意义并不大，但是对各位小伙伴理清楚SpringBoot工程独立运行的机制是有帮助的。其实整体过程主要是带着大家分析，如果以后遇到了类似的问题，多给自己提问，多问一个为什么，兴趣自己就可以独立解决问题了。\n\n**总结**\n\n1. spring-boot-maven-plugin插件用于将当前程序打包成一个可以独立运行的程序包\n\n#### 命令行启动常见问题及解决方案\n\n 各位小伙伴在DOS环境下启动SpringBoot工程时，可能会遇到端口占用的问题。给大家一组命令，不用深入学习，备用吧。\n\n```java\n# 查询端口\nnetstat -ano\n# 查询指定端口\nnetstat -ano |findstr \"端口号\"\n# 根据进程PID查询进程名称\ntasklist |findstr \"进程PID号\"\n# 根据PID杀死任务\ntaskkill /F /PID \"进程PID号\"\n# 根据进程名称杀死任务\ntaskkill -f -t -im \"进程名称\"\n```\n\n 关于打包与运行程序其实还有一系列的配置和参数，下面的内容中遇到再说，这里先开个头，知道如何打包和运行程序。\n\n#### SpringBoot项目快速启动（Linux版）\n\n 其实对于Linux系统下的程序运行与Windows系统下的程序运行差别不大，命令还是那组命令，只不过各位小伙伴可能对Linux指令不太熟悉，结果就会导致各种各样的问题发生。比如防火墙如何关闭，IP地址如何查询，JDK如何安装等等。这里不作为重点内容给大家普及了，了解一下整体过程就行了。\n\n### YW-2.配置高级\n\n 关于配置在基础篇讲过一部分，基础篇的配置总体上来说就是让各位小伙伴掌握配置的格式。比如配置文件如何写啊，写好的数据如何读取啊，都是基础的语法级知识。在实用篇中就要集中在配置的应用这个方面了，下面就开始配置高级相关内容的第一部分学习，为什么说第一部分，因为在开发实用篇中还有对应的配置高级知识要进行学习。\n\n#### YW-2-1.临时属性设置\n\n 目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。\n\n\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/66878f6bd4394e4d85e708cdd9a64333.png) ![img](https://img-blog.csdnimg.cn/img_convert/f760ce9044dcc1016bdce19a689b26b3.png) ![img](https://img-blog.csdnimg.cn/img_convert/4b9a0c3f932ae0424227cf69786da76d.png)\n\n SpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。\n\n```java\njava –jar springboot.jar –-server.port=80\n```\n\n 上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名=属性值的形式添加对应参数就可以了。记得，这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。\n\n 如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。\n\n```java\njava –jar springboot.jar –-server.port=80 --logging.level.root=debug\n```\n\n##### 属性加载优先级\n\n 现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。地址奉上： [https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html)\n\n\n&lt;![img](https://img-blog.csdnimg.cn/img_convert/e860d4fe32221044b76dcdd8f733f904.png)\n\n 我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。\n\n 比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。\n\n 我在课程评论区看到小伙伴学习基础篇的时候问这个问题了，就是这个原因造成的。在yaml中配置了user.name属性值，然后读取出来的时候居然不是自己的配置值，因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以SpringBoot最终会加载系统配置属性user.name。\n\n**总结**\n\n1. 使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性\n2. 临时属性添加方式：java –jar 工程名.jar –-属性名=值\n3. 多个临时属性之间使用空格分隔\n4. 临时属性必须是当前boot工程支持的属性，否则设置无效\n\n##### 开发环境中使用临时属性\n\n 临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。\n\n 打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/b13f6d158d90d3d0fddb608f3f608ada.png)\n\n 做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。\n\n```java\npublic static void main(String[] args) {\n}\n```\n\n 原来是这样，通过这个args就可以获取到参数。再来看我们的引导类是如何书写的\n\n```java\npublic static void main(String[] args) {\n    SpringApplication.run(SSMPApplication.class,args);\n}\n```\n\n 这个args参数居然传递给了run方法，看来在Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样外部临时属性就无法进入到SpringBoot程序中了。\n\n```java\npublic static void main(String[] args) {\n    SpringApplication.run(SSMPApplication.class);\n}\n```\n\n 或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。\n\n```java\npublic static void main(String[] args) {\n    String[] arg = new String[1];\n    arg[0] = \"--server.port=8082\";\n    SpringApplication.run(SSMPApplication.class, arg);\n}\n```\n\n**总结**\n\n1. 启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性\n\n**思考**\n\n 现在使用临时属性可以在启动项目前临时更改配置了，但是新的问题又出来了。临时属性好用是好用，就是写的多了会很麻烦。比如我现在有个需求，上线的时候使用临时属性配置20个值，这下可麻烦了，能不能搞得简单点，集中管理一下呢？比如说搞个文件，加载指定文件？还真可以。怎么做呢？咱们下一节再说。\n\n#### YW-2-2.配置文件分类\n\n SpringBoot提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这一节要说说配置文件了。其实这个配置文件我们一直在使用，只不过我们用的是SpringBoot提供的4级配置文件中的其中一个级别。4个级别分别是：\n\n- 类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）\n- 类路径下config目录下配置文件\n- 程序包所在目录中配置文件\n- 程序包所在目录中config目录下配置文件\n\n 好复杂，一个一个说。其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题。上面4个文件的加载优先顺序为\n\n1. file ：config/application.yml **【最高】**\n2. file ：application.yml\n3. classpath：config/application.yml\n4. classpath：application.yml **【最低】**\n\n 那为什么设计这种多种呢？说一个最典型的应用吧。\n\n- 场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。\n- 场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。\n- 场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？\n\n 解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？\n\n 级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。\n\n**总结**\n\n1. \n 配置文件分为4种\n <ul>\n  1. 项目类路径配置文件：服务于开发人员本机开发与测试\n  1. 项目类路径config目录中配置文件：服务于项目经理整体调控\n  1. 工程路径配置文件：服务于运维人员配置涉密线上环境\n  1. 工程路径config目录中配置文件：服务于运维经理整体调控\n </ul>\n6. \n 多层级配置文件间的属性采用叠加并覆盖的形式作用于程序\n\n#### YW-2-3.自定义配置文件\n\n 之前咱们做配置使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。\n\n 自定义配置文件方式有如下两种：\n\n**方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/971c417b4b1fd2a78ae9bf4c11a228ec.png)\n\n**方式二：使用临时属性设置配置文件路径，这个是全路径名**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/5235efc81436665329d650d5a5667e42.png)\n\n 也可以设置加载多个配置文件\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/c3625b2f63cb0f5f269d18c7996c7c43.png)\n\n 使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚。\n\n温馨提示\n\n 我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。这里不再说这些了，后面再讲这些东西。\n\n**总结**\n\n1. 配置文件可以修改名称，通过启动参数设定\n2. 配置文件可以修改路径，通过启动参数设定\n3. 微服务开发中配置文件通过配置中心进行设置\n\n### YW-3.多环境开发\n\n 讲的内容距离线上开发越来越近了，下面说一说多环境开发问题。\n\n 什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/0b4a27f997cec3b4c34bdd03f4f27d7d.png)\n\n#### YW-3-1.多环境开发（yaml单一文件版）\n\n 那什么是多环境开发？就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：\n\n```java\nserver:\n  port: 80\n```\n\n 如何想设计两组环境呢？中间使用三个减号分隔开\n\n```java\nserver:\n  port: 80\n---\nserver:\n  port: 81\n```\n\n 如何区分两种环境呢？起名字呗\n\n```java\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n```\n\n 那用哪一个呢？设置默认启动哪个就可以了\n\n```java\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 启动pro\n---\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n```\n\n 就这么简单，再多来一组环境也OK\n\n```java\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 启动pro\n---\nspring:\n\tprofiles: pro\nserver:\n\tport: 80\n---\nspring:\n\tprofiles: dev\nserver:\n\tport: 81\n---\nspring:\n\tprofiles: test\nserver:\n\tport: 82\n```\n\n 其中关于环境名称定义上述格式是过时格式，标准格式如下\n\n```java\nspring:\n\tconfig:\n    \tactivate:\n        \ton-profile: pro\n```\n\n**总结**\n\n1. 多环境开发需要设置若干种常用环境，例如开发、生产、测试环境\n2. yaml格式中设置多环境使用—区分环境设置边界\n3. 每种环境的区别在于加载的配置属性不同\n4. 启用某种环境时需要指定启动时使用该环境\n\n#### YW-3-2.多环境开发（yaml多文件版）\n\n 将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。\n\n**主配置文件**\n\n```java\nspring:\n\tprofiles:\n\t\tactive: pro\t\t# 启动pro\n```\n\n**环境配置文件**\n\n```java\nserver:\n\tport: 80\n```\n\n 环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。\n\n**application-pro.yaml**\n\n```java\nserver:\n\tport: 80\n```\n\n**application-dev.yaml**\n\n```java\nserver:\n\tport: 81\n```\n\n 文件的命名规则为：application-环境名.yml。\n\n 在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。\n\n- 主配置文件中设置公共配置（全局）\n- 环境分类配置文件中常用于设置冲突属性（局部）\n\n**总结**\n\n1. \n 可以使用独立配置文件定义环境属性\n2. \n 独立配置文件便于线上系统维护更新并保障系统安全性\n\n#### YW-3-3.多环境开发（properties多文件版）\n\n SpringBoot最早期提供的配置文件格式是properties格式的，这种格式的多环境配置也了解一下吧。\n\n**主配置文件**\n\n```java\nspring.profiles.active=pro\n```\n\n**环境配置文件**\n\n**application-pro.properties**\n\n```java\nserver.port=80\n```\n\n**application-dev.properties**\n\n```java\nserver.port=81\n```\n\n 文件的命名规则为：application-环境名.properties。\n\n**总结**\n\n1. properties文件多环境配置仅支持多文件格式\n\n#### YW-3-4.多环境开发独立配置文件书写技巧\n\n 作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。\n\n**准备工作**\n\n 将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下\n\n- application-devDB.yml\n- application-devRedis.yml\n- application-devMVC.yml\n\n**使用**\n\n 使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔\n\n```java\nspring:\n\tprofiles:\n    \tactive: dev\n        include: devDB,devRedis,devMVC\n```\n\n 比较一下，现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么\n\n**注意**\n\n 当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效\n\n**改良**\n\n 但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦了。SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。\n\n```java\nspring:\n\tprofiles:\n    \tactive: dev\n        group:\n        \t\"dev\": devDB,devRedis,devMVC\n      \t\t\"pro\": proDB,proRedis,proMVC\n      \t\t\"test\": testDB,testRedis,testMVC\n```\n\n 现在再来看，如果切换dev到pro，只需要改一下是不是就结束了？完美！\n\n**总结**\n\n1. 多环境开发使用group属性设置配置文件分组，便于线上维护管理\n\n#### YW-3-5.多环境开发控制\n\n 多环境开发到这里基本上说完了，最后说一个冲突问题。就是maven和SpringBoot同时设置多环境的话怎么搞。\n\n 要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。\n\n maven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。整个确认后下面就好做了。大体思想如下：\n\n- 先在maven环境中设置用什么具体的环境\n- 在SpringBoot中读取maven设置的环境即可\n\n**maven中设置多环境（使用属性方式区分环境）**\n\n```java\n<profiles>\n    <profile>\n        <id>env_dev</id>\n        <properties>\n            <profile.active>dev</profile.active>\n        </properties>\n        <activation>\n            <activeByDefault>true</activeByDefault>\t\t<!--默认启动环境-->\n        </activation>\n    </profile>\n    <profile>\n        <id>env_pro</id>\n        <properties>\n            <profile.active>pro</profile.active>\n        </properties>\n    </profile>\n</profiles>\n```\n\n**SpringBoot中读取maven设置值**\n\n```java\nspring:\n\tprofiles:\n    \tactive: @profile.active@\n```\n\n 上面的@属性名@就是读取maven中配置的属性值的语法格式。\n\n**总结**\n\n1. 当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@…@占位符读取Maven对应的配置属性值\n2. 基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效\n\n### YW-4.日志\n\n 运维篇最后一部分我们来聊聊日志，日志大家不陌生，简单介绍一下。日志其实就是记录程序日常运行的信息，主要作用如下：\n\n- 编程期调试代码\n- 运营期记录信息\n- 记录日常运营重要信息（峰值流量、平均响应时长……）\n- 记录应用报错信息（错误堆栈）\n- 记录运维过程数据（扩容、宕机、报警……）\n\n 或许各位小伙伴并不习惯于使用日志，没关系，慢慢多用，习惯就好。想进大厂，这是最基本的，别去面试的时候说没用过，完了，没机会了。\n\n##### YW-4-1.代码中使用日志工具记录日志\n\n 日志的使用格式非常固定，直接上操作步骤：\n\n**步骤①**：添加日志记录操作\n\n```java\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController extends BaseClass{\n    private static final Logger log = LoggerFactory.getLogger(BookController.class);\n    @GetMapping\n    public String getById(){\n        log.debug(\"debug...\");\n        log.info(\"info...\");\n        log.warn(\"warn...\");\n        log.error(\"error...\");\n        return \"springboot is running...2\";\n    }\n}\n```\n\n 上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API了。\n\n**步骤②**：设置日志输出级别\n\n 日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是：\n\n- TRACE：运行堆栈信息，使用率低\n- DEBUG：程序员调试代码使用\n- INFO：记录运维过程数据\n- WARN：记录运维过程报警数据\n- ERROR：记录错误堆栈信息\n- FATAL：灾难信息，合并计入ERROR\n\n 一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。下面就设置一下日志级别：\n\n```java\n# 开启debug模式，输出调试信息，常用于检查系统运行状况\ndebug: true\n```\n\n 这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制\n\n```java\n# 开启debug模式，输出调试信息，常用于检查系统运行状况\ndebug: true\n\n# 设置日志级别，root表示根节点，即整体应用日志级别\nlogging:\n\tlevel:\n    \troot: debug\n```\n\n 还可以再设置更细粒度的控制\n\n**步骤③**：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别\n\n```java\nlogging:\n\t# 设置日志组\n    group:\n    \t# 自定义组名，设置当前组中所包含的包\n        ebank: com.itheima.controller\n    level:\n    \troot: warn\n        # 为对应组设置日志级别\n        ebank: debug\n    \t# 为对包设置日志级别\n        com.itheima.controller: debug\n```\n\n 说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。\n\n**总结**\n\n1. 日志用于记录开发调试与运维过程消息\n2. 日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO,WARN,ERROR\n3. 可以通过日志组或代码包的形式进行日志显示级别的控制\n\n##### 教你一招：优化日志对象创建代码\n\n 写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的lombok技术给我们提供的工具类即可。\n\n```java\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController extends BaseClass{\n    private static final Logger log = LoggerFactory.getLogger(BookController.class);\t//这一句可以不写了\n}\n```\n\n 导入lombok后使用注解搞定，日志对象名为log\n\n```java\n@Slf4j\t\t//这个注解替代了下面那一行\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController extends BaseClass{\n    private static final Logger log = LoggerFactory.getLogger(BookController.class);\t//这一句可以不写了\n}\n```\n\n**总结**\n\n1. 基于lombok提供的@Slf4j注解为类快速添加日志对象\n\n##### YW-4-2.日志输出格式控制\n\n 日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/c9a132c83021f19f1d3c62abe6ba495a.png)\n\n 对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID与线程名用于做精准分析。了解这些信息后就可以DIY日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。\n\n```java\nlogging:\n\tpattern:\n    \tconsole: \"%d %clr(%p) --- [%16t] %clr(%-40.40c){cyan} : %m %n\"\n```\n\n**总结**\n\n1. 日志输出格式设置规则\n\n##### YW-4-3.日志文件\n\n 日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。\n\n 对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。这里主要研究日志文件如何记录。\n\n 记录日志到文件中格式非常简单，设置日志文件名即可。\n\n```java\nlogging:\n\tfile:\n    \tname: server.log\n```\n\n 虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：\n\n```java\nlogging:\n\tlogback:\n    \trollingpolicy:\n        \tmax-file-size: 3KB\n            file-name-pattern: server.%d{yyyy-MM-dd}.%i.log\n```\n\n 以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3KB以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。\n\n**总结**\n\n1. 日志记录到文件\n2. 日志文件格式设置\n\n### 运维实用篇完结\n\n 运维实用篇到这里就要先告一段落了，为什么不说结束呢？因为运维篇中还有一些知识，但是现在讲解过于分散了。所以要把这些知识与开发实用篇的知识结合在一起讲，也是本课程的教学设计的体现。\n\n 在整体运维实用篇中带着大家学习了4块内容，首先学习了如何运行SpringBoot程序，也就是程序的打包与运行，接下来对配置进行了升级学习，不再局限在配置文件中进行设置，通过临时属性，外部配置文件对项目的配置进行管控。在多环境开发中给大家介绍了多种多环境开发的格式，其实掌握一种即可，此外还给大家讲了多环境开发的一些技巧以及与maven的冲突解决方案。最后给大家介绍了日志系统，老实说日志这里讲的相当的潦草，因为大部分日志相关的知识都不应该在这门课中学习，这里只是告诉大家如何整合实用而已。\n\n 看了各位小伙伴的评论，知道你们再催更，我也在加油，一起努力吧，实用开发篇再会。实用开发篇会提高更新频度，不全部做完给大家更新了，我先把做好的一部分开放出来，随后做完一点就更新一点，额，好吧，就说到这里吧。\n\n","tags":["springboot","java","spring","运维","spring boot","后端"]},{"title":"springboot最全，最完整，最适合小白教程（基础篇）","url":"/2023/08/21/springboot最全，最完整，最适合小白教程（基础篇）/","content":"\n\n>本文章为黑马的springboot教程的教学文档，具体视频内容移步至bilibili 黑马程序员官方账号<br>\n 教程分为基础篇，运维实用篇，开发实用篇，原理篇\n\n基础篇： [springboot 基础篇](http://t.csdn.cn/yvD99)\n 运维实用篇 ： [springboot 运维实用篇](http://t.csdn.cn/7DPBB)\n 开发实用篇： [springboot 开发实用篇](http://t.csdn.cn/ZHmPq)\n 原理篇： [springboot 原理篇](http://t.csdn.cn/TMiLt)\n\n## SpringBoot\n\n#### 文档更新日志\n\n\n#### 前言\n\n 很荣幸有机会能以这样的形式和互联网上的各位小伙伴一起学习交流技术课程，这次给大家带来的是Spring家族中比较重要的一门技术课程——SpringBoot。一句话介绍这个技术，应该怎么说呢？现在如果开发Spring程序不用SpringBoot那就是给自己过不去，SpringBoot为我们开发Spring程序提供了太多的帮助，在此借这个机会给大家分享这门课程，希望各位小伙伴学有所得，学有所用，学有所成。\n\n 正如上面提到的，这门技术是用来加速开发Spring程序的，因此学习这门技术是有一定的门槛的。你可以理解为你现在是一门传统的手工艺人，现在工艺升级，可以加速你的生产制作过程，但是前提是你要会原始工艺，然后才能学习新的工艺。嗯，怎么说呢？有一定的门槛，至少Spring怎么回事，与Spring配合在一起工作的一堆技术又是怎么回事，这些搞明白才能来看这个技术，不然就只能学个皮毛，或者学着学着就开始因为其他技术不太过关，然后就学不下去了，然后，就没有然后了，果断弃坑了。不管怎么说，既来之则安之，加油学习吧，投资自己肯定是没毛病的。\n\n#### 课程内容说明\n\n SpringBoot这门技术课程所包含的技术点其实并不是很多，但是围绕着SpringBoot的周边知识，也就是SpringBoot整合其他技术，这样的知识量很大，例如SpringBoot整合MyBatis等等。因此为了能够将本课程制作的能够适应于各个层面的学习者进行学习，本套课程会针对小白，初学者，开发者三种不同的人群来设计全套课程。具体这三种人群如何划分，就按照我的描述形式来分吧，各位小伙伴可以对号入座，每种人群看课程的起始位置略有差别。\n\n\n 简单说就是你能用SpringBoot做多少东西，一点不会就是小白，会一点就是初学者，大部分都会就是开发者。其实这个划分也不用过于纠结，这个划分仅仅是为了帮助你对本技术课程所包含的阶段模块划分做一个清晰认知，因为本课程中会将SpringBoot技术划分成4个单元，每个单元是针对不同的学习者准备的。\n\n\n 看完这个划分你就应该有这么个概念，我没有用过SpringBoot技术，所以从基础篇开始学习；或者我会一点SpringBoot技术，那我从实用篇开始学就好了，就是这个意思。\n\n 每个课程单元内容设置不同，目标也不一样，作为学习者如果想达成最佳的学习效果，最好明确自己的学习目标再进行学习，这样目标明确，学习的时候能够更轻松，你就不会在学习的时候纠结如下的问题了。比如学着基础篇在那想，这个东西是个什么原理啊？这个东西是这么用的，那个东西该怎么用啊？因为原理性的内容统一放置到了原理篇讲解了，应用相关的内容统一放到应用篇里面讲解，你在基础篇阶段纠结也没有用，这一部分不讲这些知识，在基础篇先把SpringBoot的基础使用掌握完再说后面的知识吧。\n\n 此外还有一点需要说明的是，目前SpringBoot技术发展速度很快，更新速度也很快，因此后续还会对本套课程进行持续更新，特此在三个课程单元的基础上追加一个**番外篇**。番外篇的设置为了解决如下问题：\n\n- 持续更新SpringBoot后续发展出现的新技术\n- 讲解部分知识点规模较大的支线知识（例如WebFlux）\n- 扩展非实用性知识，扩展学习者视野\n\n 每一个课程单元的学习目标如下，请各位查收，在学习的过程中可以阶段性的给自己提个问题，下面列出来的这些学习目标你是否达成了，可以检验你的学习成果。\n\n\n 整体课程包含的内容就是这些啦，要想完成前面这些内容的学习，顺利的达成学习目标，有些东西还是要提前和大家说清楚的。SpringBoot课程不像是Java基础，不管你有没有基础，都可以听一听，这个课程还真不行，需要一定的前置知识。下面给大家列表一些前置知识，如果还有不太会的，需要想办法快速补救一下。\n\n#### 课程前置知识说明\n\n\n 看着略微有点多，其实还好吧，如果个别技术真的不会，在学习课程的时候多用心听就好，基础篇是可以跟着学下来了，后面的实用篇和原理篇就比较难了。比如我要在Linux系统下操作，命令我就直接使用了，然后你看不懂可能学习起来就比较心累了。\n\n 课程安排就说到这里了，下面进入到SpringBoot基础篇的学习\n\n## SpringBoot基础篇\n\n 在基础篇中，我给学习者的定位是先上手，能够使用SpringBoot搭建基于SpringBoot的web项目开发，所以内容设置较少，主要包含如下内容：\n\n- SpringBoot快速入门\n- SpringBoot基础配置\n- 基于SpringBoot整合SSMP\n\n### JC-1.快速上手SpringBoot\n\n 学习任意一项技术，首先要知道这个技术的作用是什么，不然学完以后，你都不知道什么时候使用这个技术，也就是技术对应的应用场景。SpringBoot技术由Pivotal团队研发制作，功能的话简单概括就是加速Spring程序的开发，这个加速要从如下两个方面来说\n\n- Spring程序初始搭建过程\n- Spring程序的开发过程\n\n 通过上面两个方面的定位，我们可以产生两个模糊的概念：\n\n1. SpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件/配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子\n2. SpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？\n\n 带着上面这些疑问我们就着手第一个SpringBoot程序的开发了，看看到底使用SpringBoot技术能简化开发到什么程度。\n\n温馨提示\n\n 如果对Spring程序的基础开发不太懂的小伙伴，看到这里可以弃坑了，下面的内容学习需要具备Spring技术的知识，硬着头皮学不下去的。\n\n#### JC-1-1.SpringBoot入门程序制作（一）\n\n 下面让我们开始做第一个SpringBoot程序吧，本课程基于Idea2020.3版本制作，使用的Maven版本为3.6.1，JDK版本为1.8。如果你的环境和上述环境不同，可能在操作界面和操作过程中略有不同，只要软件匹配兼容即可（说到这个Idea和Maven，它们两个还真不是什么版本都能搭到一起的，说多了都是泪啊）。\n\n 下面使用SpringBoot技术快速构建一个SpringMVC的程序，通过这个过程体会简化二字的含义。\n\n**步骤①**：创建新模块，选择Spring Initializr，并配置模块相关基础信息\n\n 特别关注：第3步点击Next时，Idea需要联网状态才可以进入到后面那一页，如果不能正常联网，就无法正确到达右面那个设置页了，会一直联网转转转。\n\n 特别关注：第5步选择java版本和你计算机上安装的JDK版本匹配即可，但是最低要求为JDK8或以上版本，推荐使用8或11。\n\n**步骤②**：选择当前模块需要使用的技术集\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/86cc9240533c791dfc299ba3dbb3b53d.png)\n\n 按照要求，左侧选择web，然后在中间选择Spring Web即可，选完右侧就出现了新的内容项，这就表示勾选成功了。\n\n 关注：此处选择的SpringBoot的版本使用默认的就可以了，需要说一点，SpringBoot的版本升级速度很快，可能昨天创建工程的时候默认版本是2.5.4，今天再创建工程默认版本就变成2.5.5了，差别不大，无需过于纠结，并且还可以到配置文件中修改对应的版本。\n\n**步骤③**：开发控制器类\n\n```java\n//Rest模式\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController {\n    @GetMapping\n    public String getById(){\n        System.out.println(\"springboot is running...\");\n        return \"springboot is running...\";\n    }\n}\n```\n\n 入门案例制作的SpringMVC的控制器基于Rest风格开发，当然此处使用原始格式制作SpringMVC的程序也是没有问题的，上例中的@RestController与@GetMapping注解是基于Restful开发的典型注解。\n\n 关注：做到这里SpringBoot程序的最基础的开发已经做完了，现在就可以正常的运行Spring程序了。可能有些小伙伴会有疑惑，Tomcat服务器没有配置，Spring也没有配置，什么都没有配置这就能用吗？这就是SpringBoot技术的强大之处。关于内部工作流程后面再说，先专心学习开发过程。\n\n**步骤④**：运行自动生成的Application类\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/0307de085d90ce7ef3fee1a3e9e4759c.png)\n\n 使用带main方法的java程序的运行形式来运行程序，运行完毕后，控制台输出上述信息。\n\n 不难看出，运行的信息中包含了8080的端口，Tomcat这种熟悉的字样，难道这里启动了Tomcat服务器？是的，这里已经启动了。那服务器没有配置，哪里来的呢？后面再说。现在你就可以通过浏览器访问请求的路径，测试功能是否工作正常了。\n\n```java\n访问路径：\thttp://localhost:8080/books\n```\n\n 是不是感觉很神奇？当前效果其实依赖的底层逻辑还是很复杂的，但是从开发者角度来看，目前只有两个文件展现到了开发者面前。\n\n- \n pom.xml\n 这是maven的配置文件，描述了当前工程构建时相应的配置信息。\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.4</version>\n    </parent>\n\n    <groupId>com.itheima</groupId>\n    <artifactId>springboot_01_01_quickstart</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n 配置中有两个信息需要关注，一个是parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说。\n- \n Application类\n @SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n 这个类功能很简单，就一句代码，前面运行程序就是运行的这个类。\n\n 到这里我们可以大胆推测一下，如果上面这两个文件没有的话，SpringBoot肯定没法玩，看来核心就是这两个文件了。由于是制作第一个SpringBoot程序，先不要关注这两个文件的功能，后面详细讲解内部工作流程。\n\n 通过上面的制作，我们不难发现，SpringBoot程序简直太好写了，几乎什么都没写，功能就有了，这也是SpringBoot技术为什么现在这么火的原因，和Spring程序相比，SpringBoot程序在开发的过程中各个层面均具有优势。\n\n\n 一句话总结一下就是能少写就少写，能不写就不写，这就是SpringBoot技术给我们带来的好处，行了，现在你就可以动手做一做SpringBoot程序了，看看效果如何，是否真的帮助你简化开发了。\n\n**总结**\n\n1. 开发SpringBoot程序在Idea工具中基于联网的前提下可以根据向导快速制作\n2. SpringBoot程序需要依赖JDK，版本要求最低为JDK8\n3. SpringBoot程序中需要使用某种功能时可以通过勾选的形式选择技术，也可以手工添加对应的要使用的技术（后期讲解）\n4. 运行SpringBoot程序通过运行Application程序进行\n\n**思考**\n\n 前面制作的时候说过，这个过程必须联网才可以进行，但是有些时候你会遇到一些莫名其妙的问题，比如基于Idea开发时，你会发现你配置了一些坐标，然后Maven下载对应东西的时候死慢死慢的，甚至还会失败。其实这种现象和Idea这款IDE工具有关，万一Idea不能正常访问网络的话，我们是不是就无法制作SpringBoot程序了呢？咱们下一节再说。\n\n#### JC-1-2.SpringBoot入门程序制作（二）\n\n 如果Idea不能正常联网，这个SpringBoot程序就无法制作了吗？开什么玩笑，世上IDE工具千千万，难道SpringBoot技术还必须基于Idea来做了？这是不可能的。开发SpringBoot程序可以不基于IDE工具进行，在SpringBoot官网中可以直接创建SpringBoot程序。\n\n SpringBoot官网和Spring的官网是在一起的，都是 spring.io 。你可以通过项目一级一级的找到SpringBoot技术的介绍页，然后在页面中间部位找到如下内容\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/42e8f6b09edc49ed6876ad18caa8a880.png#pic_center)\n\n**步骤①**：点击**Spring Initializr**后进入到创建SpringBoot程序界面，接下来就是输入信息的过程，和在Idea中制作是一样的，只是界面发生了变化，根据自己的要求，在左侧选择对应信息和输入对应的信息。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/0ebc17570a93de7ab18ecb7cded76a48.png#pic_center)\n\n\n**步骤②**：右侧的**ADD DEPENDENCIES**用于选择使用何种技术，和之前勾选的Spring WEB是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面。![img](https://img-blog.csdnimg.cn/img_convert/e09ce4de52124d983856d34620d3363e.png#pic_center)\n\n**步骤③**：所有信息设置完毕后，点击下面左侧**GENERATE**按钮，生成一个文件包。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/2c6df2a40e751a6f812bec6704d94793.png)\n\n**步骤④**：保存后得到一个压缩文件，这个文件就是创建的SpringBoot工程\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/0756cd96ccdd8bb703bfa529701e240f.png)\n\n**步骤⑤**：解压缩此文件得到工程目录，在Idea中导入即可直接使用，和之前在Idea环境下根据向导创建的工程完全一样，你可以创建一个Controller测试一下当前工程是否可用。\n\n温馨提示\n\n 做到这里其实可以透漏一个小秘密，Idea工具中创建SpringBoot工程其实连接的就是SpringBoot的官网，还句话说这种方式和第一种方式是一模一样的，只不过Idea把界面给整合了一下，读取Spring官网信息，然后展示到Idea界面中而已，可以通过如下信息比对一下\n\n\n**Idea中创建工程时默认选项**![img](https://img-blog.csdnimg.cn/img_convert/7f2c60d20b6ab4603ecfe60fd6c9a352.png#pic_center)\n\n**SpringBoot官网创建工程时对应的地址**\n\n\n 看看SpringBoot官网创建工程的URL地址，是不是和Idea中使用的URL地址是一样的？![img](https://img-blog.csdnimg.cn/img_convert/f9d8f6c05e97ae644236cb28e16388af.png#pic_center)\n\n**总结**\n\n1. \n 打开SpringBoot官网，选择Quickstart Your Project中的Spring Initializr。\n2. \n 创建工程。\n3. \n 保存项目文件。\n\n4. \n 解压项目，通过IDE导入项目后进行编辑使用。\n\n**思考**\n\n 现在创建工程靠的是访问国外的Spring主站，但是互联网信息的访问是可以被约束的，如果一天这个网站你在国内无法访问了，那前面这两种方式就无法创建SpringBoot工程了，这时候又该怎么解决这个问题呢？咱们下一节再说。\n\n#### JC-1-3.SpringBoot入门程序制作（三）\n\n 前面提到网站如果被限制访问了，该怎么办？开动脑筋想一想，不管是方式一还是方式二其实走的都是同一个路线，就是通过SpringBoot官网创建SpringBoot工程，假如国内有这么一个网站也能提供这样的功能，是不是就解决了呢？必然的嘛，新的问题又来了，国内有提供这样功能的网站吗？还真有，阿里提供了一个，下面问题就简单了，网址告诉我们就OK了，没错，就是这样。\n\n 创建工程时，切换选择starter服务路径，然后手工输入阿里云地址即可，地址：http://start.aliyun.com或https://start.aliyun.com\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/e692bb538f9c494c01d2be570714733c.png)\n\n 阿里为了便于自己公司开发使用，特此在依赖坐标中添加了一些阿里自主的技术，也是为了推广自己的技术吧，所以在依赖选择列表中，你有了更多的选择。此外，阿里提供的地址更符合国内开发者的使用习惯，里面有一些SpringBoot官网上没有给出的坐标，大家可以好好看一看。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/9072e4e217a20532945ce5e23bebcf19.png)\n\n 不过有一点需要说清楚，阿里云地址默认创建的SpringBoot工程版本是2.4.1，所以如果你想更换其他的版本，创建项目后在pom文件中手工修改即可，别忘了刷新一下，加载新版本信息。\n\n 注意：阿里云提供的工程创建地址初始化完毕后和使用SpringBoot官网创建出来的工程略有区别，主要是在配置文件的形式上有区别,这个信息在后面讲解SpringBoot程序的执行流程时给大家揭晓。\n\n**总结**\n\n1. 选择start来源为自定义URL\n2. 输入阿里云starter地址\n3. 创建项目\n\n**思考**\n\n 做到这里我们已经有了三种方式创建SpringBoot工程，但是每种方式都要求你必须能上网才能创建工程。假如有一天，你加入了一个保密级别比较高的项目组，整个项目组没有外网，这个事情是不是就不能做了呢？咱们下一节再说。\n\n#### JC-1-4.SpringBoot入门程序制作（四）\n\n 不能上网，还想创建SpringBoot工程，能不能做呢？能做，但是你要先问问自己联网和不联网到底差别是什么？这个差别找到以后，你就发现，你把联网要干的事情都提前准备好，就无需联网了。\n\n 联网做什么呢？首先SpringBoot工程也是基于Maven构建的，而Maven工程中如果加载一些工程需要使用又不存在的东西时，就要联网去下载。其实SpringBoot工程创建的时候就是要去下载一些必要的组件。如果把这些东西提前准备好呢？是的，就是这样。\n\n 下面就手工创建一个SpringBoot工程，如果需要使用的东西提前保障在maven仓库中存在，整个过程就可以不依赖联网环境了。不过咱们已经用3种方式创建了SprongBoot工程了，所以下面也没什么东西需要下载了。\n\n\n**步骤①**：创建工程时，选择创建普通Maven工程。![img](https://img-blog.csdnimg.cn/img_convert/694193d24fe26235cd78893a7b1b7566.png#pic_center)\n\n**步骤②**：参照标准SpringBoot工程的pom文件，书写自己的pom文件即可。\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.4</version>\n    </parent>\n\n    <groupId>com.itheima</groupId>\n    <artifactId>springboot_01_04_quickstart</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n 用什么写什么，不用的都可以不写。当然，现在小伙伴们可能还不知道用什么和不用什么，最简单的就是复制粘贴了，随着后面的学习，你就知道哪些可以省略了。此处我删减了一些目前不是必须的东西，一样能用。核心的内容有两条，一个是继承了一个父工程，另外添加了一个依赖。\n\n**步骤③**：之前运行SpringBoot工程需要一个类，这个缺不了，自己手写一个就行了，建议按照之前的目录结构来创建，先别玩花样，先学走后学跑。类名可以自定义，关联的名称同步修改即可。\n\n```java\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class);\n    }\n}\n```\n\n 关注：类上面的注解@SpringBootApplication千万别丢了，这个是核心，后面再介绍。\n\n 关注：类名可以自定义，只要保障下面代码中使用的类名和你自己定义的名称一样即可，也就是run方法中的那个class对应的名称。\n\n**步骤④**：下面就可以自己创建一个Controller测试一下是否能用了，和之前没有差别的。\n\n 看到这里其实应该能够想明白了，通过向导或者网站创建的SpringBoot工程其实就是帮你写了一些代码，而现在是自己手写，写的内容都一样，仅此而已。\n\n温馨提示\n\n 如果你的计算机上从来没有创建成功过SpringBoot工程，自然也就没有下载过SpringBoot对应的坐标相关的资源，那用手写创建的方式在不联网的情况下肯定该是不能用的。所谓手写，其实就是自己写别人帮你生成的东西，但是引用的坐标对应的资源必须保障maven仓库里面有才行，如果没有，还是要去下载的。\n\n**总结**\n\n1. 创建普通Maven工程\n2. 继承spring-boot-starter-parent\n3. 添加依赖spring-boot-starter-web\n4. 制作引导类Application\n\n 到这里已经学习了4种创建SpringBoot工程的方式，其实本质是一样的，都是根据SpringBoot工程的文件格式要求，通过不同时方式生成或者手写得到对应的文件，效果完全一样。\n\n##### 教你一招：在Idea中隐藏指定文件/文件夹\n\n 创建SpringBoot工程时，使用SpringBoot向导也好，阿里云也罢，其实都是为了一个目的，得到一个标准的SpringBoot工程文件结构。这个时候就有新的问题出现了，标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，这一节就来说说这些文件怎么处理。\n\n 处理方案无外乎两种，如果你对每一个文件/目录足够了解，有用的留着，没有用的完全可以删除掉。或者不删除，但是看着别扭，就设置文件为看不到就行了。删除不说了，选中后直接Delete掉就好了，这一节说说如何隐藏指定的文件或文件夹信息。\n\n 既然是在Idea下做隐藏功能，肯定隶属于Idea的设置，设置方式如下。\n\n\n**步骤①**：打开设置，【Files】→【Settings】。![img](https://img-blog.csdnimg.cn/img_convert/a41746d5b7e1522745f13b5c8d16885a.png#pic_center)\n\n\n**步骤②**：打开文件类型设置界面后，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示。![img](https://img-blog.csdnimg.cn/img_convert/9038556072115cd025545627ae2a5dbf.png#pic_center)\n\n**步骤③**：添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可。\n\n 到这里就做完了，其实就是Idea的一个小功能\n\n**总结**\n\n1. Idea中隐藏指定文件或指定类型文件 \n <ol>\n  1. 【Files】→【Settings】\n  1. 【Editor】→【File Types】→【Ignored Files and Folders】\n  1. 输入要隐藏的名称，支持*号通配符\n  1. 回车确认添加\n </ol>\n\n#### JC-1-5.SpringBoot简介\n\n 入门案例做完了，这个时候回忆一下咱们之前说的SpringBoot的功能是什么还记得吗？加速Spring程序的开发，现在是否深有体会？再来看SpringBoot技术的设计初衷就很容易理解了。\n\n SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程。\n\n 都简化了了哪些东西呢？其实就是针对原始的Spring程序制作的两个方面进行了简化：\n\n- Spring程序缺点 \n <ul>\n  - 依赖设置繁琐 \n   <ul>\n    - 以前写Spring程序，使用的技术都要自己一个一个的写，现在不需要了，如果做过原始SpringMVC程序的小伙伴应该知道，写SpringMVC程序，最基础的spring-web和spring-webmvc这两个坐标是必须的，就这还不包含你用json啊等等这些坐标，现在呢？一个坐标搞定了。\n   </ul>\n  - 配置繁琐 \n   <ul>\n    - 以前写配置类或者配置文件，然后用什么东西就要自己写加载bean这些东西，现在呢？什么都没写，照样能用。\n   </ul>\n </ul>\n\n>回顾\n\n 再来看看前面提出的两个问题，已经有答案了，都简化了，都不用写了，这就是SpringBoot给我们带来的好处。这些简化操作在SpringBoot中有专业的用语，也是SpringBoot程序的核心功能及优点：\n\n- 起步依赖（简化依赖配置） \n <ul>\n  - 依赖配置的书写简化就是靠这个起步依赖达成的。\n </ul>\n- 自动配置（简化常用工程相关配置） \n <ul>\n  - 配置过于繁琐，使用自动配置就可以做相应的简化，但是内部还是很复杂的，后面具体展开说。\n </ul>\n- 辅助功能（内置服务器，……） \n <ul>\n  - 除了上面的功能，其实SpringBoot程序还有其他的一些优势，比如我们没有配置Tomcat服务器，但是能正常运行，这是SpringBoot入门程序中一个可以感知到的功能，也是SpringBoot的辅助功能之一。一个辅助功能都能做的这么6，太牛了。\n </ul>\n\n 下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为4个方面\n\n- parent\n- starter\n- 引导类\n- 内嵌tomcat\n\n##### parent\n\n SpringBoot关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如A技术的2.0版，在与B技术进行配合使用时，与B技术的3.5版可以合作在一起工作，但是和B技术的3.7版合作开发使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。\n\n SpringBoot一看这种情况so easy啊，于是将所有的技术版本的常见使用方案都给开发者整理了出来，以后开发者使用时直接用它提供的版本方案，就不用担心冲突问题了，相当于SpringBoot做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做parent。\n\n parent自身具有很多个版本，每个parent版本中包含有几百个其他技术的版本号，不同的parent间使用的各种技术的版本号有可能会发生变化。当开发者使用某些技术时，直接使用SpringBoot提供的parent就行了，由parent帮助开发者统一的进行各种技术的版本管理。\n\n 比如你现在要使用Spring配合MyBatis开发，没有parent之前怎么做呢？选个Spring的版本，再选个MyBatis的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你Spring的版本发生变化需要切换时，你的MyBatis版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现其他问题。现在这一切工作都可以交给parent来做了。你无需关注这些技术间的版本冲突问题，你只需要关注你用什么技术就行了，冲突问题由parent负责处理。\n\n 有人可能会提出来，万一parent给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，parent仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，使用parent可以帮助开发者进行版本的统一管理。\n\n 关注：parent定义出来以后，并不是直接使用的，仅仅给了开发者一个说明书，但是并没有实际使用，这个一定要确认清楚。\n\n 那SpringBoot又是如何做到这一点的呢？可以查阅SpringBoot的配置源码，看到这些定义。\n\n- 项目中的pom.xml中继承了一个坐标\n\n```java\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.5.4</version>\n</parent>\n```\n\n- 打开后可以查阅到其中又继承了一个坐标\n\n```java\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.5.4</version>\n</parent>\n```\n\n- 这个坐标中定义了两组信息\n\n第一组是各式各样的依赖版本号属性，下面列出依赖版本属性的局部，可以看的出来，定义了若干个技术的依赖版本号。\n\n```java\n<properties>\n    <activemq.version>5.16.3</activemq.version>\n    <aspectj.version>1.9.7</aspectj.version>\n    <assertj.version>3.19.0</assertj.version>\n    <commons-codec.version>1.15</commons-codec.version>\n    <commons-dbcp2.version>2.8.0</commons-dbcp2.version>\n    <commons-lang3.version>3.12.0</commons-lang3.version>\n    <commons-pool.version>1.6</commons-pool.version>\n    <commons-pool2.version>2.9.0</commons-pool2.version>\n    <h2.version>1.4.200</h2.version>\n    <hibernate.version>5.4.32.Final</hibernate.version>\n    <hibernate-validator.version>6.2.0.Final</hibernate-validator.version>\n    <httpclient.version>4.5.13</httpclient.version>\n    <jackson-bom.version>2.12.4</jackson-bom.version>\n    <javax-jms.version>2.0.1</javax-jms.version>\n    <javax-json.version>1.1.4</javax-json.version>\n    <javax-websocket.version>1.1</javax-websocket.version>\n    <jetty-el.version>9.0.48</jetty-el.version>\n    <junit.version>4.13.2</junit.version>\n</properties>\n```\n\n第二组是各式各样的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值.\n\n```java\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.hibernate</groupId>\n            <artifactId>hibernate-core</artifactId>\n            <version>${hibernate.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>${junit.version}</version>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n 关注：上面的依赖坐标定义是出现在标签中的，是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组parent信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的。\n\n 关注：因为在maven中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的starter创建工程时就使用了此种形式。\n\n```java\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-dependencies</artifactId>\n            <version>${spring-boot.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n**总结**\n\n1. 开发SpringBoot程序要继承spring-boot-starter-parent\n2. spring-boot-starter-parent中定义了若干个依赖管理\n3. 继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突\n4. 继承parent的形式也可以采用引入依赖的形式实现效果\n\n**思考**\n\n parent中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？\n\n##### starter\n\n SpringBoot关注到实际开发时，开发者对于依赖坐标的使用往往都有一些固定的组合方式，比如使用spring-webmvc就一定要使用spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。\n\n SpringBoot一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用每次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot给它起了个名字叫做starter。\n\n starter定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，使用starter可以帮助开发者减少依赖配置。\n\n 这个东西其实在入门案例里面已经使用过了，入门案例中的web功能就是使用这种方式添加依赖的。可以查阅SpringBoot的配置源码，看到这些定义。\n\n- 项目中的pom.xml定义了使用SpringMVC技术，但是并没有写SpringMVC的坐标，而是添加了一个名字中包含starter的依赖\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n- 在spring-boot-starter-web中又定义了若干个具体依赖的坐标\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-json</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-tomcat</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-web</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n```\n\n 之前提到过开发SpringMVC程序需要导入spring-webmvc的坐标和spring整合web开发的坐标，就是上面这组坐标中的最后两个了。\n\n 但是我们发现除了这两个坐标，还有其他的坐标。比如第二个，叫做spring-boot-starter-json。看名称就知道，这个是与json有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有starter，打开看看里面有什么？\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-web</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.datatype</groupId>\n        <artifactId>jackson-datatype-jdk8</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.datatype</groupId>\n        <artifactId>jackson-datatype-jsr310</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.module</groupId>\n        <artifactId>jackson-module-parameter-names</artifactId>\n        <version>2.12.4</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n```\n\n 我们可以发现，这个starter中又包含了若干个坐标，其实就是使用SpringMVC开发通常都会使用到Json，使用json又离不开这里面定义的这些坐标，看来还真是方便，SpringBoot把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过maven中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。\n\n 到这里基本上得到了一个信息，使用starter可以帮开发者快速配置依赖关系。以前写依赖3个坐标的，现在写导入一个就搞定了，就是加速依赖配置的。\n\n**starter与parent的区别**\n\n 朦朦胧胧中感觉starter与parent好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。\n\n starter是一个坐标中定了若干个坐标，以前写多个的，现在写一个，是用来减少依赖配置的书写量的。\n\n parent是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，这样就不存在版本冲突了，是用来减少依赖冲突的。\n\n**实际开发应用方式**\n\n- \n 实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter\n <ul>\n  - 如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供\n  - 如果没有对应的starter，手写坐标即可\n </ul>\n- \n 实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖SpringBoot提供给我们的配置管理\n <ul>\n  - 方式一：直接写坐标\n  - 方式二：覆盖中定义的版本号，就是下面这堆东西了，哪个冲突了覆盖哪个就OK了\n </ul>\n <properties>\n    <activemq.version>5.16.3</activemq.version>\n    <aspectj.version>1.9.7</aspectj.version>\n    <assertj.version>3.19.0</assertj.version>\n    <commons-codec.version>1.15</commons-codec.version>\n    <commons-dbcp2.version>2.8.0</commons-dbcp2.version>\n    <commons-lang3.version>3.12.0</commons-lang3.version>\n    <commons-pool.version>1.6</commons-pool.version>\n    <commons-pool2.version>2.9.0</commons-pool2.version>\n    <h2.version>1.4.200</h2.version>\n    <hibernate.version>5.4.32.Final</hibernate.version>\n    <hibernate-validator.version>6.2.0.Final</hibernate-validator.version>\n    <httpclient.version>4.5.13</httpclient.version>\n    <jackson-bom.version>2.12.4</jackson-bom.version>\n    <javax-jms.version>2.0.1</javax-jms.version>\n    <javax-json.version>1.1.4</javax-json.version>\n    <javax-websocket.version>1.1</javax-websocket.version>\n    <jetty-el.version>9.0.48</jetty-el.version>\n    <junit.version>4.13.2</junit.version>\n</properties>\n\n温馨提示\n\n SpringBoot官方给出了好多个starter的定义，方便我们使用，而且名称都是如下格式\n\n```java\n命名规则：spring-boot-starter-技术名称\n```\n\n 所以后期见了spring-boot-starter-aaa这样的名字，这就是SpringBoot官方给出的starter定义。那非官方定义的也有吗？有的，具体命名方式到整合技术的章节再说。\n\n**总结**\n\n1. 开发SpringBoot程序需要导入坐标时通常导入对应的starter\n2. 每个不同的starter根据功能不同，通常包含多个依赖坐标\n3. 使用starter可以实现快速配置的效果，达到简化配置的目的\n\n##### 引导类\n\n 配置说完了，我们发现SpringBoot确实帮助我们减少了很多配置工作，下面说一下程序是如何运行的。目前程序运行的入口就是SpringBoot工程创建时自带的那个类，也就是带有main方法的那个类，运行这个类就可以启动SpringBoot工程的运行。\n\n```java\n@SpringBootApplication\npublic class Springboot0101QuickstartApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Springboot0101QuickstartApplication.class, args);\n    }\n}\n```\n\n SpringBoot本身是为了加速Spring程序的开发的，而Spring程序运行的基础是需要创建Spring容器对象（IoC容器）并将所有的对象放置到Spring容器中管理，也就是一个一个的Bean。现在改用SpringBoot加速开发Spring程序，这个容器还在吗？这个疑问不用说，一定在。其实当前这个类运行后就会产生一个Spring容器对象，并且可以将这个对象保存起来，通过容器对象直接操作Bean。\n\n```java\n@SpringBootApplication\npublic class QuickstartApplication {\n    public static void main(String[] args) {\n        ConfigurableApplicationContext ctx = SpringApplication.run(QuickstartApplication.class, args);\n        BookController bean = ctx.getBean(BookController.class);\n        System.out.println(\"bean======>\" + bean);\n    }\n}\n```\n\n 通过上述操作不难看出，其实SpringBoot程序启动还是创建了一个Spring容器对象。当前运行的这个类在SpringBoot程序中是所有功能的入口，称为引导类。\n\n 作为一个引导类最典型的特征就是当前类上方声明了一个注解@SpringBootApplication。\n\n**总结**\n\n1. SpringBoot工程提供引导类用来启动程序\n2. SpringBoot工程启动后创建并初始化Spring容器\n\n**思考**\n\n 程序现在已经运行了，通过引导类的main方法运行了起来。但是运行java程序不应该是执行完就结束了吗？但是我们现在明显是启动了一个web服务器啊，不然网页怎么能正常访问呢？这个服务器是在哪里写的呢？\n\n##### 内嵌tomcat\n\n 当前我们做的SpringBoot入门案例勾选了Spring-web的功能，并且导入了对应的starter。\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n SpringBoot发现，既然你要做web程序，肯定离不开使用web服务器，这样吧，帮人帮到底，送佛送到西，我帮你搞一个web服务器，你要愿意用的，直接使用就好了。SpringBoot又琢磨，提供一种服务器万一不满足开发者需要呢？干脆我再多给你几种选择，你随便切换。万一你不想用我给你提供的，也行，你可以自己搞。\n\n 由于这个功能不属于程序的主体功能，可用可不用，于是乎SpringBoot将其定位成辅助功能，别小看这么一个辅助功能，它可是帮我们开发者又减少了好多的设置性工作。\n\n 下面就围绕着这个内置的web服务器，也可以说是内置的tomcat服务器来研究几个问题：\n\n1. 这个服务器在什么位置定义的\n2. 这个服务器是怎么运行的\n3. 这个服务器如果想换怎么换？虽然这个需求很垃圾，搞得开发者会好多web服务器一样，用别人提供好的不香么？非要自己折腾\n\n**内嵌Tomcat定义位置**\n\n 说到定义的位置，我们就想，如果我们不开发web程序，用的着web服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是web相关的功能啊，没错，就是前面导入的web相关的starter做的这件事。\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n 打开web对应的starter查看导入了哪些东西。\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-json</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-tomcat</artifactId>\n        <version>2.5.4</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-web</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.3.9</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n```\n\n 第三个依赖就是tomcat对应的东西了，居然也是一个starter，再打开看看。\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>jakarta.annotation</groupId>\n        <artifactId>jakarta.annotation-api</artifactId>\n        <version>1.3.5</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-core</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n        <exclusions>\n            <exclusion>\n                <artifactId>tomcat-annotations-api</artifactId>\n                <groupId>org.apache.tomcat</groupId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-el</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-websocket</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n        <exclusions>\n            <exclusion>\n                <artifactId>tomcat-annotations-api</artifactId>\n                <groupId>org.apache.tomcat</groupId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n```\n\n 这里面有一个核心的坐标，tomcat-embed-core，叫做tomcat内嵌核心。就是这个东西把tomcat功能引入到了我们的程序中的。目前解决了第一个问题，找到根儿了，谁把tomcat引入到程序中的？spring-boot-starter-web中的spring-boot-starter-tomcat做的。之所以你感觉很奇妙的原因就是，这个东西是默认加入到程序中了，所以感觉很神奇，居然什么都不做，就有了web服务器对应的功能。再来说第二个问题，这个服务器是怎么运行的。\n\n**内嵌Tomcat运行原理**\n\n Tomcat服务器是一款软件，而且是一款使用java语言开发的软件，熟悉tomcat的话应该知道tomcat安装目录中保存有很多jar文件。\n\n 下面的问题来了，既然是使用java语言开发的，运行的时候肯定符合java程序运行的原理，java程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那tomcat运行起来呢？也是对象啊。\n\n 如果是对象，那Spring容器是用来管理对象的，这个对象能交给Spring容器管理吗？把吗去掉，是个对象都可以交给Spring容器管理，行了，这下通了，tomcat服务器运行其实是以对象的形式在Spring容器中运行的。怪不得我们没有安装这个tomcat但是还能用，闹了白天这东西最后是以一个对象的形式存在，保存在Spring容器中悄悄运行的。具体运行的是什么呢？其实就是上前面提到的那个tomcat内嵌核心。\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>org.apache.tomcat.embed</groupId>\n        <artifactId>tomcat-embed-core</artifactId>\n        <version>9.0.52</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n```\n\n 那既然是个对象，如果把这个对象从Spring容器中去掉是不是就没有web服务器的功能呢？是这样的，通过依赖排除可以去掉这个web服务器功能。\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <exclusions>\n            <exclusion>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n```\n\n 上面对web-starter做了一个操作，使用maven的排除依赖去掉了使用tomcat的starter。这下好了，容器中肯定没有这个对象了，重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后是一个一直运行的服务，而是直接停掉了，就是这个原因。\n\n**更换内嵌Tomcat**\n\n 那根据上面的操作我们思考是否可以换个服务器呢？必须的嘛。根据SpringBoot的工作机制，用什么技术，加入什么依赖就行了。SpringBoot提供了3款内置的服务器：\n\n- \n tomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件\n- \n jetty：更轻量级，负载性能远不及tomcat\n- \n undertow：负载性能勉强跑赢tomcat\n 想用哪个，加个坐标就OK。前提是把tomcat排除掉，因为tomcat是默认加载的。\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <exclusions>\n            <exclusion>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-jetty</artifactId>\n    </dependency>\n</dependencies>\n```\n\n 现在就已经成功替换了web服务器，核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter。\n\n**总结**\n\n1. 内嵌Tomcat服务器是SpringBoot辅助功能之一\n2. 内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理\n3. 变更内嵌服务器思想是去除现有服务器，添加全新的服务器\n\n 到这里第一章快速上手SpringBoot就结束了，这一章我们学习了两大块知识\n\n1. \n 使用了4种方式制作了SpringBoot的入门程序，不管是哪一种，其实内部都是一模一样的\n2. \n 学习了入门程序的工作流程，知道什么是parent，什么是starter，这两个东西是怎么配合工作的，以及我们的程序为什么启动起来是一个tomcat服务器等等\n 第一章到这里就结束了，再往下学习就要去基于会创建SpringBoot工程的基础上，研究SpringBoot工程的具体细节了。\n\n### JC-2.SpringBoot基础配置\n\n 入门案例做完了，下面就要研究SpringBoot的用法了。通过入门案例，各位小伙伴能够感知到一个信息，SpringBoot没有具体的功能，它是辅助加快Spring程序的开发效率的。我们发现，现在几乎不用做任何配置功能就有了，确实很好用。但是仔细想想，没有做配置意味着什么？意味着配置已经做好了，不用你自己写了。但是新的问题又来了，如果不想用已经写好的默认配置，该如何干预呢？这就是这一章咱们要研究的问题。\n\n 如果想修改默认的配置，这个信息应该写在什么位置呢？目前我们接触的入门案例中一共有3个文件，第一是pom.xml文件，设置项目的依赖，这个没什么好研究的，相关的高级内容咱们到原理篇再说，第二是引导类，这个是执行SpringBoot程序的入口，也不像是做功能配置的地方，其实还有一个信息，就是在resources目录下面有一个空白的文件，叫做application.properties。一看就是个配置文件，咱们这一章就来说说配置文件怎么写，能写什么，怎么覆盖SpringBoot的默认配置修改成自己的配置。\n\n\n\n#### JC-2-1.属性配置\n\n SpringBoot通过配置文件application.properties就可以修改默认的配置，那咱们就先找个简单的配置下手，当前访问tomcat的默认端口是8080，好熟悉的味道，但是不便于书写，我们先改成80，通过这个操作来熟悉一下SpringBoot的配置格式是什么样的。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/6e3b3570121a2c82c30d0b5f6352c653.png)\n\n 那该如何写呢？properties格式的文件书写规范是key=value\n\n```java\nname=itheima\n```\n\n\n 这个格式肯定是不能颠覆的，那就尝试性的写就行了，改端口，写port。当你输入port后，神奇的事情就发生了，这玩意儿带提示，太好了。![img](https://img-blog.csdnimg.cn/img_convert/3a63ac9446ed8f2ac4eff17961644640.png#pic_center)\n\n 根据提示敲回车，输入80端口，搞定。\n\n```java\nserver.port=80\n```\n\n 下面就可以直接运行程序，测试效果了。\n\n 我们惊奇的发现SpringBoot这玩意儿狠啊，以前修改端口在哪里改？tomcat服务器的配置文件中改，现在呢？SpringBoot专用的配置文件中改，是不是意味着以后所有的配置都可以写在这一个文件中呢？是的，简化开发者配置的书写位置，集中管理。妙啊，妈妈再也不用担心我找不到配置文件了。\n\n 其实到这里我们应该得到如下三个信息：\n\n1. SpringBoot程序可以在application.properties文件中进行属性配置\n2. application.properties文件中只要输入要配置的属性关键字就可以根据提示进行设置\n3. SpringBoot将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面\n\n**总结**\n\n1. SpringBoot默认配置文件是application.properties\n\n 做完了端口的配置，趁热打铁，再做几个配置，目前项目启动时会显示一些日志信息，就来改一改这里面的一些设置。\n\n**关闭运行日志图表（banner)**\n\n```java\nspring.main.banner-mode=off\n```\n\n**设置运行日志的显示级别**\n\n```java\nlogging.level.root=debug\n```\n\n 你会发现，现在这么搞配置太爽了，以前你做配置怎么做？不同的技术有自己专用的配置文件，文件不同格式也不统一，现在呢？不用东奔西走的找配置文件写配置了，统一格式了，这就是大秦帝国啊，统一六国。SpringBoot比大秦狠，因为未来出现的技术还没出现呢，但是现在已经确认了，配置都写这个文件里面。\n\n 我们现在配置了3个信息，但是又有新的问题了。这个配置是随便写的吗？什么都能配？有没有一个东西显示所有能配置的项呢？此外这个配置和什么东西有关呢？会不会因为我写了什么东西以后才可以写什么配置呢？比如我现在没有写数据库相关的东西，能否配置数据呢？一个一个来，先说第一个问题，都能配置什么。\n\n 打开SpringBoot的官网，找到SpringBoot官方文档，打开查看附录中的Application Properties就可以获取到对应的配置项了，网址奉上：https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties\n\n 能写什么的问题解决了，再来说第二个问题，这个配置项和什么有关。在pom中注释掉导入的spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。也合理，不然没有使用对应技术，配了也是白配。\n\n温馨提示\n\n 所有的starter中都会依赖下面这个starter，叫做spring-boot-starter。这个starter是所有的SpringBoot的starter的基础依赖，里面定义了SpringBoot相关的基础配置，关于这个starter我们到开发应用篇和原理篇中再深入讲解。\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter</artifactId>\n    <version>2.5.4</version>\n    <scope>compile</scope>\n</dependency>\n```\n\n**总结**\n\n1. SpringBoot中导入对应starter后，提供对应配置属性\n2. 书写SpringBoot配置采用关键字+提示形式书写\n\n#### JC-2-2.配置文件分类\n\n 现在已经能够进行SpringBoot相关的配置了，但是properties格式的配置写起来总是觉得看着不舒服，所以就期望存在一种书写起来更简便的配置格式提供给开发者使用。有吗？还真有，SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。三种配置文件格式分别如下:\n\n- properties格式\n- yml格式\n- yaml格式\n\n 一看到全新的文件格式，各位小伙伴肯定想，这下又要学习新的语法格式了。怎么说呢？从知识角度来说，要学，从开发角度来说，不用学。为什么呢？因为SpringBoot的配置在Idea工具下有提示啊，跟着提示走就行了。下面列举三种不同文件格式配置相同的属性范例，先了解一下。\n\n- application.properties（properties格式）\n\n```java\nserver.port=80\n```\n\n- application.yml（yml格式）\n\n```java\nserver:\n  port: 81\n```\n\n- application.yaml（yaml格式）\n\n```java\nserver:\n  port: 82\n```\n\n 仔细看会发现yml格式和yaml格式除了文件名后缀不一样，格式完全一样，是这样的，yml和yaml文件格式就是一模一样的，只是文件后缀不同，所以可以合并成一种格式来看。那对于这三种格式来说，以后用哪一种比较多呢？记清楚，以后基本上都是用yml格式的，本课程后面的所有知识都是基于yml格式来制作的，以后在企业开发过程中用这个格式的机会也最多，一定要重点掌握。\n\n**总结**\n\n1. SpringBoot提供了3种配置文件的格式 \n <ul>\n  1. properties（传统格式/默认格式）\n  1. **yml**（主流格式）\n  1. yaml\n </ul>\n\n**思考**\n\n 现在我们已经知道使用三种格式都可以做配置了，好奇宝宝们就有新的灵魂拷问了，万一我三个都写了，他们三个谁说了算呢？打一架吗？\n\n##### 配置文件优先级\n\n 其实三个文件如果共存的话，谁生效说的就是配置文件加载的优先级别。先说一点，虽然以后这种情况很少出现，但是这个知识还是可以学习一下的。我们就让三个配置文件书写同样的信息，比如都配置端口，然后我们让每个文件配置的端口号都不一样，最后启动程序后看启动端口是多少就知道谁的加载优先级比较高了。\n\n- application.properties（properties格式）\n\n```java\nserver.port=80\n```\n\n- application.yml（yml格式）\n\n```java\nserver:\n  port: 81\n```\n\n- application.yaml（yaml格式）\n\n```java\nserver:\n  port: 82\n```\n\n 启动后发现目前的启动端口为80，把80对应的文件删除掉，然后再启动，现在端口又改成了81。现在我们就已经知道了3个文件的加载优先顺序是什么。\n\n```java\napplication.properties  >  application.yml  >  application.yaml\n```\n\n 虽然得到了一个知识结论，但是我们实际开发的时候还是要看最终的效果为准。也就是你要的最终效果是什么自己是明确的，上述结论只能帮助你分析结论产生的原因。这个知识了解一下就行了，因为以后同时写多种配置文件格式的情况实在是较少。\n\n 最后我们把配置文件内容给修改一下\n\n- application.properties（properties格式）\n\n```java\nserver.port=80\nspring.main.banner-mode=off\n```\n\n- application.yml（yml格式）\n\n```java\nserver:\n  port: 81\nlogging: \n  level: \n    root: debug\n```\n\n- application.yaml（yaml格式）\n\n```java\nserver:\n  port: 82\n```\n\n 我们发现不仅端口生效了，最终显示80，同时其他两条配置也生效了，看来每个配置文件中的项都会生效，只不过如果多个配置文件中有相同类型的配置会优先级高的文件覆盖优先级的文件中的配置。如果配置项不同的话，所有的配置项都会生效。\n\n**总结**\n\n1. 配置文件间的加载优先级 properties（最高）&gt; yml &gt; yaml（最低）\n2. 不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留\n\n##### 教你一招：自动提示功能消失解决方案\n\n 在做程序的过程中，可能有些小伙伴会基于各种各样的原因导致配置文件中没有提示，这个确实很让人头疼，所以下面给大家说一下如果自动提示功能消失了怎么解决。\n\n 先要明确一个核心，就是自动提示功能不是SpringBoot技术给我们提供的，是我们在Idea工具下编程，这个编程工具给我们提供的。明白了这一点后，再来说为什么会出现这种现象。其实这个自动提示功能消失的原因还是蛮多的，如果想解决这个问题，就要知道为什么会消失，大体原因有如下2种：\n\n1. \n Idea认为你现在写配置的文件不是个配置文件，所以拒绝给你提供提示功能\n2. \n Idea认定你是合理的配置文件，但是Idea加载不到对应的提示信息\n 这里我们主要解决第一个现象，第二种现象到原理篇再讲解。第一种现象的解决方式如下：\n\n**步骤①**：打开设置，【Files】→【Project Structure…】\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/059743ea18d9303efc28ebaceac87e02.png)\n\n\n**步骤②**：在弹出窗口中左侧选择【Facets】，右侧选中Spring路径下对应的模块名称，也就是你自动提示功能消失的那个模块![img](https://img-blog.csdnimg.cn/img_convert/0bbd566c53c162dd43b783e099b97d3c.png#pic_center)\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/b2df20e66ff46acfd9887fccdb3a9911.png)\n\n**步骤③**：点击Customize Spring Boot按钮，此时可以看到当前模块对应的配置文件是哪些了。如果没有你想要称为配置文件的文件格式，就有可能无法弹出提示\n\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/67946e47e23f7b9aad1e7a13f7664bc2.png)![img](https://img-blog.csdnimg.cn/img_convert/599306fa0ddf95a9810d674a281bed67.png#pic_center)\n\n\n\n**步骤④**：选择添加配置文件，然后选中要作为配置文件的具体文件就OK了![img](https://img-blog.csdnimg.cn/img_convert/334c02db8770c04696edefcf2c357e60.png#pic_center)![img](https://img-blog.csdnimg.cn/img_convert/ea14005ea4030b9845fc1076b0364705.png#pic_center)\n\n 到这里就做完了，其实就是Idea的一个小功能\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/6979423eb42dd904342ffc134a86b5c7.png)\n\n**总结**\n\n1. \n 指定SpringBoot配置文件\n <ul>\n  1. Setting → Project Structure → Facets\n  1. 选中对应项目/工程\n  1. Customize Spring Boot\n  1. 选择配置文件\n </ul>\n\n#### JC-2-3.yaml文件\n\n SpringBoot的配置以后主要使用yml结尾的这种文件格式，并且在书写时可以通过提示的形式加载正确的格式。但是这种文件还是有严格的书写格式要求的。下面就来说一下具体的语法格式。\n\n YAML（YAML Ain’t Markup Language），一种数据序列化格式。具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。常见的文件扩展名有两种：\n\n- \n .yml格式（主流）\n- \n .yaml格式\n 具体的语法格式要求如下：\n\n1. 大小写敏感\n2. 属性层级关系使用多行描述，**每行结尾使用冒号结束**\n3. 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）\n4. 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n5. #号 表示注释\n\n 上述规则不要死记硬背，按照书写习惯慢慢适应，并且在Idea下由于具有提示功能，慢慢适应着写格式就行了。核心的一条规则要记住，数据前面要加空格与冒号隔开。\n\n 下面列出常见的数据书写格式，熟悉一下\n\n```java\nboolean: TRUE  \t\t\t\t\t\t#TRUE,true,True,FALSE,false，False均可\nfloat: 3.14    \t\t\t\t\t\t#6.8523015e+5  #支持科学计数法\nint: 123       \t\t\t\t\t\t#0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制\nnull: ~        \t\t\t\t\t\t#使用~表示null\nstring: HelloWorld      \t\t\t#字符串可以直接书写\nstring2: \"Hello World\"  \t\t\t#可以使用双引号包裹特殊字符\ndate: 2018-02-17        \t\t\t#日期必须使用yyyy-MM-dd格式\ndatetime: 2018-02-17T15:02:31+08:00  #时间和日期之间使用T连接，最后使用+代表时区\n```\n\n 此外，yaml格式中也可以表示数组，在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔。\n\n```java\nsubject:\n\t- Java\n\t- 前端\n\t- 大数据\nenterprise:\n\tname: itcast\n    age: 16\n    subject:\n    \t- Java\n        - 前端\n        - 大数据\nlikes: [王者荣耀,刺激战场]\t\t\t#数组书写缩略格式\nusers:\t\t\t\t\t\t\t #对象数组格式一\n  - name: Tom\n   \tage: 4\n  - name: Jerry\n    age: 5\nusers:\t\t\t\t\t\t\t #对象数组格式二\n  -  \n    name: Tom\n    age: 4\n  -   \n    name: Jerry\n    age: 5\t\t\t    \nusers2: [ { name:Tom , age:4 } , { name:Jerry , age:5 } ]\t#对象数组缩略格式\n```\n\n**总结**\n\n1. yaml语法规则 \n <ul>\n  1. 大小写敏感\n  1. 属性层级关系使用多行描述，每行结尾使用冒号结束\n  1. 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）\n  1. 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n  1. #号 表示注释\n </ul>\n7. 注意属性名冒号后面与数据之间有一个**空格**\n8. 字面值、对象数据格式、数组数据格式\n\n**思考**\n\n 现在我们已经知道了yaml具有严格的数据格式要求，并且已经可以正确的书写yaml文件了，那这些文件书写后其实是在定义一些数据。这些数据是给谁用的呢？大部分是SpringBoot框架内部使用，但是如果我们想配置一些数据自己使用，能不能用呢？答案是可以的，那如何读取yaml文件中的数据呢？咱们下一节再说。\n\n#### JC-2-4.yaml数据读取\n\n 对于yaml文件中的数据，其实你就可以想象成这就是一个小型的数据库，里面保存有若干数据，每个数据都有一个独立的名字，如果你想读取里面的数据，肯定是支持的，下面就介绍3种读取数据的方式。\n\n##### 读取单一数据\n\n\n yaml中保存的单个数据，可以使用Spring中的注解@Value读取单个数据，属性名引用方式：${一级属性名.二级属性名……}![img](https://img-blog.csdnimg.cn/img_convert/0287b7e9f291cf6c2592d55546d76f06.png#pic_center)\n\n 记得使用@Value注解时，要将该注解写在某一个指定的Spring管控的bean的属性名上方，这样当bean进行初始化时候就可以读取到对应的单一数据了。\n\n**总结**\n\n1. 使用@Value配合SpEL读取单个数据\n2. 如果数据存在多层级，依次书写层级名称即可\n\n##### 读取全部数据\n\n 读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，SpringBoot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做Environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/0d63334b43407a9b1a8cfac9e1b1ff8e.png#pic_center)\n\n 数据封装到了Environment对象中，获取属性时，通过Environment的接口操作进行，具体方法是getProperties（String），参数填写属性名即可\n\n**总结**\n\n1. 使用Environment对象封装全部配置信息\n2. 使用@Autowired自动装配数据到Environment对象中\n\n##### 读取对象数据\n\n 单一数据读取书写比较繁琐，全数据读取封装的太厉害了，每次拿数据还要一个一个的getProperties（）,总之用起来都不是很舒服。由于Java是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。SpringBoot也提供了可以将一组yaml对象数据封装一个Java对象的操作\n\n\n 首先定义一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean，然后使用注解@ConfigurationProperties指定该对象加载哪一组yaml中配置的信息。![img](https://img-blog.csdnimg.cn/img_convert/87f288d7695c840287594e9f09ffc9e1.png#pic_center)\n\n\n 这个@ConfigurationProperties必须告诉他加载的数据前缀是什么，这样指定前缀下的所有属性就封装到这个对象中。记得数据属性名要与对象的变量名一一对应啊，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可。![img](https://img-blog.csdnimg.cn/img_convert/7819de8652f7bc58ca3ad24a259bad3c.png#pic_center)\n\n\n\n温馨提示\n\n 细心的小伙伴会发现一个问题，自定义的这种数据在yaml文件中书写时没有弹出提示，咱们到原理篇再揭秘如何弹出提示。\n\n**总结**\n\n1. 使用@ConfigurationProperties注解绑定配置信息到封装类中\n2. 封装类需要定义为Spring管理的bean，否则无法进行属性注入\n\n##### yaml文件中的数据引用\n\n 如果你在书写yaml数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀\n\n```java\ncenter:\n\tdataDir: /usr/local/fire/data\n    tmpDir: /usr/local/fire/tmp\n    logDir: /usr/local/fire/log\n    msgDir: /usr/local/fire/msgDir\n```\n\n 或者\n\n```java\ncenter:\n\tdataDir: D:/usr/local/fire/data\n    tmpDir: D:/usr/local/fire/tmp\n    logDir: D:/usr/local/fire/log\n    msgDir: D:/usr/local/fire/msgDir\n```\n\n 这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下：\n\n```java\nbaseDir: /usr/local/fire\ncenter:\n    dataDir: ${baseDir}/data\n    tmpDir: ${baseDir}/tmp\n    logDir: ${baseDir}/log\n    msgDir: ${baseDir}/msgDir\n```\n\n 还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来\n\n```java\nlesson: \"Spring\\tboot\\nlesson\"\n```\n\n**总结**\n\n1. 在配置文件中可以使用${属性名}方式引用属性值\n2. 如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析\n\n 到这里有关yaml文件的基础使用就先告一段落，实用篇中再继续研究更深入的内容。\n\n### JC-3.基于SpringBoot实现SSMP整合\n\n 重头戏来了，SpringBoot之所以好用，就是它能方便快捷的整合其他技术，这一部分咱们就来聊聊一些技术的整合方式，通过这一章的学习，大家能够感受到SpringBoot到底有多酷炫。这一章咱们学习如下技术的整合方式\n\n- \n 整合JUnit\n- \n 整合MyBatis\n- \n 整合MyBatis-Plus\n- \n 整合Druid\n 上面这些技术都整合完毕后，我们做一个小案例，也算是学有所用吧。涉及的技术比较多，综合运用一下。\n\n#### JC-3-1.整合JUnit\n\n SpringBoot技术的定位用于简化开发，再具体点是简化Spring程序的开发。所以在整合任意技术的时候，如果你想直观感触到简化的效果，你必须先知道使用非SpringBoot技术时对应的整合是如何做的，然后再看基于SpringBoot的整合是如何做的，才能比对出来简化在了哪里。\n\n 我们先来看一下不使用SpringBoot技术时，Spring整合JUnit的制作方式\n\n```java\n//加载spring整合junit专用的类运行器\n@RunWith(SpringJUnit4ClassRunner.class)\n//指定对应的配置信息\n@ContextConfiguration(classes = SpringConfig.class)\npublic class AccountServiceTestCase {\n    //注入你要测试的对象\n    @Autowired\n    private AccountService accountService;\n    @Test\n    public void testGetById(){\n        //执行要测试的对象对应的方法\n        System.out.println(accountService.findById(2));\n    }\n}\n```\n\n 其中核心代码是前两个注解，第一个注解@RunWith是设置Spring专用的测试类运行器，简单说就是Spring程序执行程序有自己的一套独立的运行程序的方式，不能使用JUnit提供的类运行方式了，必须指定一下，但是格式是固定的，琢磨一下，每次都指定一样的东西，这个东西写起来没有技术含量啊，第二个注解@ContextConfiguration是用来设置Spring核心配置文件或配置类的，简单说就是加载Spring的环境你要告诉Spring具体的环境配置是在哪里写的，虽然每次加载的文件都有可能不同，但是仔细想想，如果文件名是固定的，这个貌似也是一个固定格式。既然有可能是固定格式，那就有可能每次都写一样的东西，也是一个没有技术含量的内容书写\n\n SpringBoot就抓住上述两条没有技术含量的内容书写进行开发简化，能走默认值的走默认值，能不写的就不写，具体格式如下\n\n```java\n@SpringBootTest\nclass Springboot04JunitApplicationTests {\n    //注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        //执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println(\"two...\");\n    }\n}\n```\n\n 看看这次简化成什么样了，一个注解就搞定了，而且还没有参数，再体会SpringBoot整合其他技术的优势在哪里，就两个字——简化。使用一个注解@SpringBootTest替换了前面两个注解。至于内部是怎么回事？和之前一样，只不过都走默认值。\n\n 这个时候有人就问了，你加载的配置类或者配置文件是哪一个？就是我们前面启动程序使用的引导类。如果想手工指定引导类有两种方式，第一种方式使用属性的形式进行，在注解@SpringBootTest中添加classes属性指定配置类\n\n```java\n@SpringBootTest(classes = Springboot04JunitApplication.class)\nclass Springboot04JunitApplicationTests {\n    //注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        //执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println(\"two...\");\n    }\n}\n```\n\n 第二种方式回归原始配置方式，仍然使用@ContextConfiguration注解进行，效果是一样的\n\n```java\n@SpringBootTest\n@ContextConfiguration(classes = Springboot04JunitApplication.class)\nclass Springboot04JunitApplicationTests {\n    //注入你要测试的对象\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        //执行要测试的对象对应的方法\n        bookDao.save();\n        System.out.println(\"two...\");\n    }\n}\n```\n\n温馨提示\n\n 使用SpringBoot整合JUnit需要保障导入test对应的starter，由于初始化项目时此项是默认导入的，所以此处没有提及，其实和之前学习的内容一样，用什么技术导入对应的starter即可。\n\n**总结**\n\n1. 导入测试对应的starter\n2. 测试类使用@SpringBootTest修饰\n3. 使用自动装配的形式添加要测试的对象\n4. 测试类如果存在于引导类所在包或子包中无需指定引导类\n5. 测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类\n\n#### JC-3-2.整合MyBatis\n\n 整合完JUnit下面再来说一下整合MyBatis，这个技术是大部分公司都要使用的技术，务必掌握。如果对Spring整合MyBatis不熟悉的小伙伴好好复习一下，下面列举出原始整合的全部内容，以配置类的形式为例进行\n\n- \n 导入坐标，MyBatis坐标不能少，Spring整合MyBatis还有自己专用的坐标，此外Spring进行数据库操作的jdbc坐标是必须的，剩下还有mysql驱动坐标，本例中使用了Druid数据源，这个倒是可以不要\n <dependencies>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid</artifactId>\n        <version>1.1.16</version>\n    </dependency>\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.6</version>\n    </dependency>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>5.1.47</version>\n    </dependency>\n    <!--1.导入mybatis与spring整合的jar包-->\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>1.3.0</version>\n    </dependency>\n    <!--导入spring操作数据库必选的包-->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.10.RELEASE</version>\n    </dependency>\n</dependencies>\n- \n Spring核心配置\n @Configuration\n@ComponentScan(\"com.itheima\")\n@PropertySource(\"jdbc.properties\")\npublic class SpringConfig {\n}\n- \n MyBatis要交给Spring接管的bean\n //定义mybatis专用的配置类\n@Configuration\npublic class MyBatisConfig {\n//    定义创建SqlSessionFactory对应的bean\n    @Bean\n    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){\n        //SqlSessionFactoryBean是由mybatis-spring包提供的，专用于整合用的对象\n        SqlSessionFactoryBean sfb = new SqlSessionFactoryBean();\n        //设置数据源替代原始配置中的environments的配置\n        sfb.setDataSource(dataSource);\n        //设置类型别名替代原始配置中的typeAliases的配置\n        sfb.setTypeAliasesPackage(\"com.itheima.domain\");\n        return sfb;\n    }\n//    定义加载所有的映射配置\n    @Bean\n    public MapperScannerConfigurer mapperScannerConfigurer(){\n        MapperScannerConfigurer msc = new MapperScannerConfigurer();\n        msc.setBasePackage(\"com.itheima.dao\");\n        return msc;\n    }\n\n}\n- \n 数据源对应的bean，此处使用Druid数据源\n @Configuration\npublic class JdbcConfig {\n    @Value(\"${jdbc.driver}\")\n    private String driver;\n    @Value(\"${jdbc.url}\")\n    private String url;\n    @Value(\"${jdbc.username}\")\n    private String userName;\n    @Value(\"${jdbc.password}\")\n    private String password;\n\n    @Bean(\"dataSource\")\n    public DataSource dataSource(){\n        DruidDataSource ds = new DruidDataSource();\n        ds.setDriverClassName(driver);\n        ds.setUrl(url);\n        ds.setUsername(userName);\n        ds.setPassword(password);\n        return ds;\n    }\n}\n- \n 数据库连接信息（properties格式）\n jdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false\njdbc.username=root\njdbc.password=root\n 上述格式基本上是最简格式了，要写的东西还真不少。下面看看SpringBoot整合MyBaits格式\n\n**步骤①**：创建模块\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/c8f9817aad572295f35be53d71e3bb47.png)\n\n**步骤②**：勾选要使用的技术，MyBatis，由于要操作数据库，还要勾选对应数据库\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/f19c0786c3898756af91d21867c814c9.png)\n\n 或者手工导入对应技术的starter，和对应数据库的坐标\n\n```java\n<dependencies>\n    <!--1.导入对应的starter-->\n    <dependency>\n        <groupId>org.mybatis.spring.boot</groupId>\n        <artifactId>mybatis-spring-boot-starter</artifactId>\n        <version>2.2.0</version>\n    </dependency>\n\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n</dependencies>\n```\n\n**步骤③**：配置数据源相关信息，没有这个信息你连接哪个数据库都不知道\n\n```java\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db\n    username: root\n    password: root\n```\n\n 结束了，就这么多，没了。有人就很纳闷，这就结束了？对，这就结束了，SpringBoot把配置中所有可能出现的通用配置都简化了。下面写一个MyBatis程序运行需要的Dao（或者Mapper）就可以运行了\n\n**实体类**\n\n```java\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n```\n\n**映射接口（Dao）**\n\n```java\n@Mapper\npublic interface BookDao {\n    @Select(\"select * from tbl_book where id = #{id}\")\n    public Book getById(Integer id);\n}\n```\n\n**测试类**\n\n```java\n@SpringBootTest\nclass Springboot05MybatisApplicationTests {\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void contextLoads() {\n        System.out.println(bookDao.getById(1));\n    }\n}\n```\n\n 完美，开发从此变的就这么简单。再体会一下SpringBoot如何进行第三方技术整合的，是不是很优秀？具体内部的原理到原理篇再展开讲解\n\n 注意：当前使用的SpringBoot版本是2.5.4，对应的坐标设置中Mysql驱动使用的是8x版本。使用SpringBoot2.4.3（不含）之前版本会出现一个小BUG，就是MySQL驱动升级到8以后要求强制配置时区，如果不设置会出问题。解决方案很简单，驱动url上面添加上对应设置就行了\n\n```java\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    username: root\n    password: root\n```\n\n 这里设置的UTC是全球标准时间，你也可以理解为是英国时间，中国处在东八区，需要在这个基础上加上8小时，这样才能和中国地区的时间对应的，也可以修改配置为Asia/Shanghai，同样可以解决这个问题。\n\n```java\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai\n    username: root\n    password: root\n```\n\n 如果不想每次都设置这个东西，也可以去修改mysql中的配置文件mysql.ini，在mysqld项中添加default-time-zone=+8:00也可以解决这个问题。其实方式方法很多，这里就说这么多吧。\n\n 此外在运行程序时还会给出一个提示，说数据库驱动过时的警告，根据提示修改配置即可，弃用**com.mysql.jdbc.Driver**，换用com.mysql.cj.jdbc.Driver。前面的例子中已经更换了驱动了，在此说明一下。\n\n```java\nLoading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.\n```\n\n**总结**\n\n1. \n 整合操作需要勾选MyBatis技术，也就是导入MyBatis对应的starter\n2. \n 数据库连接相关信息转换成配置\n3. \n 数据库SQL映射需要添加@Mapper被容器识别到\n4. \n MySQL 8.X驱动强制要求设置时区\n <ul>\n  4. 修改url，添加serverTimezone设定\n  4. 修改MySQL数据库配置\n </ul>\n7. \n 驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver\n\n#### JC-3-3.整合MyBatis-Plus\n\n 做完了两种技术的整合了，各位小伙伴要学会总结，我们做这个整合究竟哪些是核心？总结下来就两句话\n\n- \n 导入对应技术的starter坐标\n- \n 根据对应技术的要求做配置\n 虽然看起来有点虚，但是确实是这个理儿，下面趁热打铁，再换一个技术，看看是不是上面这两步。\n\n 接下来在MyBatis的基础上再升级一下，整合MyBaitsPlus（简称MP），国人开发的技术，符合中国人开发习惯，谁用谁知道。来吧，一起做整合\n\n**步骤①**：导入对应的starter\n\n```java\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.4.3</version>\n</dependency>\n```\n\n 关于这个坐标，此处要说明一点，之前我们看的starter都是spring-boot-starter-？？？，也就是说都是下面的格式\n\n```java\nSpring-boot-start-***\n```\n\n 而MyBatis与MyBatisPlus这两个坐标的名字书写比较特殊，是第三方技术名称在前，boot和starter在后。此处简单提一下命名规范，后期原理篇会再详细讲解\n\n\n温馨提示\n\n 有些小伙伴在创建项目时想通过勾选的形式找到这个名字，别翻了，没有。截止目前，SpringBoot官网还未收录此坐标，而我们Idea创建模块时读取的是SpringBoot官网的Spring Initializr，所以也没有。如果换用阿里云的url创建项目可以找到对应的坐标。\n\n**步骤②**：配置数据源相关信息\n\n```java\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db\n    username: root\n    password: root\n```\n\n 没了，就这么多，剩下的就是写MyBaitsPlus的程序了\n\n**映射接口（Dao）**\n\n```java\n@Mapper\npublic interface BookDao extends BaseMapper<Book> {\n}\n```\n\n\n 核心在于Dao接口继承了一个BaseMapper的接口，这个接口中帮助开发者预定了若干个常用的API接口，简化了通用API接口的开发工作。![img](https://img-blog.csdnimg.cn/img_convert/33ec18f5389c702531b591db27bdc4c4.png#pic_center)\n\n 下面就可以写一个测试类进行测试了，此处省略。\n\n温馨提示\n\n 目前数据库的表名定义规则是tbl_模块名称，为了能和实体类相对应，需要做一个配置，相关知识各位小伙伴可以到MyBatisPlus课程中去学习，此处仅给出解决方案。配置application.yml文件，添加如下配置即可，设置所有表名的通用前缀名\n\n```java\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\t\t#设置所有表的通用前缀名称为tbl_\n```\n\n**总结**\n\n1. 手工添加MyBatis-Plus对应的starter\n2. 数据层接口使用BaseMapper简化开发\n3. 需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标\n\n#### JC-3-4.整合Druid\n\n 使用SpringBoot整合了3个技术了，发现套路基本相同，导入对应的starter，然后做配置，各位小伙伴需要一直强化这套思想。下面再整合一个技术，继续深入强化此思想。\n\n 前面整合MyBatis和MyBatisPlus的时候，使用的数据源对象都是SpringBoot默认的数据源对象，下面我们手工控制一下，自己指定了一个数据源对象，Druid。\n\n 在没有指定数据源时，我们的配置如下：\n\n```java\n#2.配置相关信息\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai\n    username: root\n    password: root\n```\n\n 此时虽然没有指定数据源，但是根据SpringBoot的德行，肯定帮我们选了一个它认为最好的数据源对象，这就是HiKari。通过启动日志可以查看到对应的身影。\n\n```java\n2021-11-29 09:39:15.202  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2021-11-29 09:39:15.208  WARN 12260 --- [           main] com.zaxxer.hikari.util.DriverDataSource  : Registered driver with driverClassName=com.mysql.jdbc.Driver was not found, trying direct instantiation.\n2021-11-29 09:39:15.551  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n```\n\n 上述信息中每一行都有HiKari的身影，如果需要更换数据源，其实只需要两步即可。\n\n1. \n 导入对应的技术坐标\n2. \n 配置使用指定的数据源类型\n 下面就切换一下数据源对象\n\n**步骤①**：导入对应的坐标（注意，是坐标，此处不是starter）\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid</artifactId>\n        <version>1.1.16</version>\n    </dependency>\n</dependencies>\n```\n\n**步骤②**：修改配置，在数据源配置中有一个type属性，专用于指定数据源类型\n\n```java\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n    username: root\n    password: root\n    type: com.alibaba.druid.pool.DruidDataSource\n```\n\n 这里其实要提出一个问题的，目前的数据源配置格式是一个通用格式，不管你换什么数据源都可以用这种形式进行配置。但是新的问题又来了，如果对数据源进行个性化的配置，例如配置数据源对应的连接数量，这个时候就有新的问题了。每个数据源技术对应的配置名称都一样吗？肯定不是啊，各个厂商不可能提前商量好都写一样的名字啊，怎么办？就要使用专用的配置格式了。这个时候上面这种通用格式就不能使用了，怎么办？还能怎么办？按照SpringBoot整合其他技术的通用规则来套啊，导入对应的starter，进行相应的配置即可。\n\n**步骤①**：导入对应的starter\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid-spring-boot-starter</artifactId>\n        <version>1.2.6</version>\n    </dependency>\n</dependencies>\n```\n\n**步骤②**：修改配置\n\n```java\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      username: root\n      password: root\n```\n\n\n 注意观察，配置项中，在datasource下面并不是直接配置url这些属性的，而是先配置了一个druid节点，然后再配置的url这些东西。言外之意，url这个属性是druid下面的属性，那你能想到什么？除了这4个常规配置外，还有druid专用的其他配置。通过提示功能可以打开druid相关的配置查阅![img](https://img-blog.csdnimg.cn/img_convert/967443b7a5ac9dab3a770bc3417962f6.png#pic_center)\n\n 与druid相关的配置超过200条以上，这就告诉你，如果想做druid相关的配置，使用这种格式就可以了，这里就不展开描述了，太多了。\n\n 这是我们做的第4个技术的整合方案，还是那两句话：导入对应starter，使用对应配置。没了，SpringBoot整合其他技术就这么简单粗暴。\n\n**总结**\n\n1. 整合Druid需要导入Druid对应的starter\n2. 根据Druid提供的配置方式进行配置\n3. 整合第三方技术通用方式 \n <ul>\n  3. 导入对应的starter\n  3. 根据提供的配置格式，配置非默认值对应的配置项\n </ul>\n\n#### JC-3-5.SSMP整合综合案例\n\n SpringBoot能够整合的技术太多太多了，对于初学者来说慢慢来，一点点掌握。前面咱们做了4个整合了，下面就通过一个稍微综合一点的案例，将所有知识贯穿起来，同时做一个小功能，体会一下。不过有言在先，这个案例制作的时候，你可能会有这种感觉，说好的SpringBoot整合其他技术的案例，为什么感觉SpringBoot整合其他技术的身影不多呢？因为这东西书写太简单了，简单到瞬间写完，大量的时间做的不是这些整合工作。\n\n 先看一下这个案例的最终效果\n\n**主页面**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/6a2532d7228fc96d787c23ebfc1b613c.png)\n\n**添加**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/a86b927f34dd3b51e148aeddac4f0028.png)\n\n**删除**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/2f36476e0cf9ace796d08f1709c9b30e.png)\n\n**修改**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/86af396235f9e111ef26ecc00f712472.png)\n\n**分页**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/f4f0e244e3d89967e17fdffc747c525a.png)\n\n**条件查询**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/e889e5750f6dabae4c9d45fc067a27cc.png)\n\n 整体案例中需要采用的技术如下，先了解一下，做到哪一个说哪一个\n\n1. 实体类开发————使用Lombok快速制作实体类\n2. Dao开发————整合MyBatisPlus，制作数据层测试\n3. Service开发————基于MyBatisPlus进行增量开发，制作业务层测试类\n4. Controller开发————基于Restful开发，使用PostMan测试接口功能\n5. Controller开发————前后端开发协议制作\n6. 页面开发————基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理 \n <ul>\n  6. 列表\n  6. 新增\n  6. 修改\n  6. 删除\n  6. 分页\n  6. 查询\n </ul>\n13. 项目异常处理\n14. 按条件查询————页面功能调整、Controller修正功能、Service修正功能\n\n 可以看的出来，东西还是很多的，希望通过这个案例，各位小伙伴能够完成基础开发的技能训练。整体开发过程采用做一层测一层的形式进行，过程完整，战线较长，希望各位能跟紧进度，完成这个小案例的制作。\n\n##### 0.模块创建\n\n\n 对于这个案例如果按照企业开发的形式进行应该制作后台微服务，前后端分离的开发。![img](https://img-blog.csdnimg.cn/img_convert/636a231121a637ca14c348a1f54522ce.png#pic_center)\n\n\n 我知道这个对初学的小伙伴要求太高了，咱们简化一下。后台做单体服务器，前端不使用前后端分离的制作了。![img](https://img-blog.csdnimg.cn/img_convert/3ecaa5ec8e8b206a03d3dadebc7b6ef5.png#pic_center)\n\n 一个服务器即充当后台服务调用，又负责前端页面展示，降低学习的门槛。\n\n 下面我们创建一个新的模块，加载要使用的技术对应的starter，修改配置文件格式为yml格式，并把web访问端口先设置成80。\n\n**pom.xml**\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n**application.yml**\n\n```java\nserver:\n  port: 80\n```\n\n##### 1.实体类开发\n\n 本案例对应的模块表结构如下：\n\n```java\n-- ----------------------------\n-- Table structure for tbl_book\n-- ----------------------------\nDROP TABLE IF EXISTS `tbl_book`;\nCREATE TABLE `tbl_book`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `type` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of tbl_book\n-- ----------------------------\nINSERT INTO `tbl_book` VALUES (1, '计算机理论', 'Spring实战 第5版', 'Spring入门经典教程，深入理解Spring原理技术内幕');\nINSERT INTO `tbl_book` VALUES (2, '计算机理论', 'Spring 5核心原理与30个类手写实战', '十年沉淀之作，手写Spring精华思想');\nINSERT INTO `tbl_book` VALUES (3, '计算机理论', 'Spring 5 设计模式', '深入Spring源码剖析Spring源码中蕴含的10大设计模式');\nINSERT INTO `tbl_book` VALUES (4, '计算机理论', 'Spring MVC+MyBatis开发从入门到项目实战', '全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手');\nINSERT INTO `tbl_book` VALUES (5, '计算机理论', '轻量级Java Web企业应用实战', '源码级剖析Spring框架，适合已掌握Java基础的读者');\nINSERT INTO `tbl_book` VALUES (6, '计算机理论', 'Java核心技术 卷I 基础知识（原书第11版）', 'Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新');\nINSERT INTO `tbl_book` VALUES (7, '计算机理论', '深入理解Java虚拟机', '5个维度全面剖析JVM，大厂面试知识点全覆盖');\nINSERT INTO `tbl_book` VALUES (8, '计算机理论', 'Java编程思想（第4版）', 'Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉');\nINSERT INTO `tbl_book` VALUES (9, '计算机理论', '零基础学Java（全彩版）', '零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术');\nINSERT INTO `tbl_book` VALUES (10, '市场营销', '直播就该这么做：主播高效沟通实战指南', '李子柒、李佳琦、薇娅成长为网红的秘密都在书中');\nINSERT INTO `tbl_book` VALUES (11, '市场营销', '直播销讲实战一本通', '和秋叶一起学系列网络营销书籍');\nINSERT INTO `tbl_book` VALUES (12, '市场营销', '直播带货：淘宝、天猫直播从新手到高手', '一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+');\n```\n\n 根据上述表结构，制作对应的实体类\n\n**实体类**\n\n```java\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n```\n\n 实体类的开发可以自动通过工具手工生成get/set方法，然后覆盖toString()方法，方便调试，等等。不过这一套操作书写很繁琐，有对应的工具可以帮助我们简化开发，介绍一个小工具，lombok。\n\n Lombok，一个Java类库，提供了一组注解，简化POJO实体类开发，SpringBoot目前默认集成了lombok技术，并提供了对应的版本控制，所以只需要提供对应的坐标即可，在pom.xml中添加lombok的坐标。\n\n```java\n<dependencies>\n    <!--lombok-->\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n</dependencies>\n```\n\n 使用lombok可以通过一个注解@Data完成一个实体类对应的getter，setter，toString，equals，hashCode等操作的快速添加\n\n```java\nimport lombok.Data;\n@Data\npublic class Book {\n    private Integer id;\n    private String type;\n    private String name;\n    private String description;\n}\n```\n\n 到这里实体类就做好了，是不是比不使用lombok简化好多，这种工具在Java开发中还有N多，后面遇到了能用的实用开发技术时，在不增加各位小伙伴大量的学习时间的情况下，尽量多给大家介绍一些。\n\n**总结**\n\n1. 实体类制作\n2. 使用lombok简化开发 \n <ul>\n  2. 导入lombok无需指定版本，由SpringBoot提供版本\n  2. @Data注解\n </ul>\n\n##### 2.数据层开发——基础CRUD\n\n 数据层开发本次使用MyBatisPlus技术，数据源使用前面学习的Druid，学都学了都用上。\n\n**步骤①**：导入MyBatisPlus与Druid对应的starter，当然mysql的驱动不能少\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus-boot-starter</artifactId>\n        <version>3.4.3</version>\n    </dependency>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid-spring-boot-starter</artifactId>\n        <version>1.2.6</version>\n    </dependency>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n</dependencies>\n```\n\n**步骤②**：配置数据库连接相关的数据源配置\n\n```java\nserver:\n  port: 80\n\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      username: root\n      password: root\n```\n\n**步骤③**：使用MyBatisPlus的标准通用接口BaseMapper加速开发，别忘了@Mapper和泛型的指定\n\n```java\n@Mapper\npublic interface BookDao extends BaseMapper<Book> {\n}\n```\n\n**步骤④**：制作测试类测试结果，这个测试类制作是个好习惯，不过在企业开发中往往都为加速开发跳过此步，且行且珍惜吧\n\n```java\npackage com.itheima.dao;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.core.metadata.IPage;\nimport com.baomidou.mybatisplus.extension.plugins.pagination.Page;\nimport com.itheima.domain.Book;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\npublic class BookDaoTestCase {\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Test\n    void testGetById(){\n        System.out.println(bookDao.selectById(1));\n    }\n\n    @Test\n    void testSave(){\n        Book book = new Book();\n        book.setType(\"测试数据123\");\n        book.setName(\"测试数据123\");\n        book.setDescription(\"测试数据123\");\n        bookDao.insert(book);\n    }\n\n    @Test\n    void testUpdate(){\n        Book book = new Book();\n        book.setId(17);\n        book.setType(\"测试数据abcdefg\");\n        book.setName(\"测试数据123\");\n        book.setDescription(\"测试数据123\");\n        bookDao.updateById(book);\n    }\n\n    @Test\n    void testDelete(){\n        bookDao.deleteById(16);\n    }\n\n    @Test\n    void testGetAll(){\n        bookDao.selectList(null);\n    }\n}\n```\n\n温馨提示\n\n MyBatisPlus技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，和目前的数据库设定规则不相符，需要配置一下使MyBatisPlus使用数据库的主键生成策略，方式嘛还是老一套，做配置。在application.yml中添加对应配置即可，具体如下\n\n```java\nserver:\n  port: 80\n\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC\n      username: root\n      password: root\n\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\t\t#设置表名通用前缀\n      id-type: auto\t\t\t\t#设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增\n```\n\n\n 在进行数据层测试的时候，因为基础的CRUD操作均由MyBatisPlus给我们提供了，所以就出现了一个局面，开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你开发出来的，所以查看执行期运行的SQL语句就成为当务之急。\n\n SpringBoot整合MyBatisPlus的时候充分考虑到了这点，通过配置的形式就可以查阅执行期SQL语句，配置如下\n\n```java\nmybatis-plus:\n  global-config:\n    db-config:\n      table-prefix: tbl_\n      id-type: auto\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n```\n\n 再来看运行结果，此时就显示了运行期执行SQL的情况。\n\n```java\nCreating a new SqlSession\nSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2c9a6717] was not registered for synchronization because synchronization is not active\nJDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6ca30b8a] will not be managed by Spring\n==>  Preparing: SELECT id,type,name,description FROM tbl_book\n==> Parameters: \n<==    Columns: id, type, name, description\n<==        Row: 1, 计算机理论, Spring实战 第5版, Spring入门经典教程，深入理解Spring原理技术内幕\n<==        Row: 2, 计算机理论, Spring 5核心原理与30个类手写实战, 十年沉淀之作，手写Spring精华思想\n<==        Row: 3, 计算机理论, Spring 5 设计模式, 深入Spring源码剖析Spring源码中蕴含的10大设计模式\n<==        Row: 4, 计算机理论, Spring MVC+MyBatis开发从入门到项目实战, 全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手\n<==        Row: 5, 计算机理论, 轻量级Java Web企业应用实战, 源码级剖析Spring框架，适合已掌握Java基础的读者\n<==        Row: 6, 计算机理论, Java核心技术 卷I 基础知识（原书第11版）, Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新\n<==        Row: 7, 计算机理论, 深入理解Java虚拟机, 5个维度全面剖析JVM，大厂面试知识点全覆盖\n<==        Row: 8, 计算机理论, Java编程思想（第4版）, Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉\n<==        Row: 9, 计算机理论, 零基础学Java（全彩版）, 零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术\n<==        Row: 10, 市场营销, 直播就该这么做：主播高效沟通实战指南, 李子柒、李佳琦、薇娅成长为网红的秘密都在书中\n<==        Row: 11, 市场营销, 直播销讲实战一本通, 和秋叶一起学系列网络营销书籍\n<==        Row: 12, 市场营销, 直播带货：淘宝、天猫直播从新手到高手, 一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+\n<==        Row: 13, 测试类型, 测试数据, 测试描述数据\n<==        Row: 14, 测试数据update, 测试数据update, 测试数据update\n<==        Row: 15, -----------------, 测试数据123, 测试数据123\n<==      Total: 15\n```\n\n 其中清晰的标注了当前执行的SQL语句是什么，携带了什么参数，对应的执行结果是什么，所有信息应有尽有。\n\n\n 此处设置的是日志的显示形式，当前配置的是控制台输出，当然还可以由更多的选择，根据需求切换即可![img](https://img-blog.csdnimg.cn/img_convert/f17fe08371d4dccfb53d136c7c229d43.png#pic_center)\n\n**总结**\n\n1. \n 手工导入starter坐标（2个），mysql驱动（1个）\n2. \n 配置数据源与MyBatisPlus对应的配置\n3. \n 开发Dao接口（继承BaseMapper）\n4. \n 制作测试类测试Dao功能是否有效\n5. \n 使用配置方式开启日志，设置日志输出方式为标准输出即可查阅SQL执行日志\n\n##### 3.数据层开发——分页功能制作\n\n 前面仅仅是使用了MyBatisPlus提供的基础CRUD功能，实际上MyBatisPlus给我们提供了几乎所有的基础操作，这一节说一下如何实现数据库端的分页操作。\n\n MyBatisPlus提供的分页操作API如下：\n\n```java\n@Test\nvoid testGetPage(){\n    IPage page = new Page(2,5);\n    bookDao.selectPage(page, null);\n    System.out.println(page.getCurrent());\n    System.out.println(page.getSize());\n    System.out.println(page.getTotal());\n    System.out.println(page.getPages());\n    System.out.println(page.getRecords());\n}\n```\n\n 其中selectPage方法需要传入一个封装分页数据的对象，可以通过new的形式创建这个对象，当然这个对象也是MyBatisPlus提供的，别选错包了。创建此对象时需要指定两个分页的基本数据\n\n- 当前显示第几页\n- 每页显示几条数据\n\n 可以通过创建Page对象时利用构造方法初始化这两个数据。\n\n```java\nIPage page = new Page(2,5);\n```\n\n 将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象，这又是怎么回事？\n\n```java\nIPage page = bookDao.selectPage(page, null);\n```\n\n 原来这个IPage对象中封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装，一个IPage描述了分页所有的信息。下面5个操作就是IPage对象中封装的所有信息了。\n\n```java\n@Test\nvoid testGetPage(){\n    IPage page = new Page(2,5);\n    bookDao.selectPage(page, null);\n    System.out.println(page.getCurrent());\t\t//当前页码值\n    System.out.println(page.getSize());\t\t\t//每页显示数\n    System.out.println(page.getTotal());\t\t//数据总量\n    System.out.println(page.getPages());\t\t//总页数\n    System.out.println(page.getRecords());\t\t//详细数据\n}\n```\n\n 到这里就知道这些数据如何获取了，但是当你去执行这个操作时，你会发现并不像我们分析的这样，实际上这个分页功能当前是无效的。为什么这样呢？这个要源于MyBatisPlus的内部机制。\n\n 对于MySQL的分页操作使用limit关键字进行，而并不是所有的数据库都使用limit关键字实现的，这个时候MyBatisPlus为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，你可以理解为IPhone6与IPhone6S-PLUS的关系。\n\n 基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MyBatisPlus将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过MyBatisPlus的拦截器的形式存在的，其中的原理这里不分析了，有兴趣的小伙伴可以学习MyBatisPlus这门课程进行详细解读。具体设置方式如下：\n\n**定义MyBatisPlus拦截器并将其设置为Spring管控的bean**\n\n```java\n@Configuration\npublic class MPConfig {\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor(){\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());\n        return interceptor;\n    }\n}\n```\n\n 上述代码第一行是创建MyBatisPlus的拦截器栈，这个时候拦截器栈中没有具体的拦截器，第二行是初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。\n\n**总结**\n\n1. 使用IPage封装分页数据\n2. 分页操作依赖MyBatisPlus分页拦截器实现功能\n3. 借助MyBatisPlus日志查阅执行SQL语句\n\n##### 4.数据层开发——条件查询功能制作\n\n 除了分页功能，MyBatisPlus还提供有强大的条件查询功能。以往我们写条件查询要自己动态拼写复杂的SQL语句，现在简单了，MyBatisPlus将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种条件的拼装。这里给大家普及一下基本格式，详细的操作还是到MyBatisPlus的课程中查阅吧。\n\n 下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用。\n\n```java\n@Test\nvoid testGetBy(){\n    QueryWrapper<Book> qw = new QueryWrapper<>();\n    qw.like(\"name\",\"Spring\");\n    bookDao.selectList(qw);\n}\n```\n\n 其中第一句QueryWrapper对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。第二句就是一个条件了，需要什么条件，使用QueryWapper对象直接调用对应操作即可。比如做大于小于关系，就可以使用lt或gt方法，等于使用eq方法，等等，此处不做更多的解释了。\n\n 这组API使用还是比较简单的，但是关于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。\n\n MyBatisPlus针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为LambdaQueryWrapper对象，这下就避免了上述问题的出现。\n\n```java\n@Test\nvoid testGetBy2(){\n    String name = \"1\";\n    LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();\n    lqw.like(Book::getName,name);\n    bookDao.selectList(lqw);\n}\n```\n\n 为了便于开发者动态拼写SQL，防止将null数据作为条件使用，MyBatisPlus还提供了动态拼装SQL的快捷书写方式。\n\n```java\n@Test\nvoid testGetBy2(){\n    String name = \"1\";\n    LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();\n    //if(name != null) lqw.like(Book::getName,name);\t\t//方式一：JAVA代码控制\n    lqw.like(name != null,Book::getName,name);\t\t\t\t//方式二：API接口提供控制开关\n    bookDao.selectList(lqw);\n}\n```\n\n 其实就是个格式，没有区别。关于MyBatisPlus的基础操作就说到这里吧，如果这一块知识不太熟悉的小伙伴建议还是完整的学习一下MyBatisPlus的知识吧，这里只是蜻蜓点水的用了几个操作而已。\n\n**总结**\n\n1. \n 使用QueryWrapper对象封装查询条件\n2. \n 推荐使用LambdaQueryWrapper对象\n3. \n 所有查询操作封装成方法调用\n4. \n 查询条件支持动态条件拼装\n\n##### 5.业务层开发\n\n 数据层开发告一段落，下面进行业务层开发，其实标准业务层开发很多初学者认为就是调用数据层，怎么说呢？这个理解是没有大问题的，更精准的说法应该是组织业务逻辑功能，并根据业务需求，对数据持久层发起调用。有什么差别呢？目标是为了组织出符合需求的业务逻辑功能，至于调不调用数据层还真不好说，有需求就调用，没有需求就不调用。\n\n 一个常识性的知识普及一下，业务层的方法名定义一定要与业务有关，例如登录操作\n\n```java\nlogin(String username,String password);\n```\n\n 而数据层的方法名定义一定与业务无关，是一定，不是可能，也不是有可能，例如根据用户名密码查询\n\n```java\nselectByUserNameAndPassword(String username,String password);\n```\n\n 我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的\n\n```java\n接口：传入用户名与密码字段，查询出对应结果，结果是单条数据\n接口：传入ID字段，查询出对应结果，结果是单条数据\n接口：传入离职字段，查询出对应结果，结果是多条数据\n```\n\n 但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大\n\n```java\n接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对密码字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO_LOGON_USERNAME_PASSWORD_ERROR\n```\n\n 你比较一下，能是一回事吗？差别太大了，所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的ISO标准化文档而已。\n\n 多余的话不说了，咱们做案例就简单制作了，业务层接口定义如下：\n\n```java\npublic interface BookService {\n    Boolean save(Book book);\n    Boolean update(Book book);\n    Boolean delete(Integer id);\n    Book getById(Integer id);\n    List<Book> getAll();\n    IPage<Book> getPage(int currentPage,int pageSize);\n}\n```\n\n 业务层实现类如下，转调数据层即可：\n\n```java\n@Service\npublic class BookServiceImpl implements BookService {\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Override\n    public Boolean save(Book book) {\n        return bookDao.insert(book) > 0;\n    }\n\n    @Override\n    public Boolean update(Book book) {\n        return bookDao.updateById(book) > 0;\n    }\n\n    @Override\n    public Boolean delete(Integer id) {\n        return bookDao.deleteById(id) > 0;\n    }\n\n    @Override\n    public Book getById(Integer id) {\n        return bookDao.selectById(id);\n    }\n\n    @Override\n    public List<Book> getAll() {\n        return bookDao.selectList(null);\n    }\n\n    @Override\n    public IPage<Book> getPage(int currentPage, int pageSize) {\n        IPage page = new Page(currentPage,pageSize);\n        bookDao.selectPage(page,null);\n        return page;\n    }\n}\n```\n\n 别忘了对业务层接口进行测试，测试类如下：\n\n```java\n@SpringBootTest\npublic class BookServiceTest {\n    @Autowired\n    private IBookService bookService;\n\n    @Test\n    void testGetById(){\n        System.out.println(bookService.getById(4));\n    }\n    @Test\n    void testSave(){\n        Book book = new Book();\n        book.setType(\"测试数据123\");\n        book.setName(\"测试数据123\");\n        book.setDescription(\"测试数据123\");\n        bookService.save(book);\n    }\n    @Test\n    void testUpdate(){\n        Book book = new Book();\n        book.setId(17);\n        book.setType(\"-----------------\");\n        book.setName(\"测试数据123\");\n        book.setDescription(\"测试数据123\");\n        bookService.updateById(book);\n    }\n    @Test\n    void testDelete(){\n        bookService.removeById(18);\n    }\n\n    @Test\n    void testGetAll(){\n        bookService.list();\n    }\n\n    @Test\n    void testGetPage(){\n        IPage<Book> page = new Page<Book>(2,5);\n        bookService.page(page);\n        System.out.println(page.getCurrent());\n        System.out.println(page.getSize());\n        System.out.println(page.getTotal());\n        System.out.println(page.getPages());\n        System.out.println(page.getRecords());\n    }\n\n}\n```\n\n**总结**\n\n1. Service接口名称定义成业务名称，并与Dao接口名称进行区分\n2. 制作测试类测试Service功能是否有效\n\n\n 其实MyBatisPlus技术不仅提供了数据层快速开发方案，业务层MyBatisPlus也给了一个通用接口，个人观点不推荐使用，凑合能用吧，其实就是一个封装+继承的思想，代码给出，实际开发慎用。\n\n 业务层接口快速开发\n\n```java\npublic interface IBookService extends IService<Book> {\n    //添加非通用操作API接口\n}\n```\n\n 业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类。\n\n```java\n@Service\npublic class BookServiceImpl extends ServiceImpl<BookDao, Book> implements IBookService {\n    @Autowired\n    private BookDao bookDao;\n\t//添加非通用操作API\n}\n```\n\n 如果感觉MyBatisPlus提供的功能不足以支撑你的使用需要（其实是一定不能支撑的，因为需求不可能是通用的），在原始接口基础上接着定义新的API接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的API接口名冲突即可。\n\n**总结**\n\n1. 使用通用接口（ISerivce）快速开发Service\n2. 使用通用实现类（ServiceImpl&lt;M,T&gt;）快速开发ServiceImpl\n3. 可以在通用接口基础上做功能重载或功能追加\n4. 注意重载时不要覆盖原始操作，避免原始提供的功能丢失\n\n##### 6.表现层开发\n\n 终于做到表现层了，做了这么多都是基础工作。其实你现在回头看看，哪里还有什么SpringBoot的影子？前面1,2步就搞完了。继续完成表现层制作吧，咱们表现层的开发使用基于Restful的表现层接口开发，功能测试通过Postman工具进行。\n\n 表现层接口如下:\n\n```java\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController2 {\n\n    @Autowired\n    private IBookService bookService;\n\n    @GetMapping\n    public List<Book> getAll(){\n        return bookService.list();\n    }\n\n    @PostMapping\n    public Boolean save(@RequestBody Book book){\n        return bookService.save(book);\n    }\n\n    @PutMapping\n    public Boolean update(@RequestBody Book book){\n        return bookService.modify(book);\n    }\n\n    @DeleteMapping(\"{id}\")\n    public Boolean delete(@PathVariable Integer id){\n        return bookService.delete(id);\n    }\n\n    @GetMapping(\"{id}\")\n    public Book getById(@PathVariable Integer id){\n        return bookService.getById(id);\n    }\n\n    @GetMapping(\"{currentPage}/{pageSize}\")\n    public IPage<Book> getPage(@PathVariable int currentPage,@PathVariable int pageSize){\n        return bookService.getPage(currentPage,pageSize, null);\n    }\n}\n```\n\n 在使用Postman测试时关注提交类型，对应上即可，不然就会报405的错误码了。\n\n**普通GET请求**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/2161f1f89d9f5a0cbd02cf27977aa70d.png)\n\n**PUT请求传递json数据，后台实用@RequestBody接收数据**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/7be8a8a1d332148f008acde3cfebae5e.png)\n\n**GET请求传递路径变量，后台实用@PathVariable接收数据**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/fdd86530490602fb31a3919e5137a8fe.png)\n\n**总结**\n\n1. 基于Restful制作表现层接口 \n <ul>\n  1. 新增：POST\n  1. 删除：DELETE\n  1. 修改：PUT\n  1. 查询：GET\n </ul>\n6. 接收参数 \n <ul>\n  6. 实体数据：@RequestBody\n  6. 路径变量：@PathVariable\n </ul>\n\n##### 7.表现层消息一致性处理\n\n 目前我们通过Postman测试后业务层接口功能是通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重。\n\n **增删改操作结果**\n\n```java\ntrue\n```\n\n **查询单个数据操作结果**\n\n```java\n{\n    \"id\": 1,\n    \"type\": \"计算机理论\",\n    \"name\": \"Spring实战 第5版\",\n    \"description\": \"Spring入门经典教程\"\n}\n```\n\n **查询全部数据操作结果**\n\n```java\n[\n    {\n        \"id\": 1,\n        \"type\": \"计算机理论\",\n        \"name\": \"Spring实战 第5版\",\n        \"description\": \"Spring入门经典教程\"\n    },\n    {\n        \"id\": 2,\n        \"type\": \"计算机理论\",\n        \"name\": \"Spring 5核心原理与30个类手写实战\",\n        \"description\": \"十年沉淀之作\"\n    }\n]\n```\n\n 每种不同操作返回的数据格式都不一样，而且还不知道以后还会有什么格式，这样的结果让前端人员看了是很容易让人崩溃的，必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为**前后端数据协议**\n\n```java\n@Data\npublic class R {\n    private Boolean flag;\n    private Object data;\n}\n```\n\n 其中flag用于标识操作是否成功，data用于封装操作数据，现在的数据格式就变了\n\n```java\n{\n    \"flag\": true,\n    \"data\":{\n        \"id\": 1,\n        \"type\": \"计算机理论\",\n        \"name\": \"Spring实战 第5版\",\n        \"description\": \"Spring入门经典教程\"\n    }\n}\n```\n\n\n\n\n 表现层开发格式也需要转换一下![img](https://img-blog.csdnimg.cn/img_convert/d55f3e66e2856cf858993621a10a9ec4.png#pic_center)![img](https://img-blog.csdnimg.cn/img_convert/16bc5780f6291ad69c335f1de3f679af.png#pic_center)![img](https://img-blog.csdnimg.cn/img_convert/1ea36e38b70822d8b3e09474dec95ff9.png#pic_center)\n\n 结果这么一折腾，全格式统一，现在后端发送给前端的数据格式就统一了，免去了不少前端解析数据的烦恼。\n\n**总结**\n\n1. \n 设计统一的返回值结果类型便于前端开发读取数据\n2. \n 返回值结果类型可以根据需求自行设定，没有固定格式\n3. \n 返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议\n\n##### 8.前后端联通性测试\n\n 后端的表现层接口开发完毕，就可以进行前端的开发了。\n\n\n 将前端人员开发的页面保存到lresources目录下的static目录中，建议执行maven的clean生命周期，避免缓存的问题出现。![img](https://img-blog.csdnimg.cn/img_convert/fd4c4bace56393f94ea3a1aaf66a7bdc.png#pic_center)\n\n 在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发。\n\n```java\n//列表\ngetAll() {\n\taxios.get(\"/books\").then((res)=>{\n\t\tconsole.log(res.data);\n\t});\n},\n```\n\n 只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，也就可以进行下一步的功能开发了。\n\n**总结**\n\n1. 单体项目中页面放置在resources/static目录下\n2. created钩子函数用于初始化页面时发起调用\n3. 页面使用axios发送异步请求获取数据后确认前后端是否联通\n\n##### 9.页面基础功能开发\n\n\n 列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用VUE的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可。\n\n **页面数据模型定义**\n\n```java\ndata:{\n\tdataList: [],\t\t//当前页要展示的列表数据\n\t...\n},\n```\n\n 异步请求获取数据\n\n```java\n//列表\ngetAll() {\n    axios.get(\"/books\").then((res)=>{\n        this.dataList = res.data.data;\n    });\n},\n```\n\n 这样在页面加载时就可以获取到数据，并且由VUE将数据展示到页面上了。\n\n总结：\n\n1. 将查询数据返回到页面，利用前端数据绑定进行数据展示\n\n\n 添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可。\n\n **默认状态**\n\n```java\ndata:{\n\tdialogFormVisible: false,\t//添加表单是否可见\n\t...\n},\n```\n\n **切换为显示状态**\n\n```java\n//弹出添加窗口\nhandleCreate() {\n\tthis.dialogFormVisible = true;\n},\n```\n\n 由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹。\n\n **定义清理数据操作**\n\n```java\n//重置表单\nresetForm() {\n    this.formData = {};\n},\n```\n\n **切换弹窗状态时清理数据**\n\n```java\n//弹出添加窗口\nhandleCreate() {\n    this.dialogFormVisible = true;\n    this.resetForm();\n},\n```\n\n 至此准备工作完成，下面就要调用后台完成添加操作了。\n\n **添加操作**\n\n```java\n//添加\nhandleAdd () {\n    //发送异步请求\n    axios.post(\"/books\",this.formData).then((res)=>{\n        //如果操作成功，关闭弹层，显示数据\n        if(res.data.flag){\n            this.dialogFormVisible = false;\n            this.$message.success(\"添加成功\");\n        }else {\n            this.$message.error(\"添加失败\");\n        }\n    }).finally(()=>{\n        this.getAll();\n    });\n},\n```\n\n1. 将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台\n2. 根据返回的操作结果决定下一步操作 \n <ul>\n  2. 如何是true就关闭添加窗口，显示添加成功的消息\n  2. 如果是false保留添加窗口，显示添加失败的消息\n </ul>\n5. 无论添加是否成功，页面均进行刷新，动态加载数据（对getAll操作发起调用）\n\n **取消添加操作**\n\n```java\n//取消\ncancel(){\n    this.dialogFormVisible = false;\n    this.$message.info(\"操作取消\");\n},\n```\n\n**总结**\n\n1. 请求方式使用POST调用后台对应操作\n2. 添加操作结束后动态刷新页面加载数据\n3. 根据操作结果不同，显示对应的提示信息\n4. 弹出添加Div时清除表单数据\n\n\n 模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可。\n\n **删除操作**\n\n```java\n// 删除\nhandleDelete(row) {\n    axios.delete(\"/books/\"+row.id).then((res)=>{\n        if(res.data.flag){\n            this.$message.success(\"删除成功\");\n        }else{\n            this.$message.error(\"删除失败\");\n        }\n    }).finally(()=>{\n        this.getAll();\n    });\n},\n```\n\n **删除操作提示信息**\n\n```java\n// 删除\nhandleDelete(row) {\n    //1.弹出提示框\n    this.$confirm(\"此操作永久删除当前数据，是否继续？\",\"提示\",{\n        type:'info'\n    }).then(()=>{\n        //2.做删除业务\n        axios.delete(\"/books/\"+row.id).then((res)=>{\n       \t\tif(res.data.flag){\n            \tthis.$message.success(\"删除成功\");\n        \t}else{\n            \tthis.$message.error(\"删除失败\");\n        \t}\n        }).finally(()=>{\n            this.getAll();\n        });\n    }).catch(()=>{\n        //3.取消删除\n        this.$message.info(\"取消删除操作\");\n    });\n}，\n```\n\n**总结**\n\n1. 请求方式使用Delete调用后台对应操作\n2. 删除操作需要传递当前行数据对应的id值到后台\n3. 删除操作结束后动态刷新页面加载数据\n4. 根据操作结果不同，显示对应的提示信息\n5. 删除操作前弹出提示框避免误操作\n\n\n 修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：\n\n1. \n 页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗\n2. \n 弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据\n3. \n 查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台\n4. \n 查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据\n5. \n 修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据\n 所以整体上来看，修改功能就是前面几个功能的大合体\n 查询并展示数据\n\n```java\n//弹出编辑窗口\nhandleUpdate(row) {\n    axios.get(\"/books/\"+row.id).then((res)=>{\n        if(res.data.flag){\n            //展示弹层，加载数据\n            this.formData = res.data.data;\n            this.dialogFormVisible4Edit = true;\n        }else{\n            this.$message.error(\"数据同步失败，自动刷新\");\n        }\n    });\n},\n```\n\n **修改操作**\n\n```java\n//修改\nhandleEdit() {\n    axios.put(\"/books\",this.formData).then((res)=>{\n        //如果操作成功，关闭弹层并刷新页面\n        if(res.data.flag){\n            this.dialogFormVisible4Edit = false;\n            this.$message.success(\"修改成功\");\n        }else {\n            this.$message.error(\"修改失败，请重试\");\n        }\n    }).finally(()=>{\n        this.getAll();\n    });\n},\n```\n\n**总结**\n\n1. 加载要修改数据通过传递当前行数据对应的id值到后台查询数据（同删除与查询全部）\n2. 利用前端双向数据绑定将查询到的数据进行回显（同查询全部）\n3. 请求方式使用PUT调用后台对应操作（同新增传递数据）\n4. 修改操作结束后动态刷新页面加载数据（同新增）\n5. 根据操作结果不同，显示对应的提示信息（同新增）\n\n\n\n##### 10.业务消息一致性处理\n\n 目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出BUG，如果我们搞一个BUG出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子。\n\n```java\n{\n    \"timestamp\": \"2021-09-15T03:27:31.038+00:00\",\n    \"status\": 500,\n    \"error\": \"Internal Server Error\",\n    \"path\": \"/books\"\n}\n```\n\n 面对这种情况，前端的同学又不会了，这又是什么格式？怎么和之前的格式不一样？\n\n```java\n{\n    \"flag\": true,\n    \"data\":{\n        \"id\": 1,\n        \"type\": \"计算机理论\",\n        \"name\": \"Spring实战 第5版\",\n        \"description\": \"Spring入门经典教程\"\n    }\n}\n```\n\n 看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理。\n\n 首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息。\n\n```java\n@Data\npublic class R{\n    private Boolean flag;\n    private Object data;\n    private String msg;\t\t//用于封装消息\n}\n```\n\n 后台代码也要根据情况做处理，当前是模拟的错误。\n\n```java\n@PostMapping\npublic R save(@RequestBody Book book) throws IOException {\n    Boolean flag = bookService.insert(book);\n    return new R(flag , flag ? \"添加成功^_^\" : \"添加失败-_-!\");\n}\n```\n\n 然后在表现层做统一的异常处理，使用SpringMVC提供的异常处理器做统一的异常处理。\n\n```java\n@RestControllerAdvice\npublic class ProjectExceptionAdvice {\n    @ExceptionHandler(Exception.class)\n    public R doOtherException(Exception ex){\n        //记录日志\n        //发送消息给运维\n        //发送邮件给开发人员,ex对象发送给开发人员\n        ex.printStackTrace();\n        return new R(false,null,\"系统错误，请稍后再试！\");\n    }\n}\n```\n\n 页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果false，就读取后台传递的消息。\n\n```java\n//添加\nhandleAdd () {\n\t//发送ajax请求\n    axios.post(\"/books\",this.formData).then((res)=>{\n        //如果操作成功，关闭弹层，显示数据\n        if(res.data.flag){\n            this.dialogFormVisible = false;\n            this.$message.success(\"添加成功\");\n        }else {\n            this.$message.error(res.data.msg);\t\t\t//消息来自于后台传递过来，而非固定内容\n        }\n    }).finally(()=>{\n        this.getAll();\n    });\n},\n```\n\n**总结**\n\n1. 使用注解@RestControllerAdvice定义SpringMVC异常处理器用来处理异常的\n2. 异常处理器必须被扫描加载，否则无法生效\n3. 表现层返回结果的模型类中添加消息属性用来传递消息到页面\n\n\n\n##### 11.页面功能开发\n\n\n 分页功能的制作用于替换前面的查询全部，其中要使用到elementUI提供的分页组件。\n\n```java\n<!--分页组件-->\n<div class=\"pagination-container\">\n    <el-pagination\n\t\tclass=\"pagiantion\"\n\t\t@current-change=\"handleCurrentChange\"\n\t\t:current-page=\"pagination.currentPage\"\n\t\t:page-size=\"pagination.pageSize\"\n\t\tlayout=\"total, prev, pager, next, jumper\"\n\t\t:total=\"pagination.total\">\n    </el-pagination>\n</div>\n```\n\n 为了配合分页组件，封装分页对应的数据模型。\n\n```java\ndata:{\n\tpagination: {\t\n\t\t//分页相关模型数据\n\t\tcurrentPage: 1,\t//当前页码\n\t\tpageSize:10,\t//每页显示的记录数\n\t\ttotal:0,\t\t//总记录数\n\t}\n},\n```\n\n 修改查询全部功能为分页查询，通过路径变量传递页码信息参数。\n\n```java\ngetAll() {\n    axios.get(\"/books/\"+this.pagination.currentPage+\"/\"+this.pagination.pageSize).then((res) => {\n    });\n},\n```\n\n 后台提供对应的分页功能。\n\n```java\n@GetMapping(\"/{currentPage}/{pageSize}\")\npublic R getAll(@PathVariable Integer currentPage,@PathVariable Integer pageSize){\n    IPage<Book> pageBook = bookService.getPage(currentPage, pageSize);\n    return new R(null != pageBook ,pageBook);\n}\n```\n\n 页面根据分页操作结果读取对应数据，并进行数据模型绑定。\n\n```java\ngetAll() {\n    axios.get(\"/books/\"+this.pagination.currentPage+\"/\"+this.pagination.pageSize).then((res) => {\n        this.pagination.total = res.data.data.total;\n        this.pagination.currentPage = res.data.data.current;\n        this.pagination.pagesize = res.data.data.size;\n        this.dataList = res.data.data.records;\n    });\n},\n```\n\n 对切换页码操作设置调用当前分页操作。\n\n```java\n//切换页码\nhandleCurrentChange(currentPage) {\n    this.pagination.currentPage = currentPage;\n    this.getAll();\n},\n```\n\n**总结**\n\n1. 使用el分页组件\n2. 定义分页组件绑定的数据模型\n3. 异步调用获取分页数据\n4. 分页数据页面回显\n\n\n 由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现BUG，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案。\n\n```java\n@GetMapping(\"{currentPage}/{pageSize}\")\npublic R getPage(@PathVariable int currentPage,@PathVariable int pageSize){\n    IPage<Book> page = bookService.getPage(currentPage, pageSize);\n    //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值\n    if( currentPage > page.getPages()){\n        page = bookService.getPage((int)page.getPages(), pageSize);\n    }\n    return new R(true, page);\n}\n```\n\n\n 最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了\n\n- \n 页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递2个分页相关数据转换成2个分页数据加若干个条件\n- \n 后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是null，现在换成具体条件，差别不大\n- \n 查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略\n 经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别。\n 页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递。\n 页面封装查询条件字段\n pagination: {\t\t\n//分页相关模型数据\n\tcurrentPage: 1,\t\t//当前页码\n\tpageSize:10,\t\t//每页显示的记录数\n\ttotal:0,\t\t\t//总记录数\n\tname: \"\",\n\ttype: \"\",\n\tdescription: \"\"\n},\n 页面添加查询条件字段对应的数据模型绑定名称\n <div class=\"filter-container\">\n    <el-input placeholder=\"图书类别\" v-model=\"pagination.type\" class=\"filter-item\"/>\n    <el-input placeholder=\"图书名称\" v-model=\"pagination.name\" class=\"filter-item\"/>\n    <el-input placeholder=\"图书描述\" v-model=\"pagination.description\" class=\"filter-item\"/>\n    <el-button @click=\"getAll()\" class=\"dalfBut\">查询</el-button>\n    <el-button type=\"primary\" class=\"butT\" @click=\"handleCreate()\">新建</el-button>\n</div>\n 将查询条件组织成url参数，添加到请求url地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求\n getAll() {\n    //1.获取查询条件,拼接查询条件\n    param = \"?name=\"+this.pagination.name;\n    param += \"&type=\"+this.pagination.type;\n    param += \"&description=\"+this.pagination.description;\n    console.log(\"-----------------\"+ param);\n    axios.get(\"/books/\"+this.pagination.currentPage+\"/\"+this.pagination.pageSize+param).then((res) => {\n        this.dataList = res.data.data.records;\n    });\n},\n 后台代码中定义实体类封查询条件\n @GetMapping(\"{currentPage}/{pageSize}\")\npublic R getAll(@PathVariable int currentPage,@PathVariable int pageSize,Book book) {\n    System.out.println(\"参数=====>\"+book);\n    IPage<Book> pageBook = bookService.getPage(currentPage,pageSize);\n    return new R(null != pageBook ,pageBook);\n}\n 对应业务层接口与实现类进行修正\n public interface IBookService extends IService<Book> {\n    IPage<Book> getPage(Integer currentPage,Integer pageSize,Book queryBook);\n}\n @Service\npublic class BookServiceImpl2 extends ServiceImpl<BookDao,Book> implements IBookService {\n    public IPage<Book> getPage(Integer currentPage,Integer pageSize,Book queryBook){\n        IPage page = new Page(currentPage,pageSize);\n        LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();\n        lqw.like(Strings.isNotEmpty(queryBook.getName()),Book::getName,queryBook.getName());\n        lqw.like(Strings.isNotEmpty(queryBook.getType()),Book::getType,queryBook.getType());\n        lqw.like(Strings.isNotEmpty(queryBook.getDescription()),Book::getDescription,queryBook.getDescription());\n        return bookDao.selectPage(page,lqw);\n    }\n}\n 页面回显数据\n getAll() {\n    //1.获取查询条件,拼接查询条件\n    param = \"?name=\"+this.pagination.name;\n    param += \"&type=\"+this.pagination.type;\n    param += \"&description=\"+this.pagination.description;\n    console.log(\"-----------------\"+ param);\n    axios.get(\"/books/\"+this.pagination.currentPage+\"/\"+this.pagination.pageSize+param).then((res) => {\n        this.pagination.total = res.data.data.total;\n        this.pagination.currentPage = res.data.data.current;\n        this.pagination.pagesize = res.data.data.size;\n        this.dataList = res.data.data.records;\n    });\n},\n\n**总结**\n\n1. 定义查询条件数据模型（当前封装到分页数据模型中）\n2. 异步调用分页功能并通过请求参数传递数据到后台\n\n### 基础篇完结\n\n 基础篇到这里就全部结束了，在基础篇中带着大家学习了如何创建一个SpringBoot工程，然后学习了SpringBoot的基础配置语法格式，接下来对常见的市面上的实用技术做了整合，最后通过一个小的案例对前面学习的内容做了一个综合应用。整体来说就是一个最基本的入门，关于SpringBoot的实际开发其实接触的还是很少的，我们到实用篇和原理篇中继续吧，各位小伙伴，加油学习，再见。\n\n","tags":["springboot","java","开发语言","mybatis","spring","后端"]},{"title":"springboot最全，最完整，最适合小白教程（原理篇）","url":"/2023/08/21/springboot最全，最完整，最适合小白教程（原理篇）/","content":"\n\n>本文章为黑马的springboot教程的教学文档，具体视频内容移步至bilibili 黑马程序员官方账号<br>\n 教程分为基础篇，运维实用篇，开发实用篇，原理篇\n\n基础篇： [springboot 基础篇](http://t.csdn.cn/yvD99)\n 运维实用篇 ： [springboot 运维实用篇](http://t.csdn.cn/7DPBB)\n 开发实用篇： [springboot 开发实用篇](http://t.csdn.cn/ZHmPq)\n 原理篇： [springboot 原理篇](http://t.csdn.cn/TMiLt)\n\n## SpringBoot原理篇\n\n 在学习前面三篇的时候，好多小伙伴一直在B站评论区嚷嚷着期待原理篇，今天可以正式的宣布了，他来了他来了他脚踏祥云进来了（此处请自行脑补BGM）。\n\n 其实从本人的角度出发，看了这么多学习java的小伙伴的学习过程，个人观点，不建议小伙伴过早的去研究技术的原理。原因有二：一，**先应用熟练**，**培养技术应用的条件反射**，然后再学原理。大把的学习者天天还纠结于这里少写一个这，那里少写一个那，程序都跑不下去，要啥原理，要啥自行车。这里要说一句啊，懂不懂啥意思那不叫原理，原理是抽象到顶层设计层面的东西。知道为什么写这句话，知道错误的原因和懂原理是两码事。二， **原理真不是看源码**，源码只能称作原理的落地实现方式，当好的落地实现方式出现后，就会有新旧版本的迭代，底层实现方式也会伴随着更新升级。但是原理不变，只是找到了更好的实现最初目标的路径。一个好的课程，一位好的老师，不会用若干行云里雾里的源代码把学习者带到沟里，然后爬不出来，深陷泥潭。一边沮丧的看着源码，一边舔着老师奉其为大神，这就叫不干人事。原理就应该使用最通俗易懂的语言，把设计思想讲出来，至于看源码，只是因为目前的技术原创人员只想到了当前这种最笨的设计方案，还没有更好的。比如spirng程序，写起来很费劲，springboot出来以后就简单轻松了很多，实现方案变了，原理不变。但凡你想通过下面的课程学习去读懂若干行代码，然后特别装逼的告诉自己，我懂原理了。我只能告诉你，你选了一条成本最高的路线，看源码仅仅是验证原理，源码仅对应程序流程，不对应原理。原理是思想级的，不是代码级的，原理是原本的道理。\n\n springboot技术本身就是为了加速spring程序的开发的，可以大胆的说，springboot技术没有自己的原理层面的设计，仅仅是实现方案进行了改进。将springboot定位成工具，你就不会去想方设法的学习其原理了。就像是将木头分割成若干份，我们可以用斧子，用锯子，用刀，用火烧或者一脚踹断它，这些都是方式方法，而究其本质底层原理是植物纤维的组织方式，研究完这个，你再看前述的各种工具，都是基于这个原理在说如何变更破坏这种植物纤维的方式。所以不要一张嘴说了若干种技术，然后告诉自己，这就是spirngboot的原理。没有的事，springboot作为一款工具，压根就没有原理。我们下面要学习的其实就是spirngboot程序的工作流程。\n\n 下面就开始学习原理篇，因为没有想出来特别好的名字，所以还是先称作原理篇吧。原理篇中包含如下内容：\n\n- 自动配置工作流程\n- 自定义starter开发\n- springboot程序启动流程\n\n 下面开启第一部分自动配置工作流程的学习\n\n### YL-1.自动配置工作流程\n\n 自动配置是springboot技术非常好用的核心因素，前面学习了这么多种技术的整合，每一个都离不开自动配置。不过在学习自动配置的时候，需要你对spring容器如何进行bean管理的过程非常熟悉才行，所以这里需要先复习一下有关spring技术中bean加载相关的知识。方式方法很多，逐一快速复习一下，查漏补缺。不过这里需要声明一点，这里列出的bean的加载方式仅仅应用于后面课程的学习，并不是所有的spring加载bean的方式。跟着我的步伐一种一种的复习，他们这些方案之间有千丝万缕的关系，顺着看完，你就懂自动配置是怎么回事了。\n\n#### YL-1-1.bean的加载方式\n\n 关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式。已知类并交给spring管理，和已知类名并交给spring管理。有什么区别？一个给.class，一个给类名字符串。内部其实都一样，都是通过spring的BeanDefinition对象初始化spring的bean。如果前面这句话看起来有障碍，可以去复习一下spring的相关知识。B站中有我尊敬的满一航老师录制的spring高级课程，链接地址如下，欢迎大家捧场，记得一键三连哦。\n\n```java\nhttps://www.bilibili.com/video/BV1P44y1N7QG\n```\n\n##### 方式一：配置文件+<bean/>标签\n\n 最高端的食材往往只需要最简单的烹饪方法，搞错了，再来。最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。所以第一种方式就是给出bean的类名，至于内部嘛就是反射机制加载成class，然后，就没有然后了，拿到了class你就可以搞定一切了。如果这句话听不太懂，请这些小盆友转战java基础高级部分复习一下反射相关知识。\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <!--xml方式声明自己开发的bean-->\n    <bean id=\"cat\" class=\"Cat\"/>\n    <bean class=\"Dog\"/>\n\n    <!--xml方式声明第三方开发的bean-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"/>\n    <bean class=\"com.alibaba.druid.pool.DruidDataSource\"/>\n    <bean class=\"com.alibaba.druid.pool.DruidDataSource\"/>\n</beans>\n```\n\n##### 方式二：配置文件扫描+注解定义bean\n\n 由于方式一种需要将spring管控的bean全部写在xml文件中，对于程序员来说非常不友好，所以就有了第二种方式。哪一个类要受到spring管控加载成bean，就在这个类的上面加一个注解，还可以顺带起一个bean的名字（id）。这里可以使用的注解有@Component以及三个衍生注解@Service、@Controller、@Repository。\n\n```java\n@Component(\"tom\")\npublic class Cat {\n}\n```\n\n```java\n@Service\npublic class Mouse {\n}\n```\n\n 当然，由于我们无法在第三方提供的技术源代码中去添加上述4个注解，因此当你需要加载第三方开发的bean的时候可以使用下列方式定义注解式的bean。@Bean定义在一个方法上方，当前方法的返回值就可以交给spring管控，记得这个方法所在的类一定要定义在@Component修饰的类中，有人会说不是@Configuration吗？建议把spring注解开发相关课程学习一下，就不会有这个疑问了。\n\n```java\n@Component\npublic class DbConfig {\n    @Bean\n    public DruidDataSource dataSource(){\n        DruidDataSource ds = new DruidDataSource();\n        return ds;\n    }\n}\n```\n\n 上面提供的仅仅是bean的声明，spring并没有感知到这些东西，像极了上课积极回答问题的你，手举的非常高，可惜老师都没有往你的方向看上一眼。想让spring感知到这些积极的小伙伴，必须设置spring去检查这些类，看他们是否贴标签，想当积极分子。可以通过下列xml配置设置spring去检查哪些包，发现定了对应注解，就将对应的类纳入spring管控范围，声明成bean。\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n    \">\n    <!--指定扫描加载bean的位置-->\n    <context:component-scan base-package=\"com.itheima.bean,com.itheima.config\"/>\n</beans>\n```\n\n 方式二声明bean的方式是目前企业中较为常见的bean的声明方式，但是也有缺点。方式一中，通过一个配置文件，你可以查阅当前spring环境中定义了多少个或者说多少种bean，但是方式二没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个bean。\n\n##### 方式三：注解方式声明配置类\n\n 方式二已经完美的简化了bean的声明，以后再也不用写茫茫多的配置信息了。仔细观察xml配置文件，会发现这个文件中只剩了扫描包这句话，于是就有人提出，使用java类替换掉这种固定格式的配置，所以下面这种格式就出现了。严格意义上讲不能算全新的方式，但是由于此种开发形式是企业级开发中的主流形式，所以单独独立出来做成一种方式。嗯……，怎么说呢？方式二和方式三其实差别还是挺大的，番外篇找个时间再聊吧。\n\n 定义一个类并使用@ComponentScan替代原始xml配置中的包扫描这个动作，其实功能基本相同。为什么说基本，还是有差别的。先卖个关子吧，番外篇再聊。\n\n```java\n@ComponentScan({\"com.itheima.bean\",\"com.itheima.config\"})\npublic class SpringConfig3 {\n    @Bean\n    public DogFactoryBean dog(){\n        return new DogFactoryBean();\n    }\n}\n```\n\n\n 补充一个小知识，spring提供了一个接口FactoryBean，也可以用于声明bean，只不过实现了FactoryBean接口的类造出来的对象不是当前类的对象，而是FactoryBean接口泛型指定类型的对象。如下列，造出来的bean并不是DogFactoryBean，而是Dog。有什么用呢？可以在对象初始化前做一些事情，下例中的注释位置就是让你自己去扩展要做的其他事情的。\n\n```java\npublic class DogFactoryBean implements FactoryBean<Dog> {\n    @Override\n    public Dog getObject() throws Exception {\n        Dog d = new Dog();\n        //.........\n        return d;\n    }\n    @Override\n    public Class<?> getObjectType() {\n        return Dog.class;\n    }\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n```\n\n 有人说，注释中的代码写入Dog的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为Dog是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果写入Dog，或许初始化动作A当前并不能满足你的需要，这个时候你就要做一个DogB的方案了。然后，就没有然后了，你就要做两个Dog类。当时使用FactoryBean接口就可以完美解决这个问题。\n\n 通常实现了FactoryBean接口的类使用@Bean的形式进行加载，当然你也可以使用@Component去声明DogFactoryBean，只要被扫描加载到即可，但是这种格式加载总觉得怪怪的，指向性不是很明确。\n\n```java\n@ComponentScan({\"com.itheima.bean\",\"com.itheima.config\"})\npublic class SpringConfig3 {\n    @Bean\n    public DogFactoryBean dog(){\n        return new DogFactoryBean();\n    }\n}\n```\n\n\n 再补充一个小知识，由于早起开发的系统大部分都是采用xml的形式配置bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发的用注解格式，之前开发的是xml格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring提供了一个注解可以解决这个问题，@ImportResource，在配置类上直接写上要被融合的xml配置文件名即可，算的上一种兼容性解决方案，没啥实际意义。\n\n```java\n@Configuration\n@ImportResource(\"applicationContext1.xml\")\npublic class SpringConfig32 {\n}\n```\n\n\n 前面的例子中用到了@Configuration这个注解，当我们使用AnnotationConfigApplicationContext加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的bean的唯一性。为@Configuration注解设置proxyBeanMethods属性值为true即可，由于此属性默认值为true，所以很少看见明确书写的，除非想放弃此功能。\n\n```java\n@Configuration(proxyBeanMethods = true)\npublic class SpringConfig33 {\n    @Bean\n    public Cat cat(){\n        return new Cat();\n    }\n}\n```\n\n 下面通过容器再调用上面的cat方法时，得到的就是同一个对象了。注意，必须使用spring容器对象调用此方法才有保持bean唯一性的特性。此特性在很多底层源码中有应用，前面讲MQ时，也应用了此特性，只不过当前没有解释而已。这里算是填个坑吧。\n\n```java\npublic class App33 {\n    public static void main(String[] args) {\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig33.class);\n        String[] names = ctx.getBeanDefinitionNames();\n        for (String name : names) {\n            System.out.println(name);\n        }\n        System.out.println(\"-------------------------\");\n        SpringConfig33 springConfig33 = ctx.getBean(\"springConfig33\", SpringConfig33.class);\n        System.out.println(springConfig33.cat());\n        System.out.println(springConfig33.cat());\n        System.out.println(springConfig33.cat());\n    }\n}\n```\n\n##### 方式四：使用@Import注解注入bean\n\n 使用扫描的方式加载bean是企业级开发中常见的bean的加载方式，但是由于扫描的时候不仅可以加载到你要的东西，还有可能加载到各种各样的乱七八糟的东西，万一没有控制好得不偿失了。\n\n 有人就会奇怪，会有什么问题呢？比如你扫描了com.itheima.service包，后来因为业务需要，又扫描了com.itheima.dao包，你发现com.itheima包下面只有service和dao这两个包，这就简单了，直接扫描com.itheima就行了。但是万万没想到，十天后你加入了一个外部依赖包，里面也有com.itheima包，这下就热闹了，该来的不该来的全来了。\n\n 所以我们需要一种精准制导的加载方式，使用@Import注解就可以解决你的问题。它可以加载所有的一切，只需要在注解的参数中写上加载的类对应的.class即可。有人就会觉得，还要自己手写，多麻烦，不如扫描好用。对呀，但是他可以指定加载啊，好的命名规范配合@ComponentScan可以解决很多问题，但是@Import注解拥有其重要的应用场景。有没有想过假如你要加载的bean没有使用@Component修饰呢？这下就无解了，而@Import就无需考虑这个问题。\n\n```java\n@Import({Dog.class,DbConfig.class})\npublic class SpringConfig4 {\n}\n```\n\n\n 除了加载bean，还可以使用@Import注解加载配置类。其实本质上是一样的，不解释太多了。\n\n```java\n@Import(DogFactoryBean.class)\npublic class SpringConfig4 {\n}\n```\n\n##### 方式五：编程形式注册bean\n\n 前面介绍的加载bean的方式都是在容器启动阶段完成bean的加载，下面这种方式就比较特殊了，可以在容器初始化完成后手动加载bean。通过这种方式可以实现编程式控制bean的加载。\n\n```java\npublic class App5 {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n        //上下文容器对象已经初始化完毕后，手工加载bean\n        ctx.register(Mouse.class);\n    }\n}\n```\n\n 其实这种方式坑还是挺多的，比如容器中已经有了某种类型的bean，再加载会不会覆盖呢？这都是要思考和关注的问题。新手慎用。\n\n```java\npublic class App5 {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n        //上下文容器对象已经初始化完毕后，手工加载bean\n        ctx.registerBean(\"tom\", Cat.class,0);\n        ctx.registerBean(\"tom\", Cat.class,1);\n        ctx.registerBean(\"tom\", Cat.class,2);\n        System.out.println(ctx.getBean(Cat.class));\n    }\n}\n```\n\n##### 方式六：导入实现了ImportSelector接口的类\n\n 在方式五种，我们感受了bean的加载可以进行编程化的控制，添加if语句就可以实现bean的加载控制了。但是毕竟是在容器初始化后实现bean的加载控制，那是否可以在容器初始化过程中进行控制呢？答案是必须的。实现ImportSelector接口的类可以设置加载的bean的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。\n\n 现在又多了一种控制bean加载的方式，或者说是选择bean的方式。\n\n```java\npublic class MyImportSelector implements ImportSelector {\n    @Override\n    public String[] selectImports(AnnotationMetadata metadata) {\n        //各种条件的判定，判定完毕后，决定是否装载指定的bean\n        boolean flag = metadata.hasAnnotation(\"org.springframework.context.annotation.Configuration\");\n        if(flag){\n            return new String[]{\"com.itheima.bean.Dog\"};\n        }\n        return new String[]{\"com.itheima.bean.Cat\"};\n    }\n}\n```\n\n##### 方式七：导入实现了ImportBeanDefinitionRegistrar接口的类\n\n 方式六中提供了给定类全路径类名控制bean加载的形式，如果对spring的bean的加载原理比较熟悉的小伙伴知道，其实bean的加载不是一个简简单单的对象，spring中定义了一个叫做BeanDefinition的东西，它才是控制bean初始化加载的核心。BeanDefinition接口中给出了若干种方法，可以控制bean的相关属性。说个最简单的，创建的对象是单例还是非单例，在BeanDefinition中定义了scope属性就可以控制这个。如果你感觉方式六没有给你开放出足够的对bean的控制操作，那么方式七你值得拥有。我们可以通过定义一个类，然后实现ImportBeanDefinitionRegistrar接口的方式定义bean，并且还可以让你对bean的初始化进行更加细粒度的控制，不过对于新手并不是很友好。忽然给你开放了若干个操作，还真不知道如何下手。\n\n```java\npublic class MyRegistrar implements ImportBeanDefinitionRegistrar {\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n        BeanDefinition beanDefinition = \t\n            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();\n        registry.registerBeanDefinition(\"bookService\",beanDefinition);\n    }\n}\n```\n\n##### 方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类\n\n 上述七种方式都是在容器初始化过程中进行bean的加载或者声明，但是这里有一个bug。这么多种方式，它们之间如果有冲突怎么办？谁能有最终裁定权？这是个好问题，当某种类型的bean被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你还真不知道最后谁说了算。即便你理清楚了，保不齐和你一起开发的猪队友又添加了一个bean，得嘞，这下就热闹了。\n\n spring挥舞它仲裁者的大刀来了一个致命一击，都别哔哔了，我说了算，BeanDefinitionRegistryPostProcessor，看名字知道，BeanDefinition意思是bean定义，Registry注册的意思，Post后置，Processor处理器，全称bean定义后处理器，干啥的？在所有bean注册都折腾完后，它把最后一道关，说白了，它说了算，这下消停了，它是最后一个运行的。\n\n```java\npublic class MyPostProcessor implements BeanDefinitionRegistryPostProcessor {\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        BeanDefinition beanDefinition = \n            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();\n        registry.registerBeanDefinition(\"bookService\",beanDefinition);\n    }\n}\n```\n\n 总体上来说，上面介绍了各种各样的bean的注册加载初始化方式，脑子里建立个概念吧，方式很多，spring源码中大量运用各种方式。复习的内容就先说到这里。\n\n**总结**\n\n1. bean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean\n2. @Import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@Bean相关的定义，会被一同加载\n3. spring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean\n\n#### YL-1-2.bean的加载控制\n\n 前面复习bean的加载时，提出了有关加载控制的方式，其中手工注册bean，ImportSelector接口，ImportBeanDefinitionRegistrar接口，BeanDefinitionRegistryPostProcessor接口都可以控制bean的加载，这一节就来说说这些加载控制。\n\n 企业级开发中不可能在spring容器中进行bean的饱和式加载的。什么是饱和式加载，就是不管用不用，全部加载。比如jdk中有两万个类，那就加载两万个bean，显然是不合理的，因为你压根就不会使用其中大部分的bean。那合理的加载方式是什么？肯定是必要性加载，就是用什么加载什么。继续思考，加载哪些bean通常受什么影响呢？最容易想的就是你要用什么技术，就加载对应的bean。用什么技术意味着什么？就是加载对应技术的类。所以在spring容器中，通过判定是否加载了某个类来控制某些bean的加载是一种常见操作。下例给出了对应的代码实现，其实思想很简单，先判断一个类的全路径名是否能够成功加载，加载成功说明有这个类，那就干某项具体的工作，否则就干别的工作。\n\n```java\npublic class MyImportSelector implements ImportSelector {\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n        try {\n            Class<?> clazz = Class.forName(\"com.itheima.bean.Mouse\");\n            if(clazz != null) {\n                return new String[]{\"com.itheima.bean.Cat\"};\n            }\n        } catch (ClassNotFoundException e) {\n//            e.printStackTrace();\n            return new String[0];\n        }\n        return null;\n    }\n}\n```\n\n 通过上述的分析，可以看到此类操作将成为企业级开发中的常见操作，于是springboot将把这些常用操作给我们做了一次封装。这种逻辑判定你开发者就别搞了，我springboot信不过你这种新手开发者，我给你封装一下，做几个注解，你填参数吧，耶，happy。\n\n 下例使用@ConditionalOnClass注解实现了当虚拟机中加载了com.itheima.bean.Wolf类时加载对应的bean。比较一下上面的代码和下面的代码，有没有感觉很清爽。其实此类注解还有很多。\n\n```java\n@Bean\n@ConditionalOnClass(name = \"com.itheima.bean.Wolf\")\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n @ConditionalOnMissingClass注解控制虚拟机中没有加载指定的类才加载对应的bean。\n\n```java\n@Bean\n@ConditionalOnMissingClass(\"com.itheima.bean.Dog\")\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n 这种条件还可以做并且的逻辑关系，写2个就是2个条件都成立，写多个就是多个条件都成立。\n\n```java\n@Bean\n@ConditionalOnClass(name = \"com.itheima.bean.Wolf\")\n@ConditionalOnMissingClass(\"com.itheima.bean.Mouse\")\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n 除了判定是否加载类，还可以对当前容器类型做判定，下例是判定当前容器环境是否是web环境。\n\n```java\n@Bean\n@ConditionalOnWebApplication\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n 下面是判定容器环境是否是非web环境。\n\n```java\n@Bean\n@ConditionalOnNotWebApplication\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n 当然还可以判定是否加载了指定名称的bean，这种有什么用呢？太有用了。比如当前容器中已经提供了jdbcTemplate对应的bean，你还需要再加载一个全新的jdbcTemplate的bean吗？没有必要了嘛。spring说，如果你自己写的话，我就不帮你操这份心了，如果你没写，我再给你提供。自适应，自适应，明白？没有的话就提供给你，有的话就用你自己的，是不是很帅？\n\n```java\n@Bean\n@ConditionalOnBean(name=\"jerry\")\npublic Cat tom(){\n    return new Cat();\n}\n```\n\n 以下就是判定当前是否加载了mysql的驱动类，如果加载了，我就给你搞一个Druid的数据源对象出来，完美！\n\n```java\npublic class SpringConfig {\n    @Bean\n    @ConditionalOnClass(name=\"com.mysql.jdbc.Driver\")\n    public DruidDataSource dataSource(){\n        return new DruidDataSource();\n    }\n}\n```\n\n 其中springboot的bean加载控制注解还有很多，这里就不一一列举了，最常用的判定条件就是根据类是否加载来进行控制。\n\n**总结**\n\n1. springboot定义了若干种控制bean加载的条件设置注解，由spring固定加载bean变成了可以根据情况选择性的加载bean\n\n#### YL-1-3.bean的依赖属性配置管理\n\n bean的加载及加载控制已经搞完了，下面研究一下bean内部的事情。bean在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，这个时候就可以使用前期学习的bean的属性配置相关的知识进行灵活的配置了。先通过yml配置文件，设置bean运行需要使用的配置信息。\n\n```java\ncartoon:\n  cat:\n    name: \"图多盖洛\"\n    age: 5\n  mouse:\n    name: \"泰菲\"\n    age: 1\n```\n\n 然后定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值。\n\n```java\n@ConfigurationProperties(prefix = \"cartoon\")\n@Data\npublic class CartoonProperties {\n    private Cat cat;\n    private Mouse mouse;\n}\n```\n\n 最后在使用的位置注入对应的配置即可。\n\n```java\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse{\n    @Autowired\n    private CartoonProperties cartoonProperties;\n}\n```\n\n 建议在业务类上使用@EnableConfigurationProperties声明bean，这样在不使用这个类的时候，也不会无故加载专用的属性配置类CartoonProperties，减少spring管控的资源数量。\n\n**总结**\n\n1. bean的运行如果需要外部设置值，建议将设置值封装成专用的属性类* * * * Properties\n2. 设置属性类加载指定前缀的配置信息\n3. 在需要使用属性类的位置通过注解@EnableConfigurationProperties加载bean，而不要直接在属性配置类上定义bean，减少资源加载的数量，因需加载而不要饱和式加载。\n\n#### YL-1-4.自动配置原理（工作流程）\n\n 经过前面的知识复习，下面终于进入到了本章核心内容的学习，自动配置原理。原理谈不上，就是自动配置的工作流程。\n\n 啥叫自动配置呢？简单说就是springboot根据我们开发者的行为猜测你要做什么事情，然后把你要用的bean都给你准备好。听上去是不是很神奇？其实非常简单，前面复习的东西都已经讲完了。springboot咋做到的呢？就是看你导入了什么类，就知道你想干什么了。然后把你有可能要用的bean（注意是有可能）都给你加载好，你直接使用就行了，springboot把所需要的一切工作都做完了。\n\n 自动配置的意义就是加速开发效率，将开发者使用某种技术时需要使用的bean根据情况提前加载好，实现自动配置的效果。当然，开发者有可能需要提供必要的参数，比如你要用mysql技术，导入了mysql的坐标，springboot就知道了你要做数据库操作，一系列的数据库操作相关的bean都给你提前声明好，但是你要告诉springboot你到底用哪一个数据库，像什么IP地址啊，端口啊，你不告诉spirngboot，springboot就无法帮你把自动配置相关的工作做完。\n\n 而这种思想其实就是在日常的开发过程中根据开发者的习惯慢慢抽取得到了。整体过程分为2个阶段：\n\n **阶段一：准备阶段**\n\n1. \n springboot的开发人员先大量收集Spring开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成一个技术集A\n2. \n 收集常用技术(技术集A)的使用参数，不管你用什么常用设置，我用什么常用设置，统统收集起来整理一下，得到开发过程中每一个技术的常用设置，形成每一个技术对应的设置集B\n 阶段二：加载阶段\n3. \n springboot初始化Spring容器基础环境，读取用户的配置信息，加载用户自定义的bean和导入的其他坐标，形成初始化环境\n4. \n springboot将技术集A包含的所有技术在SpringBoot启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的\n5. \n springboot会对技术集A中每一个技术约定出启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些bean和其他坐标，也就是与初始化环境，这个时候就可以根据这个初始化环境与springboot的技术集A进行比对了，哪个匹配上加载哪个\n6. \n 因为有些技术不做配置就无法工作，所以springboot开始对设置集B下手了。它统计出各个国家各个行业的开发者使用某个技术时最常用的设置是什么，然后把这些设置作为默认值直接设置好，并告诉开发者当前设置我已经给你搞了一套，你要用可以直接用，这样可以减少开发者配置参数的工作量\n7. \n 但是默认配置不一定能解决问题，于是springboot开放修改设置集B的接口，可以由开发者根据需要决定是否覆盖默认配置\n\n 以上这些仅仅是一个思想，落地到代码实现阶段就要好好思考一下怎么实现了。假定我们想自己实现自动配置的功能，都要做哪些工作呢？\n\n- 首先指定一个技术X，我们打算让技术X具备自动配置的功能，这个技术X可以是任意功能，这个技术隶属于上面描述的**技术集A**\n\n```java\npublic class CartoonCatAndMouse{\n}\n```\n\n- 然后找出技术X使用过程中的常用配置Y，这个配置隶属于上面表述的**设置集B**\n\n```java\ncartoon:\n  cat:\n    name: \"图多盖洛\"\n    age: 5\n  mouse:\n    name: \"泰菲\"\n    age: 1\n```\n\n- 将常用配置Y设计出对应的yml配置书写格式，然后定义一个属性类封装对应的配置属性，这个过程其实就是上一节咱们做的bean的依赖属性管理，一模一样\n\n```java\n@ConfigurationProperties(prefix = \"cartoon\")\n@Data\npublic class CartoonProperties {\n    private Cat cat;\n    private Mouse mouse;\n}\n```\n\n- 最后做一个配置类，当这个类加载的时候就可以初始化对应的功能bean，并且可以加载到对应的配置\n\n```java\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse implements ApplicationContextAware {\n    private CartoonProperties cartoonProperties;\n}\n```\n\n- 当然，你也可以为当前自动配置类设置上激活条件，例如使用@CondtionOn* * * * 为其设置加载条件\n\n```java\n@ConditionalOnClass(name=\"org.springframework.data.redis.core.RedisOperations\")\n@EnableConfigurationProperties(CartoonProperties.class)\npublic class CartoonCatAndMouse implements ApplicationContextAware {\n    private CartoonProperties cartoonProperties;\n}\n```\n\n 做到这里都已经做完了，但是遇到了一个全新的问题，如何让springboot启动的时候去加载这个类呢？如果不加载的话，我们做的条件判定，做的属性加载这些全部都失效了。springboot为我们开放了一个配置入口，在配置目录中创建META-INF目录，并创建spring.factories文件，在其中添加设置，说明哪些类要启动自动配置就可以了。\n\n```java\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.itheima.bean.CartoonCatAndMouse\n```\n\n 其实这个文件就做了一件事，通过这种配置的方式加载了指定的类。转了一圈，就是个普通的bean的加载，和最初使用xml格式加载bean几乎没有区别，格式变了而已。那自动配置的核心究竟是什么呢？自动配置其实是一个小的生态，可以按照如下思想理解：\n\n1. 自动配置从根本上来说就是一个bean的加载\n2. 通过bean加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用，这是蒙蔽我们双眼的第一层面纱\n3. 使用bean的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，感觉这个过程好屌，也是一种自适应的形式，其实还是需要使用分支语句来做判断的，这是蒙蔽我们双眼的第二层面纱\n4. springboot技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，其实就是提前帮我们把spring.factories文件写好了，这是蒙蔽我们双眼的第三层面纱\n\n 你在不知道自动配置这个知识的情况下，经过上面这一二三，你当然觉得自动配置是一种特别牛的技术，但是一窥究竟后发现，也就那么回事。而且现在springboot程序启动时，在后台偷偷的做了这么多次检测，这么多种情况判定，不用问了，效率一定是非常低的，毕竟它要检测100余种技术是否在你程序中使用。\n\n 以上内容是自动配置的工作流程。\n\n**总结**\n\n1. springboot启动时先加载spring.factories文件中的org.springframework.boot.autoconfigure.EnableAutoConfiguration配置项，将其中配置的所有的类都加载成bean\n2. 在加载bean的时候，bean对应的类定义上都设置有加载条件，因此有可能加载成功，也可能条件检测失败不加载bean\n3. 对于可以正常加载成bean的类，通常会通过@EnableConfigurationProperties注解初始化对应的配置属性类并加载对应的配置\n4. 配置属性类上通常会通过@ConfigurationProperties加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须配置后使用了\n\n#### YL-1-5.变更自动配置\n\n 知道了自动配置的执行过程，下面就可以根据这个自动配置的流程做一些高级定制了。例如系统默认会加载100多种自动配置的技术，如果我们先手工干预此工程，禁用自动配置是否可行呢？答案一定是可以的。方式还挺多：\n\n**方式一：通过yaml配置设置排除指定的自动配置类**\n\n```java\nspring:\n  autoconfigure:\n    exclude:\n      - org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration\n```\n\n**方式二：通过注解参数排除自动配置类**\n\n```java\n@EnableAutoConfiguration(excludeName = \"\",exclude = {})\n```\n\n**方式三：排除坐标（应用面较窄）**\n\n如果当前自动配置中包含有更多的自动配置功能，也就是一个套娃的效果。此时可以通过检测条件的控制来管理自动配置是否启动。例如web程序启动时会自动启动tomcat服务器，可以通过排除坐标的方式，让加载tomcat服务器的条件失效。不过需要提醒一点，你把tomcat排除掉，记得再加一种可以运行的服务器。\n\n```java\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件-->\n        <exclusions>\n            <exclusion>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <!--添加Jetty起步依赖，匹配自动配置条件-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-jetty</artifactId>\n    </dependency>\n</dependencies>\n```\n\n**总结**\n\n1. springboot的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能\n\n### YL-2.自定义starter开发\n\n 自动配置学习完后，我们就可以基于自动配置的特性，开发springboot技术中最引以为傲的功能了，starter。其实通过前期学习，我们发现用什么技术直接导入对应的starter，然后就实现了springboot整合对应技术，再加上一些简单的配置，就可以直接使用了。这种设计方式对开发者非常友好，本章就通过一个案例的制作，开发自定义starter来实现自定义功能的快捷添加。\n\n#### YL-2-1.案例：记录系统访客独立IP访问次数\n\n 本案例的功能是统计网站独立IP访问次数的功能，并将访问信息在后台持续输出。整体功能是在后台每10秒输出一次监控信息（格式：IP+访问次数） ，当用户访问网站时，对用户的访问行为进行统计。\n\n 例如：张三访问网站功能15次，IP地址：192.168.0.135，李四访问网站功能20次，IP地址：61.129.65.248。那么在网站后台就输出如下监控信息，此信息每10秒刷新一次。\n\n```java\nIP访问监控\n+-----ip-address-----+--num--+\n|     192.168.0.135  |   15  |\n|     61.129.65.248  |   20  |\n+--------------------+-------+\n```\n\n 在进行具体制作之前，先对功能做具体的分析\n\n1. \n 数据记录在什么位置\n 最终记录的数据是一个字符串（IP地址）对应一个数字（访问次数），此处可以选择的数据存储模型可以使用java提供的map模型，也就是key-value的键值对模型，或者具有key-value键值对模型的存储技术，例如redis技术。本案例使用map作为实现方案，有兴趣的小伙伴可以使用redis作为解决方案。\n2. \n 统计功能运行位置，因为每次web请求都需要进行统计，因此使用拦截器会是比较好的方案，本案例使用拦截器来实现。不过在制作初期，先使用调用的形式进行测试，等功能完成了，再改成拦截器的实现方案。\n3. \n 为了提升统计数据展示的灵活度，为统计功能添加配置项。输出频度，输出的数据格式，统计数据的显示模式均可以通过配置实现调整。\n <ul>\n  3. 输出频度，默认10秒\n  3. 数据特征：累计数据 / 阶段数据，默认累计数据\n  3. 输出格式：详细模式 / 极简模式\n </ul>\n\n 在下面的制作中，分成若干个步骤实现。先完成最基本的统计功能的制作，然后开发出统计报表，接下来把所有的配置都设置好，最后将拦截器功能实现，整体功能就做完了。\n\n#### YL-2-2.IP计数业务功能开发（自定义starter）\n\n 本功能最终要实现的效果是在现有的项目中导入一个starter，对应的功能就添加上了，删除掉对应的starter，功能就消失了，要求功能要与原始项目完全解耦。因此需要开发一个独立的模块，制作对应功能。\n\n**步骤一：创建全新的模块，定义业务功能类**\n\n 功能类的制作并不复杂，定义一个业务类，声明一个Map对象，用于记录ip访问次数，key是ip地址，value是访问次数\n\n```java\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n}\n```\n\n 有些小伙伴可能会有疑问，不设置成静态的，如何在每次请求时进行数据共享呢？记得，当前类加载成bean以后是一个单例对象，对象都是单例的，哪里存在多个对象共享变量的问题。\n\n**步骤二：制作统计功能**\n\n 制作统计操作对应的方法，每次访问后对应ip的记录次数+1。需要分情况处理，如果当前没有对应ip的数据，新增一条数据，否则就修改对应key的值+1即可\n\n```java\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n    public void count(){\n        //每次调用当前操作，就记录当前访问的IP，然后累加访问次数\n        //1.获取当前操作的IP地址\n        String ip = null;\n        //2.根据IP地址从Map取值，并递增\n        Integer count = ipCountMap.get(ip);\n        if(count == null){\n            ipCountMap.put(ip,1);\n        }else{\n            ipCountMap.put(ip,count + 1);\n        }\n    }\n}\n```\n\n 因为当前功能最终导入到其他项目中进行，而导入当前功能的项目是一个web项目，可以从容器中直接获取请求对象，因此获取IP地址的操作可以通过自动装配得到请求对象，然后获取对应的访问IP地址。\n\n```java\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n    @Autowired\n    //当前的request对象的注入工作由使用当前starter的工程提供自动装配\n    private HttpServletRequest httpServletRequest;\n    public void count(){\n        //每次调用当前操作，就记录当前访问的IP，然后累加访问次数\n        //1.获取当前操作的IP地址\n        String ip = httpServletRequest.getRemoteAddr();\n        //2.根据IP地址从Map取值，并递增\n        Integer count = ipCountMap.get(ip);\n        if(count == null){\n            ipCountMap.put(ip,1);\n        }else{\n            ipCountMap.put(ip,count + 1);\n        }\n    }\n}\n```\n\n**步骤三：定义自动配置类**\n\n 我们需要做到的效果是导入当前模块即开启此功能，因此使用自动配置实现功能的自动装载，需要开发自动配置类在启动项目时加载当前功能。\n\n```java\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n```\n\n 自动配置类需要在spring.factories文件中做配置方可自动运行。\n\n```java\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.itcast.autoconfig.IpAutoConfiguration\n```\n\n**步骤四：在原始项目中模拟调用，测试功能**\n\n 原始调用项目中导入当前开发的starter\n\n```java\n<dependency>\n    <groupId>cn.itcast</groupId>\n    <artifactId>ip_spring_boot_starter</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n</dependency>\n```\n\n 推荐选择调用方便的功能做测试，推荐使用分页操作，当然也可以换其他功能位置进行测试。\n\n```java\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController {\n    @Autowired\n    private IpCountService ipCountService;\n    @GetMapping(\"{currentPage}/{pageSize}\")\n    public R getPage(@PathVariable int currentPage,@PathVariable int pageSize,Book book){\n        ipCountService.count();\n        IPage<Book> page = bookService.getPage(currentPage, pageSize,book);\n        if( currentPage > page.getPages()){\n            page = bookService.getPage((int)page.getPages(), pageSize,book);\n        }\n        return new R(true, page);\n    }\n}\n```\n\n温馨提示\n\n 由于当前制作的功能需要在对应的调用位置进行坐标导入，因此必须保障仓库中具有当前开发的功能，所以每次原始代码修改后，需要重新编译并安装到仓库中。为防止问题出现，建议每次安装之前先clean然后install，保障资源进行了更新。切记切记！！\n\n**当前效果**\n\n 每次调用分页操作后，可以在控制台输出当前访问的IP地址，此功能可以在count操作中添加日志或者输出语句进行测试。\n\n#### YL-2-3.定时任务报表开发\n\n 当前已经实现了在业务功能类中记录访问数据，但是还没有输出监控的信息到控制台。由于监控信息需要每10秒输出1次，因此需要使用定时器功能。可以选取第三方技术Quartz实现，也可以选择Spring内置的task来完成此功能，此处选用Spring的task作为实现方案。\n\n**步骤一：开启定时任务功能**\n\n 定时任务功能开启需要在当前功能的总配置中设置，结合现有业务设定，比较合理的位置是设置在自动配置类上。加载自动配置类即启用定时任务功能。\n\n```java\n@EnableScheduling\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n```\n\n**步骤二：制作显示统计数据功能**\n\n 定义显示统计功能的操作print()，并设置定时任务，当前设置每5秒运行一次统计数据。\n\n```java\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n    @Scheduled(cron = \"0/5 * * * * ?\")\n    public void print(){\n        System.out.println(\"         IP访问监控\");\n        System.out.println(\"+-----ip-address-----+--num--+\");\n        for (Map.Entry<String, Integer> entry : ipCountMap.entrySet()) {\n            String key = entry.getKey();\n            Integer value = entry.getValue();\n            System.out.println(String.format(\"|%18s  |%5d  |\",key,value));\n        }\n        System.out.println(\"+--------------------+-------+\");\n      }\n}\n```\n\n 其中关于统计报表的显示信息拼接可以使用各种形式进行，此处使用String类中的格式化字符串操作进行，学习者可以根据自己的喜好调整实现方案。\n\n温馨提示\n\n 每次运行效果之前先clean然后install，切记切记！！\n\n**当前效果**\n\n 每次调用分页操作后，可以在控制台看到统计数据，到此基础功能已经开发完毕。\n\n#### YL-2-4.使用属性配置设置功能参数\n\n 由于当前报表显示的信息格式固定，为提高报表信息显示的灵活性，需要通过yml文件设置参数，控制报表的显示格式。\n\n**步骤一：定义参数格式**\n\n 设置3个属性，分别用来控制显示周期（cycle），阶段数据是否清空（cycleReset），数据显示格式（model）\n\n```java\ntools:\n  ip:\n    cycle: 10\n    cycleReset: false\n    model: \"detail\"\n```\n\n**步骤二：定义封装参数的属性类，读取配置参数**\n\n 为防止项目组定义的参数种类过多，产生冲突，通常设置属性前缀会至少使用两级属性作为前缀进行区分。\n\n 日志输出模式是在若干个类别选项中选择某一项，对于此种分类性数据建议制作枚举定义分类数据，当然使用字符串也可以。\n\n```java\n@ConfigurationProperties(prefix = \"tools.ip\")\npublic class IpProperties {\n    /**\n     * 日志显示周期\n     */\n    private Long cycle = 5L;\n    /**\n     * 是否周期内重置数据\n     */\n    private Boolean cycleReset = false;\n    /**\n     * 日志输出模式  detail：详细模式  simple：极简模式\n     */\n    private String model = LogModel.DETAIL.value;\n    public enum LogModel{\n        DETAIL(\"detail\"),\n        SIMPLE(\"simple\");\n        private String value;\n        LogModel(String value) {\n            this.value = value;\n        }\n        public String getValue() {\n            return value;\n        }\n    }\n}\n```\n\n**步骤三：加载属性类**\n\n```java\n@EnableScheduling\n@EnableConfigurationProperties(IpProperties.class)\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n```\n\n**步骤四：应用配置属性**\n\n 在应用配置属性的功能类中，使用自动装配加载对应的配置bean，然后使用配置信息做分支处理。\n\n 注意：清除数据的功能一定要在输出后运行，否则每次查阅的数据均为空白数据。\n\n```java\npublic class IpCountService {\n    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();\n    @Autowired\n    private IpProperties ipProperties;\n    @Scheduled(cron = \"0/5 * * * * ?\")\n    public void print(){\n        if(ipProperties.getModel().equals(IpProperties.LogModel.DETAIL.getValue())){\n            System.out.println(\"         IP访问监控\");\n            System.out.println(\"+-----ip-address-----+--num--+\");\n            for (Map.Entry<String, Integer> entry : ipCountMap.entrySet()) {\n                String key = entry.getKey();\n                Integer value = entry.getValue();\n                System.out.println(String.format(\"|%18s  |%5d  |\",key,value));\n            }\n            System.out.println(\"+--------------------+-------+\");\n        }else if(ipProperties.getModel().equals(IpProperties.LogModel.SIMPLE.getValue())){\n            System.out.println(\"     IP访问监控\");\n            System.out.println(\"+-----ip-address-----+\");\n            for (String key: ipCountMap.keySet()) {\n                System.out.println(String.format(\"|%18s  |\",key));\n            }\n            System.out.println(\"+--------------------+\");\n        }\n        //阶段内统计数据归零\n        if(ipProperties.getCycleReset()){\n            ipCountMap.clear();\n        }\n    }\n}\n```\n\n温馨提示\n\n 每次运行效果之前先clean然后install，切记切记！！\n\n**当前效果**\n\n 在web程序端可以通过控制yml文件中的配置参数对统计信息进行格式控制。但是数据显示周期还未进行控制。\n\n#### YL-2-5.使用属性配置设置定时器参数\n\n 在使用属性配置中的显示周期数据时，遇到了一些问题。由于无法在@Scheduled注解上直接使用配置数据，改用曲线救国的方针，放弃使用@EnableConfigurationProperties注解对应的功能，改成最原始的bean定义格式。\n\n**步骤一：@Scheduled注解使用#{}读取bean属性值**\n\n 此处读取bean名称为ipProperties的bean的cycle属性值\n\n```java\n@Scheduled(cron = \"0/#{ipProperties.cycle} * * * * ?\")\npublic void print(){\n}\n```\n\n**步骤二：属性类定义bean并指定bean的访问名称**\n\n 如果此处不设置bean的访问名称，spring会使用自己的命名生成器生成bean的长名称，无法实现属性的读取\n\n```java\n@Component(\"ipProperties\")\n@ConfigurationProperties(prefix = \"tools.ip\")\npublic class IpProperties {\n}\n```\n\n**步骤三：弃用@EnableConfigurationProperties注解对应的功能，改为导入bean的形式加载配置属性类**\n\n```java\n@EnableScheduling\n//@EnableConfigurationProperties(IpProperties.class)\n@Import(IpProperties.class)\npublic class IpAutoConfiguration {\n    @Bean\n    public IpCountService ipCountService(){\n        return new IpCountService();\n    }\n}\n```\n\n温馨提示\n\n 每次运行效果之前先clean然后install，切记切记！！\n\n**当前效果**\n\n 在web程序端可以通过控制yml文件中的配置参数对统计信息的显示周期进行控制\n\n#### YL-2-6.拦截器开发\n\n 基础功能基本上已经完成了制作，下面进行拦截器的开发。开发时先在web工程中制作，然后将所有功能挪入starter模块中\n\n**步骤一：开发拦截器**\n\n 使用自动装配加载统计功能的业务类，并在拦截器中调用对应功能\n\n```java\npublic class IpCountInterceptor implements HandlerInterceptor {\n    @Autowired\n    private IpCountService ipCountService;\n    @Override\n    public boolean preHandle(HttpServletRequest request, \n                             HttpServletResponse response, Object handler) throws Exception {\n        ipCountService.count();\n        return true;\n    }\n}\n```\n\n**步骤二：配置拦截器**\n\n 配置mvc拦截器，设置拦截对应的请求路径。此处拦截所有请求，用户可以根据使用需要设置要拦截的请求。甚至可以在此处加载IpCountProperties中的属性，通过配置设置拦截器拦截的请求。\n\n```java\n@Configuration\npublic class SpringMvcConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(ipCountInterceptor()).addPathPatterns(\"/**\");\n    }\n    @Bean\n    public IpCountInterceptor ipCountInterceptor(){\n        return new IpCountInterceptor();\n    }\n}\n```\n\n温馨提示\n\n 每次运行效果之前先clean然后install，切记切记！！\n\n**当前效果**\n\n 在web程序端导入对应的starter后功能开启，去掉坐标后功能消失，实现自定义starter的效果。\n\n 到此当前案例全部完成，自定义stater的开发其实在第一轮开发中就已经完成了，就是创建独立模块导出独立功能，需要使用的位置导入对应的starter即可。如果是在企业中开发，记得不仅需要将开发完成的starter模块install到自己的本地仓库中，开发完毕后还要deploy到私服上，否则别人就无法使用了。\n\n#### YL-2-7.功能性完善——开启yml提示功能\n\n 我们在使用springboot的配置属性时，都可以看到提示，尤其是导入了对应的starter后，也会有对应的提示信息出现。但是现在我们的starter没有对应的提示功能，这种设定就非常的不友好，本节解决自定义starter功能如何开启配置提示的问题。\n\n springboot提供有专用的工具实现此功能，仅需要导入下列坐标。\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n\n 程序编译后，在META-INF目录中会生成对应的提示文件，然后拷贝生成出的文件到自己开发的META-INF目录中，并对其进行编辑。打开生成的文件，可以看到如下信息。其中groups属性定义了当前配置的提示信息总体描述，当前配置属于哪一个属性封装类，properties属性描述了当前配置中每一个属性的具体设置，包含名称、类型、描述、默认值等信息。hints属性默认是空白的，没有进行设置。hints属性可以参考springboot源码中的制作，设置当前属性封装类专用的提示信息，下例中为日志输出模式属性model设置了两种可选提示信息。\n\n```java\n{\n  \"groups\": [\n    {\n      \"name\": \"tools.ip\",\n      \"type\": \"cn.itcast.properties.IpProperties\",\n      \"sourceType\": \"cn.itcast.properties.IpProperties\"\n    }\n  ],\n  \"properties\": [\n    {\n      \"name\": \"tools.ip.cycle\",\n      \"type\": \"java.lang.Long\",\n      \"description\": \"日志显示周期\",\n      \"sourceType\": \"cn.itcast.properties.IpProperties\",\n      \"defaultValue\": 5\n    },\n    {\n      \"name\": \"tools.ip.cycle-reset\",\n      \"type\": \"java.lang.Boolean\",\n      \"description\": \"是否周期内重置数据\",\n      \"sourceType\": \"cn.itcast.properties.IpProperties\",\n      \"defaultValue\": false\n    },\n    {\n      \"name\": \"tools.ip.model\",\n      \"type\": \"java.lang.String\",\n      \"description\": \"日志输出模式  detail：详细模式  simple：极简模式\",\n      \"sourceType\": \"cn.itcast.properties.IpProperties\"\n    }\n  ],\n  \"hints\": [\n    {\n      \"name\": \"tools.ip.model\",\n      \"values\": [\n        {\n          \"value\": \"detail\",\n          \"description\": \"详细模式.\"\n        },\n        {\n          \"value\": \"simple\",\n          \"description\": \"极简模式.\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n**总结**\n\n1. 自定义starter其实就是做一个独立的功能模块，核心技术是利用自动配置的效果在加载模块后加载对应的功能\n2. 通常会为自定义starter的自动配置功能添加足够的条件控制，而不会做成100%加载对功能的效果\n3. 本例中使用map保存数据，如果换用redis方案，在starter开发模块中就要导入redis对应的starter\n4. 对于配置属性务必开启提示功能，否则使用者无法感知配置应该如何书写\n\n### YL-3.SpringBoot程序启动流程解析\n\n 原理篇学习到这里即将结束，最后一章说一下springboot程序的启动流程。对于springboot技术来说，它用于加速spring程序的开发，核心本质还是spring程序的运行，所以于其说是springboot程序的启动流程，不如说是springboot对spring程序的启动流程做了哪些更改。\n\n 其实不管是springboot程序还是spring程序，启动过程本质上都是在做容器的初始化，并将对应的bean初始化出来放入容器。在spring环境中，每个bean的初始化都要开发者自己添加设置，但是切换成springboot程序后，自动配置功能的添加帮助开发者提前预设了很多bean的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得略微复杂，但是核心本质还是在做一件事，初始化容器。作为开发者只要搞清楚springboot提供了哪些参数设置的环节，同时初始化容器的过程中都做了哪些事情就行了。\n\n springboot初始化的参数根据参数的提供方，划分成如下3个大类，每个大类的参数又被封装了各种各样的对象，具体如下：\n\n- 环境属性（Environment）\n- 系统配置（spring.factories）\n- 参数（Arguments、application.properties）\n\n 以下通过代码流向介绍了springboot程序启动时每一环节做的具体事情。\n\n```java\nSpringboot30StartupApplication【10】->SpringApplication.run(Springboot30StartupApplication.class, args);\n    SpringApplication【1332】->return run(new Class<?>[] { primarySource }, args);\n        SpringApplication【1343】->return new SpringApplication(primarySources).run(args);\n            SpringApplication【1343】->SpringApplication(primarySources)\n            # 加载各种配置信息，初始化各种配置对象\n                SpringApplication【266】->this(null, primarySources);\n                    SpringApplication【280】->public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources)\n                        SpringApplication【281】->this.resourceLoader = resourceLoader;\n                        # 初始化资源加载器\n                        SpringApplication【283】->this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n                        # 初始化配置类的类名信息（格式转换）\n                        SpringApplication【284】->this.webApplicationType = WebApplicationType.deduceFromClasspath();\n                        # 确认当前容器加载的类型\n                        SpringApplication【285】->this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();\n                        # 获取系统配置引导信息\n                        SpringApplication【286】->setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n                        # 获取ApplicationContextInitializer.class对应的实例\n                        SpringApplication【287】->setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n                        # 初始化监听器，对初始化过程及运行过程进行干预\n                        SpringApplication【288】->this.mainApplicationClass = deduceMainApplicationClass();\n                        # 初始化了引导类类名信息，备用\n            SpringApplication【1343】->new SpringApplication(primarySources).run(args)\n            # 初始化容器，得到ApplicationContext对象\n                SpringApplication【323】->StopWatch stopWatch = new StopWatch();\n                # 设置计时器\n                SpringApplication【324】->stopWatch.start();\n                # 计时开始\n                SpringApplication【325】->DefaultBootstrapContext bootstrapContext = createBootstrapContext();\n                # 系统引导信息对应的上下文对象\n                SpringApplication【327】->configureHeadlessProperty();\n                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）\n                    java.awt.headless=true\n                SpringApplication【328】->SpringApplicationRunListeners listeners = getRunListeners(args);\n                # 获取当前注册的所有监听器\n                SpringApplication【329】->listeners.starting(bootstrapContext, this.mainApplicationClass);\n                # 监听器执行了对应的操作步骤\n                SpringApplication【331】->ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n                # 获取参数\n                SpringApplication【333】->ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);\n                # 将前期读取的数据加载成了一个环境对象，用来描述信息\n                SpringApplication【333】->configureIgnoreBeanInfo(environment);\n                # 做了一个配置，备用\n                SpringApplication【334】->Banner printedBanner = printBanner(environment);\n                # 初始化logo\n                SpringApplication【335】->context = createApplicationContext();\n                # 创建容器对象，根据前期配置的容器类型进行判定并创建\n                SpringApplication【363】->context.setApplicationStartup(this.applicationStartup);\n                # 设置启动模式\n                SpringApplication【337】->prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n                # 对容器进行设置，参数来源于前期的设定\n                SpringApplication【338】->refreshContext(context);\n                # 刷新容器环境\n                SpringApplication【339】->afterRefresh(context, applicationArguments);\n                # 刷新完毕后做后处理\n                SpringApplication【340】->stopWatch.stop();\n                # 计时结束\n                SpringApplication【341】->if (this.logStartupInfo) {\n                # 判定是否记录启动时间的日志\n                SpringApplication【342】->    new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n                # 创建日志对应的对象，输出日志信息，包含启动时间\n                SpringApplication【344】->listeners.started(context);\n                # 监听器执行了对应的操作步骤\n                SpringApplication【345】->callRunners(context, applicationArguments);\n                # 调用运行器\n                SpringApplication【353】->listeners.running(context);\n                # 监听器执行了对应的操作步骤\n```\n\n 上述过程描述了springboot程序启动过程中做的所有的事情，这个时候好奇宝宝们就会提出一个问题。如果想干预springboot的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入springboot的启动流程呢？\n\n 遇到这样的问题，大部分技术是这样设计的，设计若干个标准接口，对应程序中的所有标准过程。当你想干预某个过程时，实现接口就行了。例如spring技术中bean的生命周期管理就是采用标准接口进行的。\n\n```java\npublic class Abc implements InitializingBean, DisposableBean {\n    public void destroy() throws Exception {\n        //销毁操作\n    }\n    public void afterPropertiesSet() throws Exception {\n        //初始化操作\n    }\n}\n```\n\n springboot启动过程由于存在着大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。那springboot如何解决这个问题呢？它采用了一种最原始的设计模式来解决这个问题，这就是监听器模式，使用监听器来解决这个问题。\n\n springboot将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：\n\n- org.springframework.boot.context.event.ApplicationStartingEvent \n <ul>\n  - 应用启动事件，在应用运行但未进行任何处理时，将发送 ApplicationStartingEvent\n </ul>\n- org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent \n <ul>\n  - 环境准备事件，当Environment被使用，且上下文创建之前，将发送 ApplicationEnvironmentPreparedEvent\n </ul>\n- org.springframework.boot.context.event.ApplicationContextInitializedEvent \n <ul>\n  - 上下文初始化事件\n </ul>\n- org.springframework.boot.context.event.ApplicationPreparedEvent \n <ul>\n  - 应用准备事件，在开始刷新之前，bean定义被加载之后发送 ApplicationPreparedEvent\n </ul>\n- org.springframework.context.event.ContextRefreshedEvent \n <ul>\n  - 上下文刷新事件\n </ul>\n- org.springframework.boot.context.event.ApplicationStartedEvent \n <ul>\n  - 应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 ApplicationStartedEvent\n </ul>\n- org.springframework.boot.context.event.ApplicationReadyEvent \n <ul>\n  - 应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 ApplicationReadyEvent，用于通知应用已经准备处理请求\n </ul>\n- org.springframework.context.event.ContextClosedEvent（上下文关闭事件，对应容器关闭）\n\n 上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户还可以根据需要自定义开发当前事件触发时要做的其他动作。\n\n```java\n//设定监听器，在应用启动开始事件时进行功能追加\npublic class MyListener implements ApplicationListener<ApplicationStartingEvent> {\n    public void onApplicationEvent(ApplicationStartingEvent event) {\n\t\t//自定义事件处理逻辑\n    }\n}\n```\n\n 按照上述方案处理，用户就可以干预springboot启动过程的所有工作节点，设置自己的业务系统中独有的功能点。\n\n**总结**\n\n1. springboot启动流程是先初始化容器需要的各种配置，并加载成各种对象，初始化容器时读取这些对象，创建容器\n2. 整体流程采用事件监听的机制进行过程控制，开发者可以根据需要自行扩展，添加对应的监听器绑定具体事件，就可以在事件触发位置执行开发者的业务代码\n\n### 原理篇完结\n\n 原理篇到这里就要结束了，springboot2整套课程的基础篇、实用篇和原理篇就全部讲完了。至于后面的番外篇由于受B站视频上传总量不得超过200个视频的约束，番外篇的内容不会在当前课程中发布了，会重新定义一个课程继续发布，至于具体时间，暂时还无法给到各位小伙伴。\n\n 原理篇个人感觉略微有点偷懒，怎么说呢？学习原理篇需要的前置铺垫知识太多，比如最后一节讲到启动流程时，看到reflush方法时我就想现在在看这套课程的小伙伴是否真的懂这个过程呢？但是如果把这些东西都讲了，那估计要补充的知识就太多了，就是将spring的很多知识加入到这里面重新讲解了，会出现喧宾夺主的现象。很纠结，( ´•︵•` )\n\n 课程做到这里就要和各位小伙伴先say顾拜了，感谢各位小伙伴的支持，也欢迎各位小伙伴持续关注黑马程序员出品的各种视频教程。黑马程序员的每位老师做课程都是认真的，都是为了各位致力于IT研发事业的小伙伴能够学习之路上少遇沟沟坎坎，顺利到达成功的彼岸。\n\n 番外篇，さようなら！ 안녕히 계십시오！แล้วเจอกัน！До свидания ！خداحافظ ！\n\n","tags":["springboot","java","spring","spring boot"]},{"title":"以热爱为前提写代码-读码农翻身有感","url":"/2023/07/01/以热爱为前提写代码-读码农翻身有感/","content":"\n![image-20230627101223207](https://icepeachpicture.oss-cn-shanghai.aliyuncs.com/ice/image-20230627101223207.png)\n\n  今天阅读了码农翻身这本书，看到一半就去关注作者的公众号了，因为这本书真的太好看了。\n\n  我很少用好看来形容一本编程书籍，通常我会使用`专业`，`技术底蕴深厚`等词汇来形容此类书籍，不过码农翻身这本书也不仅仅是纯粹的编程书籍，它把很多知识点通过讲故事的方式讲解出来，让人在读完之后发出：'原来这个东西的原理是这样的呀'的感慨。\n\n![image-20230627101741033](https://icepeachpicture.oss-cn-shanghai.aliyuncs.com/ice/image-20230627101741033.png)\n\n\n\n![image-20230627101830462](https://icepeachpicture.oss-cn-shanghai.aliyuncs.com/ice/image-20230627101830462.png)\n\n  抱着去了解作者的心思，去关注了他的公众号 码农翻身。作者从一篇'我是一个线程'这篇文章开始发现，大家喜欢看故事，在故事中掌握技术，就沿着这条路走了下来：用故事讲解技术的本质。作者几年如一日的积累，现在以及有了数百篇文章。\n\n  用作者的话说，写文章，一方面可以更好的掌握知识，在面试时候也能让面试官看到你的专业性，另一方面，要是阅读量高，读者多了，偶尔还能打个广告赚赚外快，岂不快哉。\n\n  在之前，我关注了很多写技术文的博主，他们或多或少也说过这样的话，而他却让我忽然心向往之。我想了想，应该是因为我也是很爱读故事的人，见到作者，就好像遇到了志同道合的道友一般，他提供的养分，被我这块挑剔的海绵急切的吸取着，让我同时在技术和精神上得到了满足。（还有一个原因是作者很喜欢郑渊洁，好巧，我也是哈哈哈）\n\n  写文章，如果能一直坚持下去，应该也是一件很了不起的事情吧。","tags":["学习","技术","感想","写作"],"categories":["记录"]},{"title":"一行代码关闭windows端口服务","url":"/2023/06/27/一行代码关闭windows端口服务/","content":"\n### 1：一条代码\n\n```\nGet-Process -Id (Get-NetTCPConnection -LocalPort 10001).OwningProcess | Stop-Process -Force\n```\n\n注意：get-process命令需要打开Powershell终端才能运行\n\n![image-20230627104730737](https://icepeachpicture.oss-cn-shanghai.aliyuncs.com/ice/image-20230627104730737.png)\n\n\n\n**解释：**\n\n- 这是一条 PowerShell 命令，用于根据本地端口号查找对应的进程并强制结束它。下面是该命令的详细解释：\n\n  - `Get-NetTCPConnection -LocalPort 10001`：使用 `Get-NetTCPConnection` 命令查找本地使用 10001 端口的 TCP 连接。该命令返回了与该端口相关联的网络连接（如果有）。`-LocalPort` 参数指定要查找的本地端口号。\n\n  - `(Get-NetTCPConnection -LocalPort 10001).OwningProcess`：从上一条命令的输出中取出 `OwningProcess` 属性的值，即与本地端口相关联的进程 ID。\n\n  - `Get-Process -Id`：使用 `Get-Process` 命令查找与指定的进程 ID 相关联的进程对象。\n\n  - `| Stop-Process -Force`：使用管道将输出传递给 `Stop-Process` 命令，强制结束指定的进程。`-Force` 参数表示强制结束进程，即使进程不响应也要结束。\n\n  因此，该命令的作用是：查找本地端口号为 10001 的 TCP 连接，并通过该连接的 OwningProcess 属性获取进程 ID，然后使用 `Get-Process` 命令获取该进程对象，并将其传递给 `Stop-Process` 命令来强制结束该进程。这可以在需要停止指定端口上的进程时很有用。\n\n因此，这个命令的意思是：使用 `netstat` 工具查找所有使用 10001 端口的连接，并将每个连接的进程 ID 作为参数传递给 `taskkill` 命令，以便强制结束该进程。可以用类似其他端口的情况使用，只需要替换 \"10001\" 为想要查找和终止进程的端口号即可。\n\n### 2：普通方法\n\n我要关闭10001端口的进程：\n\n```\nnetstat -ano|findstr \"10001\"\n```\n\n结果：\n\n![image-20230627104318114](https://icepeachpicture.oss-cn-shanghai.aliyuncs.com/ice/image-20230627104318114.png)\n\n5928就是使用这个端口的进程编码，我们关闭这个端口：\n\n```\ntaskkill /f /pid 5928\n```\n\n搞定","tags":["Windows","端口"],"categories":["一键系列"]},{"title":"一行代码判断字符串是否为某格式的时间","url":"/2023/06/27/一行代码判断字符串是否为某格式的时间/","content":"\n在开发中遇到需要判断某个字符串是否为某种格式（如`yyyyMMdd`、`yyyy-MM-dd`等）的时间的需求，没有找到已有的一键解决的api，所以自己写了一个\n\n方法本体：\n\n注：方法中的`ObjectUtil`和`DateUtil`均为hutool中的包\n\n```java\n    /**\n     * 判断字符串是否为指定格式的日期时间\n     *\n     * @param dateStr    需要检查的日期字符串\n     * @param dateFormat 指定的日期格式，例如：\"yyyyMMdd\", \"yyyy-MM-dd\", \"yyyy/MM/dd\" 等\n     * @return 如果字符串是指定格式的日期时间，返回 true;否则返回 false。\n     */\n\n    public static boolean isValidDateFormat(String dateStr, String dateFormat) {\n        if (ObjectUtil.isEmpty(dateStr)) {\n            return false;\n        }\n        try {\n            DateUtil.parse(dateStr, dateFormat); // 将字符串解析为日期对象，如果解析成功，则说明字符串是有效的日期格式；否则说明字符串不是有效的日期格式。\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n```\n\n\n\n测试：\n\n```java\n    /**\n     * 测试isValidDateFormat方法\n     * @param args\n     */\n    public static void main(String[] args) {\n\n        String dateStr = \"2021-03-44\"; // 需要检查的日期字符串\n        String dateFormat = \"yyyy-MM-dd\"; // 指定的日期格式\n        boolean isValidDate = isValidDateFormat(dateStr, dateFormat);\n        System.out.println(\"字符串 \" + dateStr + \" 是否为格式为 '\" + dateFormat + \"' 的时间：\" + isValidDate);\n    }\n```\n\n结果：\n\n```java\n字符串 2021-03-01 是否为格式为 'yyyy-MM-dd' 的时间：true\n字符串 2aaaa 是否为格式为 'yyyy-MM-dd' 的时间：false\n字符串 20230102 是否为格式为 'yyyyMMdd' 的时间：true\n```\n\n\n\n原理：\n\n定义了一个名为 `isValidDateFormat` 的方法，该方法接受两个参数：`dateStr`(需要检查的日期字符串)和 `dateFormat`(指定的日期格式)。方法内部使用 `DateUtil.parse()` 方法尝试将字符串解析为日期对象。如果解析成功且日期格式与指定的格式相符，则返回 `true`;否则返回 `false`。","tags":["java","date","hutool","工具类"],"categories":["一键系列"]},{"title":"跨域问题后端配置，粘贴即用！","url":"/2023/06/01/跨域问题后端配置，粘贴即用！/","content":"\n直接新建一个CorsConfig类，把一下代码粘贴就可以了\n> 需要注意的是，设置允许跨域请求的源地址和请求头时，应该只允许必要的来源和请求头，以避免潜在的安全风险。\n> 另外，需要根据具体的业务需求，对跨域请求的有效时长进行合理的设置。\n```\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\nimport org.springframework.web.filter.CorsFilter;\n\n/**\n * @author ice\n */\n@Configuration\npublic class CorsConfig {\n\n    /**\n     * 当前跨域请求最大有效时长。这里默认1天\n     */\n    private static final long MAX_AGE = 24 * 60 * 60;\n\n    @Bean\n    public CorsFilter corsFilter() {\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        CorsConfiguration corsConfiguration = new CorsConfiguration();\n        // 1 设置访问源地址\n        corsConfiguration.addAllowedOrigin(\"*\");\n        // 2 设置访问源请求头\n        corsConfiguration.addAllowedHeader(\"*\");\n        // 3 设置访问源请求方法\n        corsConfiguration.addAllowedMethod(\"*\");\n        corsConfiguration.setMaxAge(MAX_AGE);\n        // 4 对接口配置跨域设置\n        source.registerCorsConfiguration(\"/**\", corsConfiguration);\n        return new CorsFilter(source);\n    }\n}\n```","tags":["springboot","java","跨域","配置类"],"categories":["从头创建一个新项目可能需要的配置"]},{"title":"Mybatis-plus中，在新增或修改时，自动插入或修改某个字段值","url":"/2023/06/01/Mybatis-plus中，在新增或修改时，自动插入或修改某个字段值/","content":"\n\n\n# 一 效果\n\n在新增User表的数据时，createTime为null\n\n![image-20230531133204052](https://icepeachpicture.oss-cn-shanghai.aliyuncs.com/ice/b937d4d9b00ab747b9224b0d665d5dc0.png)\n\n使用mybatis-plus自带的save方法新增后，在数据库中有自动插入的当前时间的值\n\n![image-20230531133418819](https://icepeachpicture.oss-cn-shanghai.aliyuncs.com/ice/b38d9729833e7ebbfc80ab60f5393a6a.png)\n\n# 二 实现原理\n\n> ##  MetaObjectHandler:元数据对象处理器\n\n说明:`MetaObjectHandler接口`是mybatisPlus为我们提供的的一个扩展接口，我们可以利用这个接口在我们`插入`或者`更新`数据的时候，`为一些字段指定默认值`。\n\n> 使用场景：公共字段填充，如updateTime、createTime、createUser、updateUser等公共字段的填充。\n\n# 三 使用步骤\n\n## 1 在实体类的公共字段上添加@TableField注解\n\n1. `@TableField(fill = FieldFill.INSERT)`：表示此字段只在插入/新增操作时更新数据；\n2. `@TableField(fill = FieldFill.INSERT_UPDATE)`：表示此字段在新增和修改操作时都更新数据；\n3. `@TableField(fill = FieldFill.UPDATE)`：表示此字段只在修改操作时更新数据；\n\n如下面代码中，createTime，updateTime，createUser都会在新增时更新数据，updateTime还会在修改时更新数据\n\n```java\n@TableName(value = \"article\")\n@Data\npublic class Article implements Serializable {\n    /**\n     * id\n     */\n    @TableId(type = IdType.ASSIGN_UUID)\n    private String id;\n    /**\n     * 图片地址\n     */\n    private String pictureUrl;\n    /**\n     * 标题\n     */\n    private String title;\n    /**\n     * 创建时间\n     */\n    @TableField(fill = FieldFill.INSERT)\n    private String createTime;\n    /**\n     * 修改时间\n     */\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private String updateTime;\n\n    /**\n     * 创建人\n     */\n    @TableField(fill = FieldFill.INSERT)\n    private String createUser;\n\n    @TableField(exist = false)\n    private static final long serialVersionUID = 1L;\n}\n```\n\n## 2 创建配置类实现`MetaObjectHandler`接口\n\n实现`MetaObjectHandler`接口，重写insertFill、updateFill方法\n\n使用接口中的setFieldValByName方法，找到我们之前的几个字段，并给字段赋值\n\n> 不要忘记@Component 注解\n\n如下代码：\n\n```java\n@Component\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        this.setFieldValByName(\"createTime\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date()), metaObject);\n        this.setFieldValByName(\"updateTime\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date()), metaObject);    \n        this.setFieldValByName(\"createUser\", currrentUser.getNickname(), metaObject);\n    }\n\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        this.setFieldValByName(\"updateTime\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date()), metaObject);\n\n    }\n}\n```\n\n\n\n","tags":["springboot","java","mybatis-plus","工具"],"categories":["从头创建一个新项目可能需要的配置"]},{"title":"20221212最近看学习的感悟：记好笔记，不要眼高手低","url":"/2023/05/31/最近看学习的感悟：记好笔记，不要眼高手低/","content":"\n\n近一段时间学习，觉得刷教程最重要的事情就是在看视频的同时一定要写代码，老师怎么教我就怎么写，不能眼高手低，以前就是眼高手低，总觉得自己会了，现在工作时才会出现想法一大堆，一上手就卡住的问题。\n 同时，之前过于迷恋网上别人总结好的笔记，总觉得自己记笔记太浪费时间，到时候什么东西不会直接去找网上的笔记就行。最近自己坚持记了笔记才知道，记笔记不仅是记录知识点，更是记录自己的思考过程，只有思考了，运用了，用自己的话写下来，东西才是自己的。\n\n","tags":["学习","日记"]},{"title":"java重新开始1 引子","url":"/2023/05/31/java重新开始1 引子/","content":"\n\n最近想再重新过一遍基础，打算按照ssm,springboot,vue,springcloud的循序再学习一遍，并做一些项目。 于是有了这个JAVA重新开始的专栏 会在这里记录我学习的笔记，感想\n\n","tags":["学习方法","经验分享"]},{"title":"idea debug调试时，显示未用变量存储的方法的返回值","url":"/2023/05/31/idea debug调试时，显示未用变量存储的方法的返回值/","content":"\n在调试过程中，会遇到某些方法的返回值没有用变量存储，在debug时看不到返回值。比如返回值作为条件判断，或者返回值直接被return出去。这个时候就需要直接显示方法返回值。\n\n## 1 打开方式\n\n在debug工具框中，找到设置按钮：\n\n\n![img](https://img-blog.csdnimg.cn/853c9ef6f8da4b6881d11da364d0cd53.png)\n\n&nbsp;勾选show method return values\n\n\n![img](https://img-blog.csdnimg.cn/7bb23f9bfc94453f9c9d33f756b5996a.png)\n\n之后就可以在调试中看到方法的返回值了。\n\n## 2 注意事项\n\n注意，如果debug窗口小，设置不显示，点击&gt;&gt;就能看到设置，注意不要误点到其他几个按钮：\n\n\n![img](https://img-blog.csdnimg.cn/a054a2042523498b94d08598240c71ea.png)\n\n点击&gt;&gt;时很容易误点到其他按钮：\n\n\n![img](https://img-blog.csdnimg.cn/da5320d178de4e578219d861f169c36f.png)&nbsp;这个是被误点后的样子，图中选中的按钮是禁用断点的意思，选中后是灰色框，这样就调试不了。\n\n\n![img](https://img-blog.csdnimg.cn/9ecdb1756e584b44a5a5aad08305e503.png)\n\n## 3 测试\n\n\n![img](https://img-blog.csdnimg.cn/07be413a56c940b0a2cfa96f2911da40.png)\n\n&nbsp;在两个断点出分别能看到下图结果，调试成功\n\n\n![img](https://img-blog.csdnimg.cn/6b895dd495b94c0cbd6fd923611d2c57.png)\n\n\n![img](https://img-blog.csdnimg.cn/7a21db9e68e1409c84fd18f73b99af86.png)\n\n\n\n","tags":["java","开发工具","idea","单元测试"]},{"title":"java重新开始2 尚硅谷最新SSM教程逐P笔记 1_Mybatis部分","url":"/2023/05/31/java重新开始2 尚硅谷最新SSM教程逐P笔记 1_Mybatis部分/","content":"\n\n网址：【【尚硅谷】SSM框架全套教程，MyBatis+Spring+SpringMVC+SSM整合一套通关】https://www.bilibili.com/video/BV1Ya411S7aT?p=4&amp;vd_source=10e3dfac95ac3a6883b1f8a6c3bc65d5\n\n [最近看视频学习的感悟](http://t.csdn.cn/gZTsL) [JAVA重新开始](http://t.csdn.cn/x2EqR)\n\n这个笔记是我根据视频的P数来记的，把一些网上随时可以搜到的（比如mybatis历史之类的）部分删减，记录下了自己觉得较为重要的知识点,同时还记录了老师在课上讲的，但是可能并没有在官方给的笔记里展现出来的东西。\n\n## p1 课程介绍\n\n先讲mybatis然后讲spring和springmvc\n\n## p2 mybatis历史\n\nmybatis以前是abatis\n\nmybatis是优秀的持久层框架\n\n## p3 mybatis特性\n\n避免了几乎所有手动获得结果集和手动配置参数（自动把sql查询到的结果集解析成java对象）\n\n## p4 mybatis下载\n\n访问网站https://github.com/mybatis/mybatis-3\n\n这是mybatis的GitHub网址，直接下载最新版\n\n## p5 mybatis和其他持久层技术的区别\n\njdbc：耦合度高（sql是写死的），开发效率低，维护成本高\n\nhibernate：简单了解\n\nmybatis：轻量级，sql和java分开，sql专注数据，java专注业务\n\n## p6 搭建mybatis开发环境\n\nIDE:idea 2019.2\n 构建工具：maven3.5.4\n MySQL版本：MySQL8\n MyBatis版本：MyBatis3.5.7\n\n1新建一个空项目\n\n我：D:12_idea/newjava/SSM\n\n2 配置本地maven，配置文件和仓库\n\n3 新建module 选择maven\n\n其中src中的java放的是主程序，resources中放的是配置文件，test中的Java放的是测试程序\n\nmodule名：mybatis_helloworld\n\ngroupid:com.ice\n\nversion:1.0\n\n4 在pom.xml中，version下再添加一个打包方式：jar\n\n```java\n<groupId>com.ice</groupId>\n    <artifactId>mybatis_hellloworld</artifactId>\n    <version>1.0</version>\n    <packaging>jar</packaging>\n```\n\n5 导入一些依赖\n\n```java\n<dependencies>\n        <!-- Mybatis核心 -->\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.7</version>\n        </dependency>\n        <!-- junit测试 -->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n        <!-- MySQL驱动 -->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.16</version>\n        </dependency>\n    </dependencies>\n```\n\n注：如果要使用MySQL5，就要使用5版本的驱动\n\n6 新建数据库 ssm\n\n新建表\n\n```java\nCREATE TABLE `t_user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(20) DEFAULT NULL,\n  `password` varchar(32) DEFAULT NULL,\n  `age` int(11) DEFAULT NULL,\n  `gender` varchar(255) DEFAULT NULL,\n  `email` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;\n```\n\n7 新建对应的实体类\n\n在java文件夹下新建com.ice.mybatis.pojo.User(前面几个是包路径，最后一个是类名)\n\nalt+insert创建有参和无参构造和getset等（或者使用lombok的@Date）\n\n```java\npublic class User {\n\n    private Integer id;\n\n    private String username;\n\n    private String password;\n\n    private Integer age;\n\n\n\n    private String gender;\n\n    private String email;\n    public User(){\n\n    }\n\n    public User(Integer id, String username, String password, Integer age, String gender, String email) {\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.age = age;\n        this.gender = gender;\n        this.email = email;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public String getGender() {\n        return gender;\n    }\n\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n}\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", password='\" + password + '\\'' +\n                \", age=\" + age +\n                \", gender='\" + gender + '\\'' +\n                \", email='\" + email + '\\'' +\n                '}';\n    }\n```\n\n## p7 创建mybatis核心配置文件\n\n习惯命名为mybatis-config.xml（仅仅是建议，因为整合spring之后是通过文件名来配置的）\n\n核心配置文件主要用来配置连接数据库的环境以及mybatis的全局配置信息\n\n核心配置文件放在src/main/resources下\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!--设置连接数据库的环境-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <!--事务-->\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm?\nserverTimezone=UTC\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"1234\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--引入映射文件-->\n    <mappers>\n        <mapper resource=\"\"/>\n    </mappers>\n</configuration>\n```\n\n在映射文件中，我们写的才是sql语句,到时候要把映射文件配置在核心配置文件中\n\n## p8 创建mapper接口和映射文件\n\n### 1 mapper\n\nMyBatis中的mapper接口**相当于以前的dao**。但是区别在于，mapper仅仅是接口，我们不需要\n 提供实现类。\n\n起名规则，类名+mapper\n\n创建和pojo同级的mapper包\n\n```java\npackage com.ice.mybatis.mapper;\n\npublic interface UserMapper {\n    /**\n     * 添加用户信息\n     */\n    int insertUser();\n}\n```\n\n先写一个添加的方法\n\n### 2 映射文件\n\n在resources中新建一个mappers文件夹，专门用来存放xml文件\n\n新建和UserMapper对应的UserMapper.xml\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\nPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.atguigu.mybatis.mapper.UserMapper\">\n<!--int insertUser();-->\n<insert id=\"insertUser\">\ninsert into t_user values(null,'admin','123456',23,'男','12345@qq.com')\n</insert>\n</mapper>\n```\n\n注意点：\n\n1 namespace 和mapper全类名一致\n\n2 mapper接口中的方法名和映射文件sql语句的id保持一致\n\n**在核心配置文件中配置映射文件**\n\n```java\n<mapper resource=\"mappers/UserMapper.xml\"/>\n```\n\n## p9 新增测试\n\n### 1 新建测试类\n\n```java\npackage com.ice.mybatis.test;\n\nimport com.ice.mybatis.mapper.UserMapper;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class MyBatisTst {\n    @Test\n    public void testInsert() throws IOException {\n        //输入流\n        InputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n        //创建SqlSessionFactoryBuilder对象\n        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new\n                SqlSessionFactoryBuilder();\n        //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象\n        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n        //创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务\n        //SqlSession sqlSession = sqlSessionFactory.openSession();\n        //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n        //通过代理模式创建UserMapper接口的代理实现类对象\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配\n        int result = userMapper.insertUser();\n        System.out.println(\"结果：\" + result);\n        sqlSession.commit();\n        sqlSession.close();\n    }\n\n}\n```\n\n1 事务要自己提交，这样才能把数据保留在数据库中\n\n2 创建sqlSession对象时，openSession的参数为true，可以自动提交事务\n\n3 这些代码在之后配置了spring后几乎不用写\n\n4 说实话，这些代码我不怎么看懂\n\n### 2 加入log4j日志功能\n\n1 依赖\n\n```java\n<!-- log4j日志 -->\n<dependency>\n<groupId>log4j</groupId>\n<artifactId>log4j</artifactId>\n<version>1.2.17</version>\n</dependency>\n```\n\n2 在resources下加入名为log4j.xml的配置文件\n\n照着复制就行\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\">\n<log4j:configuration xmlns:log4j=\"http://jakarta.apache.org/log4j/\">\n    <appender name=\"STDOUT\" class=\"org.apache.log4j.ConsoleAppender\">\n        <param name=\"Encoding\" value=\"UTF-8\" />\n        <layout class=\"org.apache.log4j.PatternLayout\">\n            <param name=\"ConversionPattern\" value=\"%-5p %d{MM-dd HH:mm:ss,SSS}\n%m (%F:%L) \\n\" />\n        </layout>\n    </appender>\n    <logger name=\"java.sql\">\n        <level value=\"debug\" />\n    </logger>\n    <logger name=\"org.apache.ibatis\">\n        <level value=\"info\" />\n    </logger>\n    <root>\n        <level value=\"debug\" />\n        <appender-ref ref=\"STDOUT\" />\n    </root>\n</log4j:configuration>\n```\n\n之后运行测试类时就会打印一些测试的提示\n\n## p10 优化新增\n\n1. 在创建sqlsession对象时加入参数true，之后就会自动提交事务\n\n## p11 源码验证和日志级别\n\n讲了一下sqlsession获取sql的方法的底层源码\n\n日志级别\n\nFATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)\n 从左到右打印的内容越来越详细\n\n## 封装获取sql的代码\n\n新建一个和pojo同级的Utils文件夹，用来存储工具类\n\n新建一个SqlSessionUtil类\n\n```java\npackage com.ice.mybatis.Utils;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class SqlSessionUtil {\n    public static SqlSession getSqlSession(){\n        SqlSession sqlSession=null;\n        try {\n            InputStream   is = Resources.getResourceAsStream(\"mybatis-config.xml\");\n            //创建SqlSessionFactoryBuilder对象\n            SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new\n                    SqlSessionFactoryBuilder();\n            //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象\n            SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);\n            //创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务\n            //SqlSession sqlSession = sqlSessionFactory.openSession();\n            //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交\n            sqlSession = sqlSessionFactory.openSession(true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return sqlSession;\n    }\n}\n```\n\n之后在测试类中使用\n\n```java\nSqlSession sqlSession = SqlSessionUtil.getSqlSession();\n```\n\n直接获取sqlSession对象即可\n\n## p12 修改和删除\n\n修改\n\n```java\n<!--int updateUser();-->\n<update id=\"updateUser\">\nupdate t_user set username='ybc',password='123' where id = 6\n</update>\n```\n\n删除\n\n```java\n<!--int deleteUser();-->\n<delete id=\"deleteUser\">\ndelete from t_user where id = 7\n</delete>\n```\n\n## p13 查询\n\n### 1 查询实体类对象\n\n```java\n<!--User getUserById();-->\n<select id=\"getUserById\" resultType=\"com.atguigu.mybatis.bean.User\">\nselect * from t_user where id = 2\n</select>\n```\n\n2 查询list集合\n\n```java\n<!--List<User> getUserList();-->\n<select id=\"getUserList\" resultType=\"com.atguigu.mybatis.bean.User\">\nselect * from t_user\n</select>\n```\n\n查询一定要添加resultType或resultMap，resultType就是返回的类的全类名，resultMap之后会讲\n\nresultType：自动映射，用于属性名和表中字段名一致的情况\n resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况\n\n## p14~p17的核心配置文件的完整文件\n\n后面几p是讲核心配置文件中具体的配置的，在这里先把完好的配置文件放这\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\nPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n\"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n<!--\nMyBatis核心配置文件中，标签的顺序：\nproperties?,settings?,typeAliases?,typeHandlers?,\nobjectFactory?,objectWrapperFactory?,reflectorFactory?,\nplugins?,environments?,databaseIdProvider?,mappers?\n-->\n<!--引入properties文件-->\n<properties resource=\"jdbc.properties\" />\n<!--设置类型别名-->\n<typeAliases>\n<!--\ntypeAlias：设置某个类型的别名\n属性：\ntype：设置需要设置别名的类型\nalias：设置某个类型的别名，若不设置该属性，那么该类型拥有默认的别名，即类名\n且不区分大小写\n-->\n<!--<typeAlias type=\"com.atguigu.mybatis.pojo.User\"></typeAlias>-->\n<!--以包为单位，将包下所有的类型设置默认的类型别名，即类名且不区分大小写-->\n<package name=\"com.atguigu.mybatis.pojo\"/>\n</typeAliases>\n<!--\nenvironments：配置多个连接数据库的环境\n属性：\ndefault：设置默认使用的环境的id\n-->\n<environments default=\"development\">\n    <!--\nenvironment：配置某个具体的环境\n属性：\nid：表示连接数据库的环境的唯一标识，不能重复\n-->\n<environment id=\"development\">\n<!--\ntransactionManager：设置事务管理方式\n属性：\ntype=\"JDBC|MANAGED\"\nJDBC：表示当前环境中，执行SQL时，使用的是JDBC中原生的事务管理方式，事\n务的提交或回滚需要手动处理\nMANAGED：被管理，例如Spring\n-->\n<transactionManager type=\"JDBC\"/>\n<!--\ndataSource：配置数据源\n属性：\ntype：设置数据源的类型\ntype=\"POOLED|UNPOOLED|JNDI\"\nPOOLED：表示使用数据库连接池缓存数据库连接\nUNPOOLED：表示不使用数据库连接池\nJNDI：表示使用上下文中的数据源\n-->\n<dataSource type=\"POOLED\">\n<!--设置连接数据库的驱动-->\n<property name=\"driver\" value=\"${jdbc.driver}\"/>\n<!--设置连接数据库的连接地址-->\n<property name=\"url\" value=\"${jdbc.url}\"/>\n<!--设置连接数据库的用户名-->\n<property name=\"username\" value=\"${jdbc.username}\"/>\n<!--设置连接数据库的密码-->\n<property name=\"password\" value=\"${jdbc.password}\"/>\n</dataSource>\n</environment>\n    <environment id=\"test\">\n<transactionManager type=\"JDBC\"/>\n<dataSource type=\"POOLED\">\n<property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n<property name=\"url\"\nvalue=\"jdbc:mysql://localhost:3306/ssmserverTimezone=UTC\"/>\n<property name=\"username\" value=\"root\"/>\n<property name=\"password\" value=\"123456\"/>\n</dataSource>\n</environment>\n</environments>\n<!--引入映射文件-->\n<mappers>\n<!--<mapper resource=\"mappers/UserMapper.xml\"/>-->\n<!--\n以包为单位引入映射文件\n要求：\n1、mapper接口所在的包要和映射文件所在的包一致\n2、mapper接口要和映射文件的名字一致\n-->\n<package name=\"com.atguigu.mybatis.mapper\"/>\n</mappers>\n    </configuration>\n```\n\n注意，配置文件中各项的顺序是固定的，如果顺序错误就会报错或者运行错误，具体的顺序：\n\nproperties?,settings?,typeAliases?,typeHandlers?,\n objectFactory?,objectWrapperFactory?,reflectorFactory?,\n plugins?,environments?,databaseIdProvider?,mappers?\n\n## p14 environment\n\ntransactionManager：设置事务管理方式\n 属性：\n type=“JDBC|MANAGED”\n JDBC：表示当前环境中，执行SQL时，使用的是JDBC中原生的事务管理方式，事\n 务的提交或回滚需要手动处理\n MANAGED：被管理，例如Spring\n\n## p 15 properties\n\n在resources上右键，点击new中的 resource bundle，这个就是properties文件的新建项，本次我们要给jdbc配置一个properties文件，所以name填jdbc\n\n在jdbc.properties文件中填写数据：\n\n```java\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC\njdbc.username=root\njdbc.password=1234\n```\n\n在核心配置文件中引入properties文件\n\n以后在配置properties文件的时候务必记得在之前加上一个区分的名字（这里的jdbc）\n\n之后我们就可以将核心配置文件中的数据源配置成\"${jdbc.driver}\"的形式啦（详细看完整配置文件）\n\n## p16 typeAliases 别名\n\ntypeAliases 可以给类起别名，之前我们在mapper的xml文件中返回类型写的全类名较长，我们可以在typeAliases 中配置类名的全类名，这样可以省事一点\n\n```java\n<typeAliases>\n        <typeAlias type=\"com.ice.mybatis.pojo.User\" alias=\"user\"></typeAlias>\n    </typeAliases>\n```\n\ntype属性中写全类名，alias中写别名，这样在mapper的xml文件中就可以直接使用user了\n\nalias也可以不写，如果只写type属性的话，那么别名就默认是类名，且不区分大小写，即在咱们这个例子中，如果不写alias的话，别名就默认是user，或者User也可以（问：那useR呢）\n\n## p17 mappers\n\n除了在mappers中通过<mapper resource=\"mappers/UserMapper.xml\"/>引入具体文件夹以外，我们还可以直接引入一整个文件夹中的xml\n\n当然，因为我们之前说过，mapper中的mapper类和每一个xml是一一对应的，所以为了找到对应的xml文件，在resources中存放xml的文件夹也要和java中mapper的位置一一对应，这里我们在任意一个mapper文件的最上面可以看到包名，我的是com.ice.mybatis.mapper 我们用相同的路径在resources中新建这样路径的文件夹即可\n\n注意，在java中新建的是包，所以可以用com.ice.mybatis.mapper直接新建出对应路径的文件或包，而在resources中默认的是文件夹，如果在文件夹中写com.ice.mybatis.mapper的话，只会 生成一个名为com.ice.mybatis.mapper的文件夹，我们可以新建时填写com/ice/mybatis/mapper，这样就可以生产对应路径的文件夹了，或者，您也可以一层一层新建文件夹，随你\n\n新建完文件夹后，把之前UserMapper.xml文件放到文件夹中，然后将核心配置文件中的mappers下的标签修改为<package name=\"com.ice.mybatis.mapper\"/>\n\n然后再测试测试类中的代码，运行正确\n\n## p18 idea中创建模板\n\n我们不可能每次都去官网复制这些配置，所以我们可以直接将模板放在idea中，以后就可以直接新建了\n\n点击设置-editer-fire and code templates\n\n新增模板\n\n以后右键的时候就可以直接生成模板了\n\n## p19 使用模板新建一个新的模块\n\n没什么讲的，就是建议一些配置文件，如jdbc.properties ;log4j.xml; 等文件可以保存在一个常用文件夹下，以后直接复制就可以\n\n## p20 mybatis获取参数值的两种方式\n\n#{} 占位符的方式\n\n${} 字符串拼接的方式\n\n## p21 mybatis获取参数值的情况（1）\n\n获取个参数值，sql语句中#{}中的参数随便填\n\n## p22 mybatis获取参数值的情况（2）\n\n获取多个参数值，mybatis会默认已arg1 arg2…（或者param1，param2…）为键，参数值为值封装为map集合，所以在sql中填写arg1，arg2就行\n\n## p23 mybatis 获取参数值的情况（3）\n\n既然它默认封装map，那我们也可以封装自己的map来获取参数值呀，\n\n修改UserMapper的方法\n\nUser checkLogin(Map&lt;String,Object&gt; map)\n\n之后把数据手动放在map中\n\n## p24 mybatis 获取参数值的情况（4）\n\n参数为对象\n\n## p25 mybatis 获取参数值的情况（5）\n\n@Param\n\n## p26 mybatis的各种查询功能（1）\n\n1 查找一个对象\n\n2 查找多个对象\n\n这节课讲了，查找结果为多个时不可以用对象类型接受，会抛异常\n\n查找单结果时可以用集合接受\n\n## p27 mybatis的各种查询功能（2）\n\n比如要查数据总量\n\nInt findAll();\n\n在sql的返回类型中，我们发现用int,Int ,Integer，integer之类都可以接收，说明mybatis已经帮我们把这些类型的别名配置好了\n\n## p28 mybatis的各种查询功能（3）\n\n查询一条数据，且返回的数据无法和一个已有类对应时，可以直接返回Map\n\nMap&lt;String,Object&gt; findOneById();\n\n在sql的resultType中填写Map就行\n\n## p29 mybatis的各种查询功能（4）\n\n查询一条数据，且返回的数据无法和一个已有类对应时\n\n这下不可以直接用Map&lt;String,Object&gt;接收了\n\n方式1：可以使用List&lt;Map&lt;String,Object&gt;&gt;接收\n\n方法2：可以添加一个@MapKey的注解\n\n在Map&lt;String,Object&gt; selectAll上添加一个@MapKey(“id”)的注解\n\n注意，双引号中的是查询的数据中的一个字段，之后会作为一个大map的键，而id这个键对应的值就是这个id所在的数据，即p27中查出的键值对\n\n这波是键值对套键值对\n\n同时，因为键值对的key是不可以重复的，所以这里要用主键或者是不会重复的字段作为参数\n\n## p30 p31 mybatis处理模糊查询\n\n```java\nList<User> selectUserByMoHu(@Param(\"mohu\") String mohu);\n```\n\n```java\n<select id=\"selectUserByMoHu\" resultType=\"com.ice.mybatis.pojo.User\">\n        select * from t_user where username like '%${mohu}%'\n    </select>\n```\n\n1 这个时候要使用${},这样可以拼接出正确的sql（有sql注入风险）\n\n2 或者，如果使用占位符的方式可以这样写sql（concat拼接）\n\n```java\nselect * from t_user where username like concat('%',#{mohu},'%')\n```\n\n使用一个concat拼接\n\n3 或者直接拼接（最建议的方式）\n\n```java\nselect * from t_user where username like \"%\"#{mohu}\"%\"\n```\n\n注意，这里%外使用的是双引号\n\n## p32 批量删除\n\nsql：\n\n```java\ndelete from t_user where id in (6,7)\n```\n\nmapper：\n\n```java\nvoid deleteMoreUser(@Param(\"ids\") String ids);\n```\n\nxml:\n\n```java\n<delete id=\"deleteMoreUser\">\n        delete from t_user where id in (${ids})\n</delete>\n```\n\n测试：\n\ndeleteMoreUser（“6,7”）\n\n这里就必须使用${}了，因为如果使用#{}会默认多出一个单引号，这样sql就不对了\n\n## p33 设置动态表名\n\n有时要动态设置表名\n\n用${}\n\n原因同上\n\n## p34 在新增数据时获取这个数据的自增主键\n\nmapper：\n\n```java\nvoid insertByUser(User user);\n```\n\nxml:\n\n```java\n<insert id=\"insertByUser\" useGeneratedKeys=\"true\" keyProperty=\"id\">\ninsert into t_user values(null,#{username},#{password},#{age},#{gender},#{email})\n    </insert>\n```\n\nuseGeneratedKeys指的是当前添加的功能的主键为自增\n\nkeyProperty指的是把自增的主键返回到对象的某个字段里，这里是id，所以测试类调用完方法后就会将id放到作为参数的User中\n\n```java\nUser user = new User(null,\"1\",\"1\",1,\"1\",\"1\");\n        userMapper.insertByUser(user);\n        System.out.println(user);\n```\n\n打印出的user的id为11\n\n## p 35 标题是搭建mybatis框架，但讲的好像是resultMap自定义映射\n\n这个视频将的是当数据库中的字段和java中的对象属性不一致时，应该如何处理\n\n如，在数据库中，字段名是符合mysql规范的user_name,而java中是符合java规范的userName小驼峰命名方式，这个时候查询出的数据对应不上属性名怎么办\n\n## p36 使用全局配置处理字段名和属性名不一样的问题\n\n方法1：\n\nsql查询的时候起别名\n\n```java\nselect user_name userName ,age from t_user\n```\n\n方法2：\n\nmybatis核心配置文件中的setting标签中有很多封装好的映射\n\n其中有一个叫mapUnderscoreToCamelCase 的，意思是把下划线转成小驼峰，把属性设置为true\n\n```java\n<settings>\n        <setting name=\"mapUnderscoreToCamelCase\" value=\"ture\"/>\n    </settings>\n```\n\n这样就可以继续在sql中使用select *来进行查询了\n\n且数据库中的下划线会自动映射为小驼峰\n\n在使用自动映射的过程中，发现自动映射失效\n\n排查后发现是因为在实体类使用lombok（@Data），却没有对实体类进行序列化\n\n## p37 使用resultMap处理字段名和属性名不一样的问题\n\n书接上回\n\n方法3：\n\n可以在xml配置resultMap\n\n```java\n<resultMap id=\"userMap\" type=\"User\">\n<id property=\"id\" column=\"id\"></id>\n<result property=\"userName\" column=\"user_name\"></result>\n<result property=\"password\" column=\"password\"></result>\n<result property=\"age\" column=\"age\"></result>\n<result property=\"sex\" column=\"sex\"></result>\n</resultMap>\n```\n\n是映射主键的\n\n是映射普通字段的\n\n除了这两个外还有另外两个，后面几p讲\n\ncolumn是数据库中字段名，property是java中类的属性名\n\n中的id是这个resultMap的id，用来给sql找到它的，type就是要映射的类\n\n之后在之前那个sql中添加这个resultMap的映射\n\n```java\n<select id=\"testMohu\" resultMap=\"userMap\">\n<!--select * from t_user where username like '%${mohu}%'-->\nselect id,user_name,password,age,sex from t_user where user_name like\nconcat('%',#{mohu},'%')\n</select>\n```\n\nresultMap=\"userMap\"中的userMap是刚刚说的resultMap标签中的id\n\n## p38 处理多对一映射关系\n\n**对一，对应的就是一个对象，对多，对应的就是一个集合**\n\n比如员工和部门\n\n多个员工对应一个部门，就是每一个员工都对应一个部门的对象\n\n一个部门对应多个员工，就是每一个部门都对应一个员工的集合\n\n## p39 使用级联处理多对一的映射关系\n\n先添加多表联查的sql\n\n```java\n<select id=\"findEmp\" parameterType=\"integer\" resultMap=\"resultMapForFindEmp\">\n        select emp.*,dept.* from  emp left join  dept on emp.dept_id = dept.dept_id where emp.emp_id = #{empId}\n    </select>\n```\n\n在Emp类中添加一个private Dept dept;\n\n然后在resultMap中添加\n\n```java\n<resultMap id=\"resultMapForFindEmp\" type=\"com.ice.mybatis.pojo.Emp\">\n        <id column=\"emp_id\" property=\"empId\"></id>\n        <result column=\"emp_name\" property=\"empName\"></result>\n        <result column=\"age\" property=\"age\"></result>\n        <result column=\"gender\" property=\"gender\"></result>\n        <result column=\"dept_id\" property=\"dept.deptId\"></result>\n        <result column=\"dept_name\" property=\"dept.deptName\"></result>\n    </resultMap>\n```\n\n这个配置中的dept_id对应的是sql查出的dept_id，后面的dept.deptId对应的是tpye中的实体类中创建的dept对象中的deptId属性\n\n## p40 使用association处理多对一映射关系\n\n```java\n<resultMap id=\"resultMapForFindEmp\" type=\"com.ice.mybatis.pojo.Emp\">\n        <id column=\"emp_id\" property=\"empId\"></id>\n        <result column=\"emp_name\" property=\"empName\"></result>\n        <result column=\"age\" property=\"age\"></result>\n        <result column=\"gender\" property=\"gender\"></result>\n        <association property=\"dept\" javaType=\"com.ice.mybatis.pojo.Dept\">\n            <id column=\"dept_id\" property=\"deptId\"></id>\n            <result column=\"dept_name\" property=\"deptName\"></result>\n        </association>\n    </resultMap>\n```\n\n专门用来处理多对一的映射关系（处理实体类类型的属性）\n\n如这里的dept就是Emp中的一个属性而他本身又是一个实体类，这个时候就可以使用association\n\n## p41 使用分步查询处理多对一的映射关系\n\n要想清楚每一步要查什么\n\n1 通过员工id查询员工\n\n2 通过员工中的部门id查到部门\n\n①查询员工信息\n\n```java\n/**\n* 通过分步查询查询员工信息\n* @param eid\n* @return\n*/\nEmp getEmpByStep(@Param(\"empId\") int emptId);\n```\n\n```java\n<resultMap id=\"empDeptStepMap\" type=\"Emp\">\n<id column=\"emp_id\" property=\"empId\"></id>\n<result column=\"emp_name\" property=\"empName\"></result>\n<result column=\"age\" property=\"age\"></result>\n<result column=\"gender\" property=\"gender\"></result>\n<!--\nselect：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId）\ncolumn：将sql以及查询结果中的某个字段设置为分步查询的条件\n-->\n<association property=\"dept\"\nselect=\"com.atguigu.MyBatis.mapper.DeptMapper.getEmpDeptByStep\" column=\"dept_id\">\n</association>\n</resultMap>\n\n<!--Emp getEmpByStep(@Param(\"eid\") int eid);-->\n<select id=\"getEmpByStep\" resultMap=\"empDeptStepMap\">\nselect * from emp where emp_id = #{empId}\n</select>\n```\n\n②根据员工所对应的部门id查询部门信息\n\n```java\n/**\n* 分步查询的第二步： 根据员工所对应的did查询部门信息\n* @param did\n* @return\n*/\nDept getEmpDeptByStep(@Param(\"deptId\") int deptId);\n```\n\n```java\n<!--Dept getEmpDeptByStep(@Param(\"did\") int did);-->\n<select id=\"getEmpDeptByStep\" resultType=\"Dept\">\nselect * from dept where dept_id = #{deptId}\n</select>\n```\n\n## P42 分步查询的好处：延迟加载\n\n分步查询的优点：可以实现延迟加载\n 但是必须在核心配置文件中设置全局配置信息：\n lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载\n aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载\n\n懒加载：\n\n比如之前的例子，查询员工的信息时，如果我调用对了查询员工信息的方法，然后获取员工的姓名而不获取员工的部门相关的属性，那么mybatis就只会调用获取员工信息的sql而不调用获取部门信息的sql\n\nlazyLoadingEnabled开启时，就是全都延迟加载，而aggressiveLazyLoading的意思就是，当这个开启时，不管掉不掉用部门的属性，获取部门属性的那个sql都会自动加载\n\n所以lazyLoadingEnabled开启且aggressiveLazyLoading关闭，就是实现延迟加载，即所谓的懒加载\n\n此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。\n\n上面的是全局配置，如果全局配置里开了延迟加载，但是你的某一个分步查询又需要立即加载，则可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载， fetchType=“lazy(延迟加载)|eager(立即加载)”\n\n## p43 一对多映射关系\n\n直接抄笔记里的了\n\n```java\n/**\n* 根据部门id查新部门以及部门中的员工信息\n* @param did\n* @return\n*/\nDept getDeptEmpByDid(@Param(\"did\") int did);\n```\n\n```java\n<resultMap id=\"deptEmpMap\" type=\"Dept\">\n<id property=\"did\" column=\"did\"></id>\n<result property=\"dname\" column=\"dname\"></result>\n<!--\nofType：设置collection标签所处理的集合属性中存储数据的类型\n-->\n<collection property=\"emps\" ofType=\"Emp\">\n<id property=\"eid\" column=\"eid\"></id>\n<result property=\"ename\" column=\"ename\"></result>\n<result property=\"age\" column=\"age\"></result>\n<result property=\"sex\" column=\"sex\"></result>\n</collection>\n</resultMap>\n<!--Dept getDeptEmpByDid(@Param(\"did\") int did);-->\n<select id=\"getDeptEmpByDid\" resultMap=\"deptEmpMap\">\nselect dept.*,emp.* from t_dept dept left join t_emp emp on dept.did =\nemp.did where dept.did = #{did}\n</select>\n```\n\n## p44 分步加载实现一对多\n\n直接抄笔记了兄弟\n\n①查询部门信息\n\n```java\n/**\n* 分步查询部门和部门中的员工\n* @param did\n* @return\n*/\nDept getDeptByStep(@Param(\"did\") int did);\n```\n\n```java\n<resultMap id=\"deptEmpStep\" type=\"Dept\">\n<id property=\"did\" column=\"did\"></id>\n<result property=\"dname\" column=\"dname\"></result>\n<collection property=\"emps\" fetchType=\"eager\"\nselect=\"com.atguigu.MyBatis.mapper.EmpMapper.getEmpListByDid\" column=\"did\">\n</collection>\n</resultMap>\n<!--Dept getDeptByStep(@Param(\"did\") int did);-->\n<select id=\"getDeptByStep\" resultMap=\"deptEmpStep\">\nselect * from t_dept where did = #{did}\n</select>\n```\n\n②根据部门id查询部门中的所有员工\n\n```java\n/**\n* 根据部门id查询员工信息\n* @param did\n* @return\n*/\nList<Emp> getEmpListByDid(@Param(\"did\") int did);\n```\n\n```java\n<!--List<Emp> getEmpListByDid(@Param(\"did\") int did);-->\n<select id=\"getEmpListByDid\" resultType=\"Emp\">\nselect * from t_emp where did = #{did}\n</select>\n```\n\n## p45 动态sql简介\n\n多条件查询的时候有些条件没有\n\n## p46 if标签\n\n```java\n<!--List<Emp> getEmpListByCondition(Emp emp);-->\n<select id=\"getEmpListByMoreTJ\" resultType=\"Emp\">\nselect * from t_emp where 1=1\n<if test=\"ename != '' and ename != null\">\nand ename = #{ename}\n</if>\n<if test=\"age != '' and age != null\">\nand age = #{age}\n</if>\n<if test=\"sex != '' and sex != null\">\nand sex = #{sex}\n</if>\n</select>\n```\n\n## p47 where标签\n\nwhere和if一般结合使用：\n a&gt;若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字\n b&gt;若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的\n and去掉\n 注意：where标签不能去掉条件最后多余的and\n\n```java\n<select id=\"getEmpListByMoreTJ2\" resultType=\"Emp\">\nselect * from t_emp\n<where>\n<if test=\"ename != '' and ename != null\">\nename = #{ename}\n</if>\n<if test=\"age != '' and age != null\">\nand age = #{age}\n</if>\n<if test=\"sex != '' and sex != null\">\nand sex = #{sex}\n</if>\n</where>\n</select>\n```\n\n**不使用where标签的话，也可以在where后面加一个1=1**\n\n## p48 trim标签\n\n感觉没有where好用\n\ntrim用于去掉或添加标签中的内容\n 常用属性：\n prefix：在trim标签中的内容的前面添加某些内容\n prefixOverrides：在trim标签中的内容的前面去掉某些内容\n suffix：在trim标签中的内容的后面添加某些内容\n suffixOverrides：在trim标签中的内容的后面去掉某些内容\n\n```java\n<select id=\"getEmpListByMoreTJ\" resultType=\"Emp\">\nselect * from t_emp\n<trim prefix=\"where\" suffixOverrides=\"and\">\n<if test=\"ename != '' and ename != null\">\n    ename = #{ename} and\n</if>\n<if test=\"age != '' and age != null\">\nage = #{age} and\n</if>\n<if test=\"sex != '' and sex != null\">\nsex = #{sex}\n</if>\n</trim>\n</select>\n```\n\n## p49 choose when otherwise 标签\n\nchoose、when、 otherwise相当于if…else if…else\n\n```java\n<!--List<Emp> getEmpListByChoose(Emp emp);-->\n<select id=\"getEmpListByChoose\" resultType=\"Emp\">\nselect <include refid=\"empColumns\"></include> from t_emp\n<where>\n<choose>\n<when test=\"ename != '' and ename != null\">\nename = #{ename}\n</when>\n<when test=\"age != '' and age != null\">\nage = #{age}\n</when>\n<when test=\"sex != '' and sex != null\">\nsex = #{sex}\n</when>\n<when test=\"email != '' and email != null\">\nemail = #{email}\n</when>\n</choose>\n</where>\n</select>\n```\n\n## p50 51 foreach 批量添加和批量删除\n\n```java\n<!--int insertMoreEmp(@Pamram(\"emps\")List<Emp> emps);-->\n<insert id=\"insertMoreEmp\">\ninsert into t_emp values\n<foreach collection=\"emps\" item=\"emp\" separator=\",\">\n(null,#{emp.ename},#{emp.age},#{emp.sex},#{emp.email},null)\n</foreach>\n</insert>\n<!--int deleteMoreByArray(int[] eids);-->\n<delete id=\"deleteMoreByArray\">\ndelete from t_emp where\n<foreach collection=\"eids\" item=\"eid\" separator=\"or\">\neid = #{eid}\n</foreach>\n</delete>\n<!--int deleteMoreByArray(int[] eids);-->\n<delete id=\"deleteMoreByArray\">\ndelete from t_emp where eid in\n<foreach collection=\"eids\" item=\"eid\" separator=\",\" open=\"(\" close=\")\">\n    #{eid}\n</foreach>\n</delete>\n```\n\n## p52 sql标签\n\nsql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入\n\n```java\n<sql id=\"empColumns\">\neid,ename,age,sex,did\n</sql>\nselect <include refid=\"empColumns\"></include> from t_emp\n```\n\n## p53 Mybatis 的一级缓存\n\n一级缓存是**SqlSession**级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问\n\n比如在测试类中，调用了\n\nUser user = userMapper.getUserById(“1”);\n\n之后再User user2 = userMapper.getUserById(“1”);\n\n你会发现只运行了一次sql，这是因为缓存把第一次运行的结果保存下来了\n\n## p54 一级缓存失效的四种情况\n\n1. 不同的SqlSession对应不同的一级缓存\n\n两个不同的SqlSession不用同一个缓存\n\n1. 同一个SqlSession但是查询条件不同\n\n查询条件不同，是不同的sql了，肯定也不一样\n\n1. 同一个SqlSession两次查询期间执行了任何一次增删改操作\n\n执行增删改操作之后，就不会从缓存中获取数据，而是重新从数据库获取数据，因为增删改会修改数据库数据，那缓存中的数据可就不一定对了\n\n1. 同一个SqlSession两次查询期间手动清空了缓存\n\n这个就不用说了，清空了，肯定重新查\n\nsqlSession.clearCache() 这是用来清除一级缓存的\n\n## p55 mybatis的二级缓存\n\n二级缓存是SqlSessionFactory级别，通过**同一个SqlSessionFactory创建的SqlSession**查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取\n 二级缓存开启的条件：\n a&gt;在核心配置文件中，设置全局配置属性cacheEnabled=“true”，默认为true，不需要设置\n b&gt;在映射文件中设置标签 \n c&gt;二级缓存必须在SqlSession关闭或提交之后有效\n\nsqlSession.close()\n\nd&gt;查询的数据所转换的实体类类型必须实现序列化的接口\n 使二级缓存失效的情况：\n 两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效\n\n## p56 二级缓存相关配置\n\n在mapper配置文件中添加的cache标签可以设置一些属性：\n\n①eviction属性：缓存回收策略，默认的是 LRU。\n\nLRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。\n\nFIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。\n\nSOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。\n\nWEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。\n\n②flushInterval属性：刷新间隔，单位毫秒\n\n默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新\n\n③size属性：引用数目，正整数\n\n代表缓存最多可以存储多少个对象，太大容易导致内存溢出\n ④readOnly属性：只读， true/false\n\ntrue：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了 很重要的性能优势。\n\nfalse：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。\n\n**查询缓存顺序**\n\n先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。\n\n如果二级缓存没有命中，再查询一级缓存\n\n如果一级缓存也没有命中，则查询数据库\n\nSqlSession关闭之后，一级缓存中的数据会写入二级缓存\n\n## p57整合第三方缓存\n\n是针对二级缓存的\n\n了解，知道mybatis可以整合第三方缓存就可以了，所以还是直接复制哈\n\n### 1 添加依赖\n\n```java\n<!-- Mybatis EHCache整合包 -->\n<dependency>\n<groupId>org.mybatis.caches</groupId>\n<artifactId>mybatis-ehcache</artifactId>\n<version>1.2.1</version>\n</dependency>\n<!-- slf4j日志门面的一个具体实现 -->\n<dependency>\n<groupId>ch.qos.logback</groupId>\n<artifactId>logback-classic</artifactId>\n<version>1.2.3</version>\n</dependency>\n```\n\n### 2 各jar包作用\n\n\n### 3 创建EHCache的配置文件ehcache.xml\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\">\n<!-- 磁盘保存路径 -->\n<diskStore path=\"D:\\atguigu\\ehcache\"/>\n<defaultCache\nmaxElementsInMemory=\"1000\"\nmaxElementsOnDisk=\"10000000\"\neternal=\"false\"\noverflowToDisk=\"true\"\ntimeToIdleSeconds=\"120\"\ntimeToLiveSeconds=\"120\"\ndiskExpiryThreadIntervalSeconds=\"120\"\nmemoryStoreEvictionPolicy=\"LRU\">\n</defaultCache>\n</ehcache>\n```\n\n### 4 设置二级缓存的类型\n\n这个是写在映射文件里的\n\n```java\n<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\n```\n\n### 5 加入logback日志\n\n存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日\n 志。 创建logback的配置文件logback.xml\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration debug=\"true\">\n<!-- 指定日志输出的位置 -->\n<appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n<encoder>\n<!-- 日志输出的格式 -->\n<!-- 按照顺序分别是： 时间、日志级别、线程名称、打印日志的类、日志主体内容、换行\n-->\n<pattern>[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger]\n[%msg]%n</pattern>\n</encoder>\n</appender>\n<!-- 设置全局日志级别。日志级别按顺序分别是： DEBUG、INFO、WARN、ERROR -->\n<!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 -->\n<root level=\"DEBUG\">\n<!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender -->\n<appender-ref ref=\"STDOUT\" />\n</root>\n<!-- 根据特殊需求指定局部日志级别 -->\n<logger name=\"com.atguigu.crowd.mapper\" level=\"DEBUG\"/>\n</configuration>\n```\n\n### 6 EHCache配置文件说明\n\n\n","tags":["java","开发语言","mybatis"]},{"title":"java重新开始2 尚硅谷最新SSM教程逐P笔记 2_spring部分","url":"/2023/05/31/java重新开始2 尚硅谷最新SSM教程逐P笔记 2_spring部分/","content":"\n\n网址：【【尚硅谷】SSM框架全套教程，MyBatis+Spring+SpringMVC+SSM整合一套通关】https://www.bilibili.com/video/BV1Ya411S7aT?p=4&amp;vd_source=10e3dfac95ac3a6883b1f8a6c3bc65d5\n\n [最近看视频学习的感悟](http://t.csdn.cn/gZTsL) [JAVA重新开始](http://t.csdn.cn/x2EqR)\n\n这个笔记是我根据视频的P数来记的，把一些网上随时可以搜到的（比如mybatis历史之类的）部分删减，记录下了自己觉得较为重要的知识点,同时还记录了老师在课上讲的，但是可能并没有在官方给的笔记里展现出来的东西。\n\n目前更新到p93\n\n## p63 spring概述\n\nSpring：让java更简单\n\nSpring 框架来创建性能好、易于测试、可重用的代码。\n\n创建性能好：\n\n以前我们在控制层 下面是service层，下面是Dao层\n\n每一层都要new一个对象 ，现在我们可以直接接收Spring直接提供给我们的对象\n\n易于测试：\n\n可以使用单元测试来对我们的代码进行测试\n\n可重用：\n\n之前：\n\n事务管理：不好封装\n\n## p64 framework简介和特性\n\n1 特性\n\n- 非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常\n\n小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会\n\n破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序\n\n时结构清晰、简洁优雅。\n\n- 控制反转：IOC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源\n\n变成环境将资源准备好，我们享受资源注入。\n\n- 面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功\n\n能。\n\n- 容器：Spring IOC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化\n\n的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发\n\n效率。\n\n- 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML\n\n和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭\n\n建超大型复杂应用系统。\n\n- \n 声明式：很多以前需要编写代码才能实现的功能，现在只需要声明需求即可由框架代为实现。\n- \n 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且\n\nSpring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基\n\n础上全部使用 Spring 来实现。\n\n2、Spring Framework五大 功能模块\n\n\n## p65 ioc思想和DI\n\nIOC：Inversion of Control，翻译过来是**反转控制**。\n\n**理解：**\n\n原来是我们自己获取容器资源，这就要求我们对我们需要获取的资源了如指掌\n\n现在反过来，资源自己给我们提供资源，我们不需要了解我们获取的资源，这波就是**反转**\n\n##### ①获取资源的传统方式\n\n自己做饭：买菜、洗菜、择菜、改刀、炒菜，全过程参与，费时费力，必须清楚了解资源创建整个过程中的全部细节且熟练掌握。\n\n在应用程序中的组件需要获取资源时，传统的方式是组件**主动**的从容器中获取所需要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率。\n\n##### ②反转控制方式获取资源\n\n点外卖：下单、等、吃，省时省力，不必关心资源创建过程的所有细节。\n\n反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向——改由容器主动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的**被动**形式。\n\n**很多时候，点外卖要比自己做的还要香，比如我们想要单例模式，以前要自己写，现在可以直接让Spring给我一个**\n\n##### ③DI\n\nDI：Dependency Injection，翻译过来是**依赖注入**。\n\nDI 是 IOC 的另一种表述方式：即组件以一些预先定义好的方式（例如：setter 方法）接受来自于容器的资源注入。相对于IOC而言，这种表述更直接。\n\n所以结论是：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种具体实现。\n\n## p66 ioc容器在Spring中的实现\n\nSpring 的 IOC 容器就是 IOC 思想的一个落地的产品实现。IOC 容器中管理的组件也叫做 bean。在创建bean 之前，首先需要创建 IOC 容器。Spring 提供了 IOC 容器的两种实现方式：\n\n##### ①BeanFactory\n\n这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，**不提供给开发人员使用**。\n\n##### ②ApplicationContext\n\nBeanFactory 的子接口，提供了更多高级特性。面向Spring 的使用者，几乎所有场合都使用ApplicationContext 而不是底层的 BeanFactory。\n\n##### ③ApplicationContext的主要实现类\n\n\n## p67 Spring的入门案例\n\n##### ①创建Maven Module\n\n##### ②引入依赖\n\n```java\n<dependencies>\n    <!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 -->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.3.1</version>\n    </dependency>\n    <!-- junit测试 -->\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n##### ③创建类HelloWorld\n\n```java\npublic class HelloWorld {\n    public void sayHello(){\n        System.out.println(\"helloworld\");\n    }\n}\n```\n\n##### ⑤在Spring的配置文件中配置bean\n\n新建spring的配置文件，最好命名为applicationContext\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/456034ef2d7935cf2a7bac2382f1ffdf.png)\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/88e042b456d04319db03783f9966812e.png)\n\n```java\n<!--\n\t配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理\n\t通过bean标签配置IOC容器所管理的bean\n\t属性：\n\t\tid：设置bean的唯一标识\n\t\tclass：设置bean所对应类型的全类名\n-->\n<bean id=\"helloworld\" class=\"com.atguigu.spring.bean.HelloWorld\"></bean>\n```\n\n##### ⑥创建测试类测试\n\n```java\n@Test\npublic void testHelloWorld(){\n    ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    HelloWorld helloworld = (HelloWorld) ac.getBean(\"helloworld\");\n    helloworld.sayHello();\n}\n```\n\n##### ⑦注意\n\nSpring 底层默认通过反射技术调用组件类的无参构造器来创建组件对象，这一点需要注意。如果在需要无参构造器时，没有无参构造器，则会抛出下面的异常：\n\n>org.springframework.beans.factory.BeanCreationException: Error creating bean with name\n\n## P68 iOC容器创建对象的方式\n\n一个普通的User类\n\n```java\n<bean id=\"User\" class=\"com.ice.spring.pojo.User\"></bean>\n```\n\n然后在测试类中：\n\n```java\n@Test\n    public void test(){\n        ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        User user=ac.getBean(User.class);\n        System.out.println(user);\n    }\n```\n\n## P69 获取bean的三种方式和注意事项\n\n我们最常用的是根据类型获取\n\n##### ①方式一：根据id获取\n\n由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。\n\n上个实验中我们使用的就是这种方式。\n\n##### ②方式二：根据类型获取\n\n```java\n@Test\npublic void testHelloWorld(){\n    ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    HelloWorld bean = ac.getBean(HelloWorld.class);\n    bean.sayHello();\n}\n```\n\n##### ③方式三：根据id和类型\n\n```java\n@Test\npublic void testHelloWorld(){\n    ApplicationContext ac = newClassPathXmlApplicationContext(\"applicationContext.xml\");\n    HelloWorld bean = ac.getBean(\"helloworld\", HelloWorld.class);\n    bean.sayHello();\n}\n```\n\n##### ④注意\n\n当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个\n\n当IOC容器中一共配置了两个：\n\n```java\n<bean id=\"helloworldOne\" class=\"com.atguigu.spring.bean.HelloWorld\"></bean>\n<bean id=\"helloworldTwo\" class=\"com.atguigu.spring.bean.HelloWorld\"></bean>\n```\n\n根据类型获取时会抛出异常：\n\n>org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean\n\n##### ⑤扩展\n\n如果组件类实现了接口，根据接口类型可以获取 bean 吗？\n\n>可以，前提是bean唯一\n\n如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？\n\n>不行，因为bean不唯一\n\n##### ⑥结论\n\n根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 **instanceof** 指定的类\n\n型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。\n\n## P70 依赖注入之setter注入\n\n在之前例子的基础上，在配置文件中配置bean的时候使用property标签配置属性值\n\n```java\n<bean id=\"User\" class=\"com.ice.spring.pojo.User\">\n        <property name=\"age\" value=\"12\"></property>\n        <property name=\"email\">\n            <value><![CDATA[2427328505@qq.com]]></value>\n        </property>\n    </bean>\n```\n\n## P71 依赖注入之构造器注入\n\n构造器注入用的不多\n\n##### ①在Student类中添加有参构造\n\n```java\npublic Student(Integer id, String name, Integer age, String sex) {\n    this.id = id;\n    this.name = name;\n    this.age = age;\n    this.sex = sex;\n}\n```\n\n##### ②配置bean\n\n```java\n<bean id=\"studentTwo\" class=\"com.atguigu.spring.bean.Student\">\n    <constructor-arg value=\"1002\"></constructor-arg>\n    <constructor-arg value=\"李四\"></constructor-arg>\n    <constructor-arg value=\"33\"></constructor-arg>\n    <constructor-arg value=\"女\"></constructor-arg>\n</bean>\n```\n\n>注意：\n\n##### ③测试\n\n```java\n@Test\npublic void testDIBySet(){\n    ApplicationContext ac = new ClassPathXmlApplicationContext(\"springdi.xml\");\n    Student studentOne = ac.getBean(\"studentTwo\", Student.class);\n    System.out.println(studentOne);\n}\n```\n\n## P72 依赖注入之特殊值处理\n\n##### 1 null\n\n```java\n<property name=\"name\">\n\t<null />\n</property>\n```\n\n>注意：\n\n##### 2 特殊字符\n\n当需要使用&lt; &gt;等字符时，需要避免这两个符号和xml标签中的&lt;&gt;的冲突\n\n方法1：\n\n```java\n<!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 -->\n<!-- 解决方案一：使用XML实体来代替 -->\n<property name=\"expression\" value=\"a &lt; b\"/>\n```\n\n方法2：\n\nCDATA节\n\n```java\n<property name=\"expression\">\n    <!-- 解决方案二：使用CDATA节 -->\n    <!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 -->\n    <!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 -->\n    <!-- 所以CDATA节中写什么符号都随意 -->\n    <value><![CDATA[a < b]]></value>\n</property>\n```\n\n## p73 为类类型属性赋值(引用外部bean)\n\n##### ①创建班级类Clazz\n\n```java\n@Data\npublic class Clazz implements Serializable {\n    private Integer clazzId;\n    private String clazzName;\n}\n```\n\n##### ②修改Student类\n\n在Student类中添加以下代码：\n\n```java\nprivate Clazz clazz;\npublic Clazz getClazz() {\n    return clazz;\n}\npublic void setClazz(Clazz clazz) {\n    this.clazz = clazz;\n}\n```\n\n##### ③方式一：引用外部已声明的bean\n\n配置Clazz类型的bean：\n\n```java\n<bean id=\"clazzOne\" class=\"com.atguigu.spring.bean.Clazz\">\n    <property name=\"clazzId\" value=\"1111\"></property>\n    <property name=\"clazzName\" value=\"财源滚滚班\"></property>\n</bean>\n```\n\n为Student中的clazz属性赋值：\n\n```java\n<bean id=\"studentFour\" class=\"com.atguigu.spring.bean.Student\">\n    <property name=\"id\" value=\"1004\"></property>\n    <property name=\"name\" value=\"赵六\"></property>\n    <property name=\"age\" value=\"26\"></property>\n    <property name=\"sex\" value=\"女\"></property>\n    <!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 -->\n    <property name=\"clazz\" ref=\"clazzOne\"></property>\n</bean>\n```\n\n错误演示：\n\n```java\n<bean id=\"studentFour\" class=\"com.atguigu.spring.bean.Student\">\n    <property name=\"id\" value=\"1004\"></property>\n    <property name=\"name\" value=\"赵六\"></property>\n    <property name=\"age\" value=\"26\"></property>\n    <property name=\"sex\" value=\"女\"></property>\n    <property name=\"clazz\" value=\"clazzOne\"></property>\n</bean>\n```\n\n>如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException:\n\n## p74 为类类型属性赋值（内部bean和级联的方式）\n\n##### ④方式二：内部bean\n\n```java\n<bean id=\"studentFour\" class=\"com.atguigu.spring.bean.Student\">\n    <property name=\"id\" value=\"1004\"></property>\n    <property name=\"name\" value=\"赵六\"></property>\n    <property name=\"age\" value=\"26\"></property>\n    <property name=\"sex\" value=\"女\"></property>\n    <property name=\"clazz\">\n        <!-- 在一个bean中再声明一个bean就是内部bean -->\n        <!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 -->\n        <bean id=\"clazzInner\" class=\"com.atguigu.spring.bean.Clazz\">\n            <property name=\"clazzId\" value=\"2222\"></property>\n            <property name=\"clazzName\" value=\"远大前程班\"></property>\n        </bean>\n    </property>\n</bean>\n```\n\n##### ③方式三：级联属性赋值\n\n```java\n<bean id=\"studentFour\" class=\"com.atguigu.spring.bean.Student\">\n    <property name=\"id\" value=\"1004\"></property>\n    <property name=\"name\" value=\"赵六\"></property>\n    <property name=\"age\" value=\"26\"></property>\n    <property name=\"sex\" value=\"女\"></property>\n    <!-- 一定先引用某个bean为属性赋值，才可以使用级联方式更新属性 -->\n    <property name=\"clazz\" ref=\"clazzOne\"></property>\n    <property name=\"clazz.clazzId\" value=\"3333\"></property>\n    <property name=\"clazz.clazzName\" value=\"最强王者班\"></property>\n</bean>\n```\n\n## p75 为数组类型赋值\n\n##### ①修改Student类\n\n在Student类中添加以下代码：\n\n```java\nprivate String[] hobbies;\npublic String[] getHobbies() {\n    return hobbies;\n}\npublic void setHobbies(String[] hobbies) {\n    this.hobbies = hobbies;\n}\n```\n\n##### ②配置bean\n\n```java\n<bean id=\"studentFour\" class=\"com.atguigu.spring.bean.Student\">\n    <property name=\"id\" value=\"1004\"></property>\n    <property name=\"name\" value=\"赵六\"></property>\n    <property name=\"age\" value=\"26\"></property>\n    <property name=\"sex\" value=\"女\"></property>\n    <!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 -->\n    <property name=\"clazz\" ref=\"clazzOne\"></property>\n    <property name=\"hobbies\">\n        <array>\n            <value>抽烟</value>\n            <value>喝酒</value>\n            <value>烫头</value>\n        </array>\n    </property>\n</bean>\n```\n\n## p76 为list集合类型赋值\n\n##### ①为List集合类型属性赋值\n\n在Clazz类中添加以下代码：\n\n```java\nprivate List<Student> students;\npublic List<Student> getStudents() {\n    return students;\n}\npublic void setStudents(List<Student> students) {\n    this.students = students;\n}\n```\n\n配置bean：\n\n```java\n<bean id=\"clazzTwo\" class=\"com.atguigu.spring.bean.Clazz\">\n    <property name=\"clazzId\" value=\"4444\"></property>\n    <property name=\"clazzName\" value=\"Javaee0222\"></property>\n    <property name=\"students\">\n        <list>\n            <ref bean=\"studentOne\"></ref>\n            <ref bean=\"studentTwo\"></ref>\n            <ref bean=\"studentThree\"></ref>\n        </list>\n    </property>\n</bean>\n```\n\n>若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可\n\n## p77 为map集合类型赋值\n\n##### ②为Map集合类型属性赋值\n\n创建教师类Teacher：\n\n```java\n@Data\npublic class Teacher implements Serializable {\n    private Integer teacherId;\n    private String teacherName;\n}\n```\n\n在Student类中添加以下代码：\n\n```java\nprivate Map<String, Teacher> teacherMap;\n```\n\n配置bean：\n\n```java\n<bean id=\"teacherOne\" class=\"com.atguigu.spring.bean.Teacher\">\n    <property name=\"teacherId\" value=\"10010\"></property>\n    <property name=\"teacherName\" value=\"大宝\"></property>\n</bean>\n<bean id=\"teacherTwo\" class=\"com.atguigu.spring.bean.Teacher\">\n    <property name=\"teacherId\" value=\"10086\"></property>\n    <property name=\"teacherName\" value=\"二宝\"></property>\n</bean>\n<bean id=\"studentFour\" class=\"com.atguigu.spring.bean.Student\">\n    <property name=\"id\" value=\"1004\"></property>\n    <!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 -->\n    <property name=\"clazz\" ref=\"clazzOne\"></property>\n    <property name=\"teacherMap\">\n        <map>\n            <entry>\n                <key>\n                    <value>10010</value>\n                </key>\n                <ref bean=\"teacherOne\"></ref>\n            </entry>\n            <entry>\n                <key>\n                    <value>10086</value>\n                </key>\n                <ref bean=\"teacherTwo\"></ref>\n            </entry>\n        </map>\n    </property>\n</bean>\n```\n\n##### ③引用集合类型的bean\n\n```java\n<!--list集合类型的bean-->\n<util:list id=\"students\">\n    <ref bean=\"studentOne\"></ref>\n    <ref bean=\"studentTwo\"></ref>\n    <ref bean=\"studentThree\"></ref>\n</util:list>\n<!--map集合类型的bean-->\n<util:map id=\"teacherMap\">\n    <entry>\n        <key>\n            <value>10010</value>\n        </key>\n        <ref bean=\"teacherOne\"></ref>\n    </entry>\n    <entry>\n        <key>\n            <value>10086</value>\n        </key>\n        <ref bean=\"teacherTwo\"></ref>\n    </entry>\n</util:map>\n<bean id=\"clazzTwo\" class=\"com.atguigu.spring.bean.Clazz\">\n    <property name=\"students\" ref=\"students\"></property>\n</bean>\n<bean id=\"studentFour\" class=\"com.atguigu.spring.bean.Student\">\n    <!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 -->\n    <property name=\"clazz\" ref=\"clazzOne\"></property>\n    <property name=\"hobbies\">\n        <array>\n            <value>抽烟</value>\n            <value>喝酒</value>\n            <value>烫头</value>\n        </array>\n    </property>\n    <property name=\"teacherMap\" ref=\"teacherMap\"></property>\n</bean>\n```\n\n>使用util:list、util:map标签必须引入相应的命名空间，可以通过idea的提示功能选择\n\n## p78 依赖注入之p命名空间\n\n这个基本上不用，简单了解\n\n引入p命名空间后，可以通过以下方式为bean的各个属性赋值\n\n```java\n<bean id=\"studentSix\" class=\"com.atguigu.spring.bean.Student\"\n      p:id=\"1006\" p:name=\"小明\" p:clazz-ref=\"clazzOne\" p:teacherMap-ref=\"teacherMap\"></bean>\n```\n\n## p79 spring管理数据源和引入外部文件\n\n##### ①加入依赖\n\n```java\n<!-- MySQL驱动 -->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.16</version>\n</dependency>\n<!-- 数据源 -->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.0.31</version>\n</dependency>\n```\n\n##### ②创建外部属性文件\n\njdbc.properties\n\n```java\njdbc.user=root\njdbc.password=atguigu\njdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC\njdbc.driver=com.mysql.cj.jdbc.Driver\n```\n\n##### ③引入属性文件\n\n```java\n<!-- 引入外部属性文件 -->\n<context:property-placeholder location=\"classpath:jdbc.properties\"/>\n```\n\n##### ④配置bean\n\n```java\n<bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n    <property name=\"url\" value=\"${jdbc.url}\"/>\n    <property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\n    <property name=\"username\" value=\"${jdbc.user}\"/>\n    <property name=\"password\" value=\"${jdbc.password}\"/>\n</bean>\n```\n\n##### ⑤测试\n\n```java\n@Test\npublic void testDataSource() throws SQLException {\n    ApplicationContext ac = new ClassPathXmlApplicationContext(\"spring-datasource.xml\");\n    DataSource dataSource = ac.getBean(DataSource.class);\n    Connection connection = dataSource.getConnection();\n    System.out.println(connection);\n}\n```\n\n## p80 bean的作用域\n\n##### ①概念\n\n在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：\n\n\n如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：\n\n\n##### ②创建类User\n\n```java\n@Data\npublic class User implements Serializable {\nprivate Integer id;\nprivate String username;\nprivate String password;\nprivate Integer age;\n}\n```\n\n##### ③配置bean\n\n```java\n<!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建\n对象 -->\n<!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 -->\n<bean class=\"com.atguigu.bean.User\" scope=\"prototype\"></bean>\n```\n\n##### ④测试\n\n```java\n@Test\npublic void testBeanScope(){\n    ApplicationContext ac = new ClassPathXmlApplicationContext(\"spring-scope.xml\");\n    User user1 = ac.getBean(User.class);\n    User user2 = ac.getBean(User.class);\n    System.out.println(user1==user2);\n}\n```\n\n## p81-82 bean的生命周期\n\n生命周期了解即可，这里复制笔记\n\n##### ①具体的生命周期过程\n\n- bean对象创建（调用无参构造器）\n- 给bean对象设置属性\n- bean对象初始化之前操作（由bean的后置处理器负责）\n- bean对象初始化（需在配置bean时指定初始化方法）\n- bean对象初始化之后操作（由bean的后置处理器负责）\n- bean对象就绪可以使用\n- bean对象销毁（需在配置bean时指定销毁方法）\n- IOC容器关闭\n\n##### ②修改类User\n\n```java\npublic class User {\n    private Integer id;\n    private String username;\n    private String password;\n    private Integer age;\n    public User() {\n        System.out.println(\"生命周期：1、创建对象\");\n    }\n    public User(Integer id, String username, String password, Integer age) {\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.age = age;\n    }\n    public Integer getId() {\n        return id;\n    }\n    public void setId(Integer id) {\n        System.out.println(\"生命周期：2、依赖注入\");\n        this.id = id;\n    }\n    public String getUsername() {\n        return username;\n    }\n    public void setUsername(String username) {\n        this.username = username;\n    }\n    public String getPassword() {\n        return password;\n    }\n    public void setPassword(String password) {\n        this.password = password;\n    }\n    public Integer getAge() {\n        return age;\n    }\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n    public void initMethod(){\n        System.out.println(\"生命周期：3、初始化\");\n    }\n    public void destroyMethod(){\n        System.out.println(\"生命周期：5、销毁\");\n    }\n    @Override\n    public String toString() {\n        return \"User{\" +\n            \"id=\" + id +\n            \", username='\" + username + '\\'' +\n            \", password='\" + password + '\\'' +\n            \", age=\" + age +\n            '}';\n    }\n}\n```\n\n>注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法\n\n##### ③配置bean\n\n```java\n<!-- 使用init-method属性指定初始化方法 -->\n<!-- 使用destroy-method属性指定销毁方法 -->\n<bean class=\"com.atguigu.bean.User\" scope=\"prototype\" init-method=\"initMethod\"destroy-method=\"destroyMethod\">\n    <property name=\"id\" value=\"1001\"></property>\n    <property name=\"username\" value=\"admin\"></property>\n    <property name=\"password\" value=\"123456\"></property>\n    <property name=\"age\" value=\"23\"></property>\n</bean>\n```\n\n##### ④测试\n\n```java\n@Test\npublic void testLife(){\n    ClassPathXmlApplicationContext ac = newClassPathXmlApplicationContext(\"spring-lifecycle.xml\");\n    User bean = ac.getBean(User.class);\n    System.out.println(\"生命周期：4、通过IOC容器获取bean并使用\");\n    ac.close();\n}\n```\n\n##### ⑤bean的后置处理器\n\nbean的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口，\n\n且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行\n\n创建bean的后置处理器：\n\n```java\npackage com.atguigu.spring.process;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\npublic class MyBeanProcessor implements BeanPostProcessor {\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(\"☆☆☆\" + beanName + \" = \" + bean);\n        return bean;\n    }\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(\"★★★\" + beanName + \" = \" + bean);\n        return bean;\n    }\n}\n```\n\n在IOC容器中配置后置处理器：\n\n>&lt;bean id=\"myBeanProcessor\"class=“com.atguigu.spring.process.MyBeanProcessor”/&gt;\n\n## p83 FactoryBean\n\n##### ①简介\n\nFactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。\n\n将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。\n\n##### ②创建类UserFactoryBean\n\n```java\npublic class UserFactoryBean implements FactoryBean<User> {\n    @Override\n    public User getObject() throws Exception {\n        return new User();\n    }\n    @Override\n    public Class<?> getObjectType() {\n        return User.class;\n    }\n}\n```\n\n##### ③配置bean\n\n```java\n<bean id=\"user\" class=\"com.atguigu.bean.UserFactoryBean\"></bean>\n```\n\n##### ④测试\n\n```java\n@Test\npublic void testUserFactoryBean(){\n    //获取IOC容器\n    ApplicationContext ac = new ClassPathXmlApplicationContext(\"spring-factorybean.xml\");\n    User user = (User) ac.getBean(\"user\");\n    System.out.println(user);\n}\n```\n\n## p84-86 基于xml的自动装配\n\n自动装配的意思是：\n\n本来一个UserCoontroller中有个对象是UserService\n\n本来配置bean的时候需要用来配置这个对象，现在添加一个byName或者byType就可以自动装配了\n\nbytype:controller中有一个UserService，然后配置文件（配置bean的xml）中有一个类型是UserService，就会自动配置这个\n\n>自动装配：\n\n##### ①场景模拟\n\n创建类UserController\n\n```java\npublic class UserController {\n    private UserService userService;\n    public void setUserService(UserService userService) {\n        this.userService = userService;\n    }\n    public void saveUser(){\n        userService.saveUser();\n    }\n}\n```\n\n创建接口UserService\n\n```java\npublic interface UserService {\n\tvoid saveUser();\n}\n```\n\n创建类UserServiceImpl实现接口UserService\n\n```java\npublic class UserServiceImpl implements UserService {\n    private UserDao userDao;\n    public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n    @Override\n    public void saveUser() {\n        userDao.saveUser();\n    }\n}\n```\n\n创建接口UserDao\n\n```java\npublic interface UserDao {\n\tvoid saveUser();\n}\n```\n\n创建类UserDaoImpl实现接口UserDao\n\n```java\npublic class UserDaoImpl implements UserDao {\n    @Override\n    public void saveUser() {\n        System.out.println(\"保存成功\");\n    }\n}\n```\n\n##### ②配置bean\n\n>使用bean标签的autowire属性设置自动装配效果\n\n```java\n<bean id=\"userController\"class=\"com.atguigu.autowire.xml.controller.UserController\" autowire=\"byType\">\n</bean>\n<bean id=\"userService\"class=\"com.atguigu.autowire.xml.service.impl.UserServiceImpl\" autowire=\"byType\">\n</bean>\n<bean id=\"userDao\" class=\"com.atguigu.autowire.xml.dao.impl.UserDaoImpl\"></bean>\n```\n\n>自动装配方式：byName\n\n```java\n<bean id=\"userController\"class=\"com.atguigu.autowire.xml.controller.UserController\" autowire=\"byName\">\n</bean>\n<bean id=\"userService\"class=\"com.atguigu.autowire.xml.service.impl.UserServiceImpl\" autowire=\"byName\">\n</bean>\n<bean id=\"userServiceImpl\"class=\"com.atguigu.autowire.xml.service.impl.UserServiceImpl\" autowire=\"byName\">\n</bean>\n<bean id=\"userDao\" class=\"com.atguigu.autowire.xml.dao.impl.UserDaoImpl\">\n</bean>\n<bean id=\"userDaoImpl\" class=\"com.atguigu.autowire.xml.dao.impl.UserDaoImpl\">\n</bean>\n```\n\n##### ③测试\n\n```java\n@Test\npublic void testAutoWireByXML(){\n    ApplicationContext ac = new ClassPathXmlApplicationContext(\"autowire-xml.xml\");\n    UserController userController = ac.getBean(UserController.class);\n    userController.saveUser();\n}\n```\n\n## p87-89 基于注解管理的注解和扫描\n\n介绍：在类上添加一个注解，然后在spring的配置文件中扫描到这个类，然后spring就会自动执行操作（不需要自己写bean了）\n\n##### ③新建Maven Module\n\n```java\n<dependencies>\n    <!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 -->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.3.1</version>\n    </dependency>\n    <!-- junit测试 -->\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n##### ④创建Spring配置文件\n\n##### ⑤标识组件的常用注解\n\n>@Component：将类标识为普通组件\n\n问：以上四个注解有什么关系和区别？\n\n@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。\n\n对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。\n\n注意：虽然它们本质上一样，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。\n\n##### ⑥创建组件\n\n创建控制层组件\n\n```java\n@Controller\npublic class UserController {\n}\n```\n\n创建接口UserService\n\n```java\npublic interface UserService {\n}\n```\n\n创建业务层组件UserServiceImpl\n\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n}\n```\n\n创建接口UserDao\n\n```java\npublic interface UserDao {\n}\n```\n\n创建持久层组件UserDaoImpl\n\n```java\n@Repository\npublic class UserDaoImpl implements UserDao {\n}\n```\n\n##### ⑦扫描组件\n\n情况一：最基本的扫描方式\n\n记录4: beans的命名空间中，在使用扫描包时，要引入的命名空间为\n\n xmlns:context=“http://www.springframework.org/schema/context”\n\n和\n\n http://www.springframework.org/schema/context\n ​ http://www.springframework.org/schema/context/spring-context-4.2.xsd\n ​\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context-4.2.xsd\n         \">\n   <context:component-scan base-package=\"com.ice\">\n   </context:component-scan>\n</beans>\n<context:component-scan base-package=\"com.atguigu\">\n</context:component-scan>\n```\n\n情况二：指定要排除的组件\n\n```java\n<context:component-scan base-package=\"com.atguigu\">\n    <!-- context:exclude-filter标签：指定排除规则 -->\n    <!--\n        type：设置排除或包含的依据\n        type=\"annotation\"，根据注解排除，expression中设置要排除的注解的全类名\n        type=\"assignable\"，根据类型排除，expression中设置要排除的类型的全类名\n    -->\n    <context:exclude-filter type=\"annotation\"expression=\"org.springframework.stereotype.Controller\"/>\n    <!--<context:exclude-filter type=\"assignable\"expression=\"com.atguigu.controller.UserController\"/>-->\n</context:component-scan>\n```\n\n情况三：仅扫描指定组件\n\n```java\n<context:component-scan base-package=\"com.atguigu\" use-default-filters=\"false\">\n    <!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 -->\n    <!-- use-default-filters属性：取值false表示关闭默认扫描规则 -->\n    <!-- 此时必须设置use-default-filters=\"false\"，因为默认规则即扫描指定包下所有类 -->\n    <!--\n        type：设置排除或包含的依据\n        type=\"annotation\"，根据注解排除，expression中设置要排除的注解的全类名\n        type=\"assignable\"，根据类型排除，expression中设置要排除的类型的全类名\n     -->\n    <context:include-filter type=\"annotation\"expression=\"org.springframework.stereotype.Controller\"/>\n    <!--<context:include-filter type=\"assignable\"expression=\"com.atguigu.controller.UserController\"/>-->\n</context:component-scan>\n```\n\n##### ⑧测试\n\n```java\n@Test\npublic void testAutowireByAnnotation(){\n    ApplicationContext ac = new\n        ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    UserController userController = ac.getBean(UserController.class);\n    System.out.println(userController);\n    UserService userService = ac.getBean(UserService.class);\n    System.out.println(userService);\n    UserDao userDao = ac.getBean(UserDao.class);\n    System.out.println(userDao);\n}\n```\n\n## p90 基于注解管理bean之bean的id\n\n##### ⑨组件所对应的bean的id\n\n在我们使用XML方式管理bean的时候，每个bean都有一个唯一标识，便于在其他地方引用。现在使用\n\n注解后，每个组件仍然应该有一个唯一标识。\n\n>默认情况\n\n## p91-93 基于注解的自动装配\n\n@Autowired自动装配的作用\n\n原来Controller中调用Service：\n\n```java\npublic class UserController {\n    private UserService userService;\n    public void setUserService(UserService userService) {\n        this.userService = userService;\n    }\n    public void saveUser(){\n        userService.saveUser();\n    }\n}\n```\n\n现在：\n\n```java\npublic class UserController {\n    @Autowired\n    private UserService userService; \n}\n```\n\n##### ①场景模拟\n\n>参考基于xml的自动装配\n\n##### ②@Autowired注解\n\n在成员变量上直接标记@Autowired注解即可完成自动装配，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。\n\n```java\n@Controller\npublic class UserController {\n    @Autowired\n    private UserService userService;\n    public void saveUser(){\n        userService.saveUser();\n    }\n}\n```\n\n```java\npublic interface UserService {\n    void saveUser();\n}\n@Service\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserDao userDao;\n    @Override\n    public void saveUser() {\n        userDao.saveUser();\n    }\n}\n```\n\n```java\npublic interface UserDao {\n\tvoid saveUser();\n}\n```\n\n```java\n@Repository\npublic class UserDaoImpl implements UserDao {\n    @Override\n    public void saveUser() {\n        System.out.println(\"保存成功\");\n    }\n}\n```\n\n##### ③@Autowired注解其他细节\n\n>@Autowired注解可以标记在构造器和set方法上\n\n```java\n@Controller\npublic class UserController {\n    private UserService userService;\n    @Autowired\n    public UserController(UserService userService){\n        this.userService = userService;\n    }\n    public void saveUser(){\n        userService.saveUser();\n    }\n}\n```\n\n```java\n@Controller\npublic class UserController {\n    private UserService userService;\n    @Autowired\n    public void setUserService(UserService userService){\n        this.userService = userService;\n    }\n    public void saveUser(){\n        userService.saveUser();\n    }\n}\n```\n\n##### ④@Autowired工作流程\n\n- 首先根据所需要的组件类型到IOC容器中查找 \n <ul>\n  - 能够找到唯一的bean：直接执行装配\n  - 如果完全找不到匹配这个类型的bean：装配失败\n  - 和所需类型匹配的bean不止一个 \n   <ul>\n    - 没有@Qualifier注解：根据@Autowired标记位置成员变量的变量名作为bean的id进行匹配\n    - 能够找到：执行装配\n    - 找不到：装配失败\n    - 使用@Qualifier注解：根据@Qualifier注解中指定的名称作为bean的id进行匹配\n    - 能够找到：执行装配\n    - 找不到：装配失败\n   </ul>\n </ul>\n\n```java\n@Controller\npublic class UserController {\n    @Autowired\n    @Qualifier(\"userServiceImpl\")\n    private UserService userService;\n    public void saveUser(){\n        userService.saveUser();\n    }\n}\n```\n\n>@Autowired中有属性required，默认值为true，因此在自动装配无法找到相应的bean时，会装配失败\n\n","tags":["java","mybatis","spring"]},{"title":"尚硅谷vue笔记 详细讲解版（尚硅谷 天禹老师）","url":"/2023/05/31/尚硅谷vue笔记 详细讲解版（尚硅谷 天禹老师）/","content":"\n\n视频：【尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通】https://www.bilibili.com/video/BV1Zy4y1K7SH?vd_source=10e3dfac95ac3a6883b1f8a6c3bc65d5\n\n>看了很多市面上以后的笔记，大多都是复制粘贴代码，让我看的知其然而不知其所以然，于是打算自己写一下这个课程的笔记，把一些老师的讲解结合自己的理解也写下来\n\n教程内容：\n\n1.vue基础\n 2.vue-cli\n 3.vue-router\n 4.vuex\n 5.element-ui\n 6.vue3\n\n注：因为笔者学习过程中需要参与一个小项目，该项目需要使用到vue，但是记详细的讲解比较较为耗时，所以在1.10之后的笔记是只记录使用方法和案例，不添加详细讲解。实际上，您可以直接访问官网的文档教程，如果您看了我的笔记的1.10之前的内容，理解官网的教程应该就比较简单了，如果有不理解的，再去看老师的讲解视频，个人觉得这是较快的学习方法（当然 ，时间充裕的，最好去听老师讲的课）\n\n## 第1章 vue核心\n\n### 1.1 vue简介\n\n#### 1.1.1vue是什么\n\n一套用于构建用户界面的渐进式js框架\n\n- \n 构建用户界面：我只关注，你把数据给我，我怎么把数据变成界面\n- \n 渐进式：可以自底向上逐层应用：\n <ul>\n  - 简单应用：只需要一个小巧的核心库\n  - 复杂应用：可以引入各式各样的vue插件\n </ul>\n\n#### 1.1.2 谁开发的\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/6ffa67589a68032c270d63f22ca461e3.png)\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/f6378ccf6a3e525860e3126b512eec9d.png)\n\n#### 1.1.3 vue的特点\n\n1. 采用组件化模式，提高代码复用率、且让代码更好维护。\n\n组件化：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/706266efb6145fd4b38a793da20f070e.png)\n\n以后其他人想用这个activity功能，直接应用我的这个文件就行\n\n更好维护：哪个部分出了问题，就到哪个组件维护\n\n1. 声明式编码，让编码人员无需直接操作DOM,提高开发效率。\n\njs：用代码拼接html 这是命令式编码\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/1a847ad915313efa100a405e72202883.png)\n\n命令式：同学，我渴了，你往前走两步，到饮水机面前，拿出杯子，倒点水，回头走到我旁边，往我嘴里倒水\n\n声明式：同学，我渴了。然后同学就把水装给我了\n\n1. 使用虚拟DOM+优秀的Dif算法，尽量复用DOM节点。\n\n咱们还是用js举例\n\n原来你声明了变量，赋值以后写到html页面上，之后，如果你的数据变了，刷新页面的时候，相当于把原来的删除了，又从头添加了数据。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/fc3bcf9c93f4d5b86afcdb6d39017ec1.png)\n\n而vue呢，先把三个数据转换成虚拟dom，然后再转换成页面中的真实dom\n\n数据变化之后，又生成了新的虚拟dom，他会把新的虚拟dom和原来的dom进行比较，然后会把原本的数据复用，再添加上多出来的dom（这里的赵六）\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/224600aeba3fef4ca0ce714e84ce9c1e.png)\n\n1. 学习Vue之前要掌握的javaScript基础知识：\n    ES6语法规范 结构函数，模板字符串，箭头函数\n    ES6模块化 默认暴露，同意暴露，分别暴露\n    包管理器 npm yarn cnpm\n    原型、原型链\n    数组常用方法 过滤一个数组，\n    axios\n    promise\n\n当然，如果哪个不会，老师也会简单回顾一下\n\n#### 1.1.4 vue网站简单了解（vue2文档）\n\n [Vue.js (vuejs.org)](https://v2.cn.vuejs.org/)\n\n1. 教程\n\n按照教程说的一步一步来\n\n1. API\n\n不会的就找字典\n\n1. 风格指南\n\n会教你怎么写出优雅的vue代码\n\n1. 示例\n\n看示例的时候，往右划一划，就能看到代码\n\n1. cookbook\n\n编码技巧： 1 js基本功 2 vue代码一些小技巧\n\n指南和cookbook的不同：指南教你什么好，什么不好；cookbook教你实用的技巧\n\n1. 工具 核心插件\n\n公司开发时用到的 ，很重要\n\n1. Awssome vue/浏览和vue相关的包\n\n很多vue的周边库（steam的创意工坊）\n\n#### 1.1.5 搭建vue开发环境\n\n根据文档，安装\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/6326b5cecd4c31a87e507cefcb4ca6ca.png)\n\n我们可以看到，一个是直接scipt引入vue，另外一个是使用npm安装\n\n咱们先直接用引用\n\n开发时，最好使用开发版本\n\n点击后，自动下载，上面的是开发版，下面的是生产版，过会会进行对比\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/e81eb19d7e71811a6e62b123382eca37.png)\n\nok，我们在桌面新建一个文件夹，叫vue_basic\n\n用vs code打开（不会有人前端已经学到vue了还不知道什么是vscode吧，不会吧不会吧）\n\n把两个文件放在js文件夹中，新建html文件，新建完，！＋回车；html结构就出来了\n\n**文件夹结构：**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/20f8b91831c1400743a5846ecc82f66e.png)\n\n**引入vue**\n\n```java\n<script type=\"text/javascript\" src=\"../js/vue.js\"></script>\n```\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/700fe6ac51c40767251a5e91d4d74d82.png)\n\n如何证明我们引入了vue呢？\n\n右键，在浏览器中打开（记得CTRL+s保存）\n\nf12查看控制台，可以看到两个提示，一个说建议用开发工具开发vue，另一个说引入的vue有点大，不建议在生产环境中使用\n\n输入vue，敲回车，发现有了构造方法，说明引用成功了\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/d89d7918a8a29b0081804ea06baf88af.png)\n\n说回刚刚的问题，如何下载浏览器vue的开发工具，edge下载扩展\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/a89c14e0d1b89a361145d7ac944ca636.png)\n\n还要点上允许文件访问\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/22d85031fe7355c4d579da082ea63a84.png)\n\n另外一个提示我们如何隐藏呢，这是vue的全局配置中的一个属性，我们可以在文件中修改默认值\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/8f8379d4ba3587968cdb4bb879522837.png)\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/6167d1e067b1cb1dc926951025246b25.png)\n\n### 1.2 初识vue\n\n#### 1.2.1 vue小案例\n\n首先，我们要添加一个存放页面的容器\n\n容器，一般在11行，是一切的开始\n\n输入 div#root 回车 得到：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/17b7c83a6c3b20bc222fc5e8c9df8cb4.png)\n\n创建一个Vue对象 在19行\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/f840a69e62fc1c73c55279fd513047d1.png)\n\n然后我们需要\n\n##### 配置对象\n\n>什么叫配置对象：对象中有需要配置的属性：如anxios中要配置url，这个url你不能写成ura，因为不存在这个属性，url对应的值写在’'中，这是有规范的\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/97cb6e00cf754db52f7567b3b6f0ae09.png)\n\n好，我们开始写vue的配置对象\n\n\nel是element的简称，里面的#root类似于css中的id选择器，没有第二十行的这个配置的时候，vue对象和id为root的容器是互相看不到的，加上之后，他们就互相匹配了\n\n>el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/a3ce09ea15a9004ddfb1b4dee906fdaf.png)\n\n\n我们之前在容器中写的是hhh，那我们想在我们的实例中动态的存放那个位置填写的文字，怎么办呢\n\n很自然的，第二个属性：data\n\n>data中用于存储数据，数据供el所指定的容器去使用,值我们暂时先写成一个对象(以后可能写成一个函数)\n\n这里用到了双大括号（插值语法，后面会讲到），这个实际上就是分隔符区分data的数据\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/4852cba99f2e3295dae33e6c6d402d30.png)\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/b2f29c54b76481c6a35e4b1221b63fbf.png)\n\n写到这我们发现，const x一点用也没有，我们可以去掉，完全不受影响\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/702f208523e89709e9c1099c6a8a965d.png)\n\n##### 总结\n\n1. \n 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象：\n2. \n root容器里的代码依然符html规范只不过混入了一些特殊的vue语法：\n3. \n root容器里的代码被称为【Vue模板】\n\n#### 1.2.2 分析小案例\n\n1. 容器和实例之间的关系是一对一的，一一对应\n2. 以后如果数据多了，会有组件功能来分担数据\n3. =={<!-- -->{}}==中必须写成js表达式\n\n区分js表达式和js代码\n\n- js表达式：可以生成一个值，可以放在任何一个需要值的地方 \n <ul>\n  - a\n  - a+b\n  - Data.now() 生成当前时间戳\n  - demo(1) 函数调用表达式\n  - x==y ? ‘a’:‘b’ 三元表达式\n  - 以上的东西都是可以在左边用一个const x= 接住的\n </ul>\n- js代码（语句） \n <ul>\n  - if(){}\n  - for(){}\n </ul>\n\n1. vue开发者工具\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/d0ab333a05b1f7c31fd0814c5377947e.png)\n\n可以直接在这里修改数据\n\n1. 一旦data中的数据发生改变，那么模板中用到该数据的地方也会自动更新\n\n### 1.3 模板语法\n\n#### 1.3.1 效果\n\n实际上，模板语法有两大类，一类就是{<!-- -->{}}，插值语法\n\n还有一类叫指令语法\n\n比如，我们想在一个<a href=\"\"></a>标签里，动态存入href的值，该怎么做呢，第一反应肯定是加一个{<!-- -->{}}，我们试试看：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/3ba4c05c333ebabb8457ca2dbbd3b621.png)\n\n我们发现，并没有帮我转换，看一下控制台的报错：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/c0a261fb52e24b50867df79659ef6859.png)\n\n说以前这样子写是可以的，但是现在不行了，建议我们用v-bind或者：来写\n\n#### 1.3.2 指令语法\n\n引入 v-bind：\n\n我们在href前添加v-bind:\n\n```java\n<a v-bind:href=\"url\">点我跳转</a>\n```\n\n发现url动态的显示在href中了：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/74268564bce98ebb1d87d91eb3bffa5e.png)\n\n><code>v-bind:</code>后的属性值后的双引号中的也是js表达式,且可以简写为 <code>：</code>\n\n简写：\n\n```java\n<a :href=\"url\">点我跳转</a>\n```\n\n>插值模板主要用在标签体中\n\n总结：\n\nVue模板语法有2大类：\n 1.插值语法：\n 功能：用于解析标签体内容。\n 写法：{<!-- -->{xxx}}:xx是的s表达式。且可以直接读取到data中的所有属性。\n 2.指令语法：\n 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）。\n 举例：v-bind:href=\"xxx\"域筒写为：:href=\"xxx\",xxx同样要列js表达式，且以直接读取到data中的所有属性.\n 备注：Vue中有根多的指令，且形式都是：v-???,此处我们只是拿v-bind举个例子。\n\n如果一个页面有多个地方，需要name这个变量怎么办：\n\n我们可以name1，name2但是可读性不高，所以我们可以在data中再新建对象，如图：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/53f05c3411dafca26b6fdad005377129.png)\n\n使用这样的方法区分不同的变量\n\n### 1.4 数据绑定\n\n#### 1.4.1 单向数据绑定\n\nv-bind是单向数据绑定\n\n<input v-bind:value=\"name\">\n\n在这个input框中填写数据，data中name的值不会变，因为数据只能从data中到v-bind中\n\n实例1：\n\n容器：\n\n```java\n<div id=\"root\">\n      <input v-bind:value=\"name\" />\n      <hr/>\n      {{name}}\n    </div>\n```\n\n一开始：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/5409733eb469421b4752b887bbe1bdd3.png)\n\ninput中输入数据后：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/d92660a4834c7132d31b82e98117bb26.png)\n\n#### 1.4.2 双向数据绑定\n\n引出新的指令模板 v-model\n\n```java\n<input v-model:value=\"name\" />\n```\n\nv-model可以双向绑定，即在value中的数据也可以同步到data中：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/79585676cc85ceb9b5c07fc3a6390c05.png)\n\n总结：\n\nv-model只能用在表单类元素中（输入类元素）\n\n也就是说，有一个属性是value的元素\n\nv-model:value=可以简写成v-model=\n\n### 番外 el和data的两种写法\n\n正常说讲到组件才要讲这个，但是组件内容太多了，所以拆到这里说一下\n\n#### el\n\n之前我们是在data中，通过el属性来绑定vue实例和容器的。\n\n除此之外，我们可以通过挂载的方式绑定\n\n```java\n<script>     \n//创建Vue实例\n      const v = new Vue({\n        data: {\n          name: \"五六七\",\n        },\n      });\n      v.$mount(\"#root\");\n    </script>\n```\n\nv.$mount的这个操作叫挂载\n\n这两种方式都可以，第二种比较灵活一点\n\n#### data\n\n原来的方法：\n\n```java\ndata:{\nname:''\n}\n<script>\n const v = new Vue({\n        data:{\n\t\t\tname:''\n\t\t\t}\n      });\n      v.$mount(\"#root\");\n</script>\n```\n\n这是对象式写法，还有一种写法，叫函数式\n\n函数式：\n\n```java\n<script>\n const v = new Vue({\n        data: function(){\n            return{\n                name:'尚硅谷'\n            }\n        }\n      });\n      v.$mount(\"#root\");\n</script>\n```\n\nel 两种方法都可以\n\n但是data，**以后用到组件的时候，只可以用函数式**，不然会报错，我们到时候会讲到\n\n由vue管理的函数，不可以用箭头函数（es6中的东西），写了箭头函数后，this就不再是vue实例了\n\n### 1.5 MVVM模型\n\nVue的设计受到了MVVM模型的启发，设计时参考了这个模型\n\n1. M 模型（model） 对应data中的数据\n2. V 视图（View） 模板（页面结构）\n3. VM 视图模型（ViewModel） Vue实例对象\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/4fb8a61c053f169d3d9dc292302f03f1.png)\n\n其实主流的前端框架都是这样\n\n所以我们经常使用vm这个变量名表示Vue实例\n\n**观察发现：**\n 1.data中所有的属性，最后都出现在了vm身上.\n 2.vm身上所有的属性及Vue原型上所有属性，在Vue模版中都可以直接使用.\n\nconsole.log一下vue实例\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/95024a9805846a24d4c38e58ca804034.png)\n\n下面这些v的属性数据都可以写在模板中\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/a9c222ac0fd6a0f4b24c1e65671bfd1f.png)\n\n原型中的也可以写在里面（当然，写也没什么意义，这些是用来调用的方法）\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/8e099711dd7727edaa5d2c06193aa376.png)\n\n### 1.6 数据代理\n\n#### 1.6.1 回顾 Object.defineProperty方法\n\n用于给对象添加属性\n\n需要三个参数\n\n第一个是对象 第二个是属性名 第三个是配置项\n\n```java\n<script type=\"text/javascript\">\n\n        let person={\n            age:'18',\n            name:'桃桃'\n        }\n        Object.defineProperty(person,'sex',{\n            value:'女'\n        })\n        console.log(person)\n    </script>\n```\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/dd2a7b36d2364acfa34058f96154891b.png)\n\n用这种方法添加的属性，在遍历时不会参与遍历\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/b9c1c7386aab47fb0613664f4a4c092b.png)\n\n如果想要这个属性也可以参与遍历，在用方法添加时，在配置项中添加一个叫**enumerable**的属性\n\n```java\n<script>\nObject.defineProperty(person,'sex',{\n            value:'女',\n            enumerable:true\n        })\n    </script>\n```\n\n用这种方法添加的属性，值也是不可以修改的：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/a316074dd9bfad18fdab0508acf1d580.png)\n\n要是想修改，添加属性**writable**\n\n同理，也无法删除，想要删除，添加属性**configurable**\n\n这些是基本的配置项，除此之外，我们可以添加一些高级的配置项 get set\n\n比如我们不想要age的值是固定的，我们想要age的值是取决于一个叫做number的变量，然后number的值变了，age的值就会变，我们怎么写呢\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/e0818c9e32a87a86dfa362cf186093be.png)\n\n我们现在想要number值变了，我们的值也变，怎么办呢，使用Object.defineProperty方法配置项中的get属性\n\n```java\n<script type=\"text/javascript\">\n      let number = \"女\";\n      let person = {\n        age: \"18\",\n        name: \"桃桃\",\n      };\n      Object.defineProperty(person, \"sex\", {\n        // enumerable:true,\n        // writable:true,\n        // configurable:true\n        get:function(){\n            return number\n        }\n      });\n      console.log(person);\n    </script>\n```\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/19f87c0aa29c90c6bab047fa54f56b3e.png)\n\n每一次访问sex，都会触发get方法的调用\n\nset方法：\n\n```java\n<script type=\"text/javascript\">\n      let number = \"女\";\n      let person = {\n        age: \"18\",\n        name: \"桃桃\",\n      };\n      Object.defineProperty(person, \"sex\", {\n        // enumerable:true,\n        // writable:true,\n        // configurable:true\n        get:function(){\n            return number\n        },\n        set:function(value){\n            number=value\n        }\n      });\n      console.log(person);\n    </script>\n```\n\n每次有人修改sex的值，都会调用set方法\n\n#### 1.6.2 何为数据代理\n\n通过一个对象代理对另一个对象中属性的操作\n\n比如有一个obj1对象，其中一个属性是x，我们想通过另一个obj2对象来获取和修改obj1中x属性的值，应该怎么做呢，这就可以用到上面学的东西\n\n```java\n<script type=\"text/javascript\">\n       let obj1={x:100}\n       let obj2={y:200}\n       Object.defineProperty(obj2,'x',{\n        get(){\n            return obj1.x;\n        },\n        set(value){\n            obj1.x=value;\n        }\n       })\n      </script>\n```\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/c4405de5434750c9476f19db154c83e0.png)\n\n>模板语法中数据的值（data属性中数据的值）就是通过数据代理存放到vm（vue实例）中的\n\n#### 1.6.3 数据代理在vue中的使用\n\n1.Vue中的数据代理：\n 通过VM对象代理data对像中属性的操作（读/写）\n 2.Vue中数据代理的好处：\n 更加方便的操作data中的数据\n 3.基本原理：\n 通过Object,defineProperty()把data对象中所有属性添加到外vm上，\n 为每一个添加到vm上的属性，都指定一个getter/setter.\n 在getter/setter内部去操作（读/写）data中对应的属性.\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/269a41d94026401154fa2c7ef4622dd4.png)\n\noptions是Vue的配置对象的意思\n\nvm._data实际上就是我们传给它的data\n\n所以以下这两种表达方式都是可 以的\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/fbbb9b7c13d0bd8dd327d76f3e1de1e8.png)\n\nvm.data是用的数据代理\n\n数据代理图示：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/1c8e5f21a4f2e46ae2f54195bcf0aa6d.png)\n\n### 1.7 事件处理\n\n#### 1.7.1 事件的基本使用：\n\n1. 使用v-on:xxx或@xxx绑定事件，其中xxx是事件名：\n2. 事件的回调需要配置在methods对象中，最终会在vm上：\n3. methods中配置的函数，不要用箭头函数！否则this就不是vm了：\n4. methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件实例对象：\n5. @click=\"demo”和@click=\"demo($event)\"效果一到，但后者可以传参\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/fba9f249fe24e98a469b6660e127918d.png)\n\n在button中，绑定一个v-on指令，在vue实例中添加一个新属性，methods，在里面添加方法，：\n\n```java\n<body>\n    <div id=\"root\">\n        <h1>{{name}}\n        </h1>\n\n        <button v-on:click=\"clickme\">别点我</button>\n    </div>\n\n\n</body>\n<script type=\"text/javascript\">\n\n    new Vue(\n        {\n            el: '#root',\n            data: {\n                name: '桃桃'\n            },\n            methods:{\n                clickme(){\n                    alert('让你别点，你个小坏蛋')\n                }\n            }\n        }\n    )\n\n</script>\n```\n\n此时在页面中点击按钮，就会弹出弹框\n\n如果我们在方法中添加一个参数，\n\n```java\nclick(a){\nconsole.log(a);\n}\n```\n\n在页面中点击时，发现打印在控制台的是点击事件\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/edd7678b052bbab151ffae20d317865e.png)\n\n这是老师以前讲的事件event（建议这部分去视频里听一下，因为我以前没学过，肯定讲不明白这个是什么东西，这个在视频的p14 事件处理中）\n\n我们把参数改为event，打印event.target这个是打印出事件触发的元素，也就是我们的button标签\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/7e3086c5751ad75ea067cf1a2f3123a3.png)\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/17ed57423d65da7a162710510ff43a3d.png)\n\n注意，所有被vue管理的函数不可以用箭头函数\n\n>简写 v-on简写成@ v-on:click @click\n\n如果想要传参的话，就在click后双引号里方法名后加括号，里面写参数，不传参可以 不加括号\n\n```java\n<button v-on:click=\"clickme('hello')\">别点我</button>\n```\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/dd354e86acfb398579268dce16ca7830.png)\n\n当然，也可以直接传已定义的变量\n\n```java\n<button v-on:click=\"clickme(name)\">别点我</button>\n```\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/f3c7459dadcd94f79c88e0ff57a02ba3.png)\n\n这样的话，就把之前的event搞丢了，可以在括号中添加$event来接受事件\n\n#### 1.7.2 事件修饰符\n\nVue中的事件修饰符：\n\n1. prevent:阻止默认事件（常用）\n\n```java\n<a href=\"www.baidu.com\" @click=\"sum\">点我</a>\n```\n\n正常点击这个按钮的时候，会先触发sum方法，然后跳转页面，如果我们不想a标签触发其默认事件（访问链接），我们可以在click后添加prevent,就不会访问了\n\n```java\n<a href=\"www.baidu.com\" @click.prevent=\"sum\">点我</a>\n```\n\n2.stop:阻止事件冒泡（常用）：\n\n当存在标签嵌套，且内外的标签都有调用的事件时，点击里面的标签，会像冒泡一样，触发外面标签的事件：\n\n```java\n<div @click=\"sum2\">\n<button  @click=\"sum\">点我</button>\n</div>\n```\n\n如以上的代码，点击按钮时，会先触发sum方法，然后冒泡触发sum2方法，如果外面像阻止冒泡，可以在里面的click后添加.stop以阻止事件冒泡\n\n3.once:事件只触发一次（常用）：\n\n这个就很好理解了，事件只触发一次\n\n后面三个不常用，我没怎么听懂，有学习需要的建议原视频\n\n4.capture:使用事件的捕获模式：\n 5.self:只有event.target是当前操作的元素时才触发事件：\n 6.passive:事件的默认行为立即执行，无需等待事件回调执行完毕：\n\n如果需要多个修饰符，比如既要阻止冒泡，又要阻止默认行为，可以@click.prevent.stop这代表先阻止默认行为，再阻止冒泡。实际上他们哪个先阻止，效果是一样的\n\n#### 1.7.3 键盘事件\n\nkeydown，按下去就触发事件\n\nkeyup，按下去，抬上来之后才出发事件\n\nevent:当前事件\n\nevent.target：当前事件操作的元素\n\nevent.target.value 这是这个例子中input的value\n\n```java\n<input @keyup='print'>\n\nprint(event){\nconsole.log(event.target.value);\n}\n```\n\n效果：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/1ac05d361db65d828e8bd0eea6d43424.png)\n\n那问题来了，如果我们不想每次按键的时候都在控制台输出，而是按特定的案件才会输出，怎么办呢\n\n我们知道每一个按键都有一个keyCode值（没事，我也是才知道），我们可以先在控制台输出一下\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/fd53da13ea089ad4f401dc8a7345cc65.png)\n\n可以看到，每次按完按键都会输出按键对应的键码，\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/2e8d70763955c9c57ddc2074eebdef85.png)\n\n我们输入回车，发现对应的键码是13，所以我们可以在方法中添加一个校验，如果触发当前事件的按键键码不是13，就不执行，这样，就只有回车时才会打印了。\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/21ecd26588bd0887d63c4067eced7532.png)\n\n实际上，以上操作可以直接在@keyup后加.enter来完成：\n\n```java\n<input @keyup.enter='print'>\nprint(event){\nconsole.log(event.target.value);\n}\n```\n\n这里的enter是回车键的别名，@keyup.enter='print’的意思是按下enter键后会触发print方法\n\n键盘的每一个按键，除了键码外也有自己对应的名字，keyu后可以添加每一个按键的名字\n\n我们可以这样获取当前按键的名字和键码：\n\n```java\nprint(event) {\n   console.log(event.key,event.keyCode);\n       }\n```\n\n.key就是按键的名字\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/aa1c7db6c9e641ac6026c4a264107a5f.png)\n\n如果要按下ctrl键触发，可以写@keyup.Control或者@keyup.17\n\n如果要求按下ctrl+y触发，我们可以写@keyup.ctrl.y\n\n这里的ctrl是别名\n\n注意项：\n\n1. \n <p>Vue中常用的按键别名：<br>\n   回车=&gt;enter<br>\n   删除=&gt;delete(捕获“删除”和“退格”键)<br>\n   退出=&gt;esc<br>\n   空格=&gt;space<br>\n   换行=&gt;tab<br>\n   上=&gt;up<br>\n   下=&gt;down<br>\n   左=&gt;1eft<br>\n   右=&gt;right</p>\n2. \n Vue未提供别名的按键，可以使用按键原始的key值去绑定，但由两个单词组成的要注意要转为kebab-case(短横线命名)\n3. \n <p>系统修饰键（用法特殊）：ctrl、alt、shift、meta(win)<br>\n   (I).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。<br>\n   (2).配合keydown使用：正常触发事件。</p>\n4. \n 也可以使用keyCode去指定具体的按键（不推荐）\n5. \n Vue.config.keyCodes.自定义键名=键码，可以去定制按键别名\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/91f83970a59e341f88c82853550d96a5.png)\n\n### 1.8 计算属性\n\n我们现在要完成一个需求，就是在两个input框中分别填写姓和名，要求自动在后面拼写出完整的姓名\n\n为了横向对比，我们分别用双大括号，methods，和计算属性完成这个需求\n\n#### 1.8.1 双大括号\n\n这个就太简单了\n\n直接上代码\n\n```java\n<body>\n    <div id=\"root\">\n姓：<input v-model=\"firstName\"><br/>\n名：<input v-model=\"lastName\"><br/>\n全名：<span>{{firstName}}+{{lastName}}</span>\n    </div>\n</body>\n<script type=\"text/javascript\">\n\n    new Vue(\n        {\n            el: '#root',\n            data: {\n                firstName: '',\n                lastName:''\n            }\n        }\n    )\n\n</script>\n```\n\n#### 1.8.2 methods\n\n可以在插值语法中调用方法，然后在方法中返回\n\n注意，如果在双大括号中的方法不加（），在页面中显示的是方法体，加了（）之后，返回的才是方法中return的值，这和之前的绑定事件不一样\n\n```java\n<body>\n    <div id=\"root\">\n姓：<input v-model=\"firstName\"><br/>\n名：<input v-model=\"lastName\"><br/>\n全名：<span>{{fullname()}}</span>\n\n    </div>\n\n\n</body>\n<script type=\"text/javascript\">\n\n    new Vue(\n        {\n            el: '#root',\n            data: {\n                firstName: '',\n                lastName:''\n            },\n            methods: {\n                fullname(){\n                    return this.firstName+this.lastName\n                }\n            }\n        }\n    )\n\n</script>\n```\n\n#### 1.8.3 computed 计算属性\n\n计算属性：\n 1,定义：要用的属性不存在，要通过己有属性计算得来。\n 2,原理：底层借助了Objcet.defineproperty方法提供的getter和setter。\n 3.get函数什么时候执行？\n (1).初次读取时会执行一次。\n (2).当依赖的数据发生改变时会被再次调用。\n 4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。\n 5.备注：\n 1,计算属性最终会出现在vm上，直接读取使用即可。\n 2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。\n\n当我们需要的数据是从两个已有的属性中计算得来的，这个计算得来的新属性就被称作计算属性\n\n```java\n<script type=\"text/javascript\">\n    new Vue(\n        {\n            el: '#root',\n            data: {\n                firstName: '',\n                lastName: ''\n            },\n            computed: {\n                fullname: {\n                    get() {\n                        return this.firstName + '-' + this.lastName\n                    }\n                }\n            }\n        }\n    )\n\n</script>\n```\n\ncomputed中的都是计算属性，和data很像，但是有get和set方法，底层是Objcet.defineproperty实现的，然后插值模板中直接写属性名就可以 了： {<!-- -->{fullname}}\n\n#### 1.8.4 计算属性的简写\n\n当某一个计算属性只有get，没有set的时候，可以简写成函数的样子\n\n```java\n<script type=\"text/javascript\">\n    new Vue(\n        {\n            el: '#root',\n            data: {\n                firstName: '',\n                lastName: ''\n            },\n            computed: {\n                fullname: function(){       //这一行也可以写成  fullname(){             \n                        return this.firstName + '-' + this.lastName            \n                }\n            }\n        }\n    )\n\n</script>\n```\n\n当然不要看到他长得像函数，就把他当成函数了，在{<!-- -->{}}中使用的时候，还是不能添加括号的。\n\n### 1.9 监视属性\n\n**推荐插件**\n\nVue 3 Snippets 会提示vue代码\n\n#### 1.9.1 watch 监视属性\n\n就是添加了一个新的配置项，watch，\n\n当watch中监视的数据发生改变时，就会调用watch中的方法\n\n直接引出watch中的方法，handler：\n\n```java\n<body>\n    <div id=\"root\">\n        姓：<input v-model=\"firstName\"><br />\n        <button @click=\"firstName++\">点我</button>\n    </div>\n\n\n</body>\n<script type=\"text/javascript\">\n\n    new Vue(\n        {\n            el: '#root',\n            data: {\n                firstName: 1\n            },\n            watch: {\n                firstName: {\n                    handler() {\n                        console.log(\"firstname被改了\")\n                    }\n\n                }\n            }\n        }\n    )\n\n</script>\n```\n\n在页面中点击按钮修改firstName的值的时候，就会调用watch中的handler方法\n\nhandler可以接收两个参数，第一个是修改后的数据，第二个是修改前的数据：\n\n```java\nhandler(newvalue,oldvalue) {\n         console.log(\"firstname被改了\" +newvalue+\"   \"+oldvalue)\n   }\n```\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/363067d8263559daf4150a402f9534bd.png)\n\nwatch是在数据被修改之后，才会触发，如果在配置项中添加一个immediate属性，就会在一开始加载页面的时候，就触发一次：\n\n```java\nwatch: {\n\tfirstName: {\n             handler() {\nimmediate:true，\nconsole.log(\"firstname被改了\")\n                    }\n\n                }\n```\n\n同时，计算属性中的数据也可以在watch中被监视，使用方法相同 。\n\n除了直接在vue()中配置以外，watch还可以在vue实例中手动配置：\n\n```java\n<script type=\"text/javascript\">\n\n    var vm = new Vue(\n        {\n            el: '#root',\n            data: {\n                firstName: 1\n            }\n        }\n    )\n    vm.$watch('firstName', {\n        handler(newvalue, oldvalue) {\n            console.log(\"firstname被改了\" + newvalue + \"     \" + oldvalue)\n        }\n    })\n\n</script>\n```\n\n记得在vm.$watch()中，firstName要添加单引号，这是因为js中对象（还是变量？我不太清楚）需要用单引号表示，我们在vue中没有添加单引号是因为我们简写了。\n\n#### 1.9.3 深度监视\n\n事情是这样的，当我们date中存储一个对象number，里面有数据a和b，我们改变这个a的值时，想要监视a的变化，而不是监视整个number的变化，该怎么做呢\n\n```java\n<div id=\"root\">\n{{number.a}}\n<button  @click=\"number.a++\">点我增加</button>\n    </div>\n    <script type=\"text/javascript\">\n        new Vue({\n            el:'#root',\n            data:{\n               number:{\n                a:1,\n                b:1\n               }\n            \n            },\n            watch:{\n                'number.a':{\n                    handler(a,b){\n                        console.log(\"我又被改了\"+a+b);\n                    }\n                }\n            }\n        }       \n        )\n    </script>\n```\n\n没错，方法就是直接使用number.a，但是注意，我们在number.a边上添加了单引号，这是为什么呢。\n 实际上，我们在使用这些变量名时都是引用的key，在语法规范中，key就是要添加单引号，但当只有一个单词时，在vue框架中可以省略这个单引号，但是当不是一个单词时，就要把单引号重新加上\n\n那如果我们想要当number中的a或者b任意一个改变了，就检测到number，我们该怎么做呢\n\n```java\nwatch:{\n                'number':{\n                    handler(a,b){\n                        console.log(\"我又被改了\"+a+b);\n                    }\n                }\n            }\n```\n\n我们发现，直接使用number，不起作用。\n\n实际上，number是这个对象的key，number后面的大括号实际上是这个对象的地址值，我们这样写，监视的就是对象的地址值，a变了，b变了，但是地址值是不会变的。\n\n如何让watch监视number中的值呢，我们在watch的number中添加一个配置项deep：\n\n```java\nwatch:{\n                number:{\n                    deep:true,\n                    handler(a,b){\n                        console.log(\"我又被改了\"+a+b);\n                    }\n                }\n            }\n```\n\n这样就会监视number中的数据的改变\n\n#### 1.9.4 监视的简写\n\n当你的监视项只有一个handler时，就可以简写，就好像计算属性，当只有get方法的时候，就可以简写\n\n```java\n//原来的\nwatch:{\n                number:{\n                    handler(a,b){\n                        console.log(\"我又被改了\"+a+b);\n                    }\n                }\n            }\n//修改后的：\n watch:{\n                number(a,b){\n                    \n                        console.log(\"我又被改了\"+a+b);\n                    }\n            }\n```\n\n或者，使用$f符添加，和之前的一样\n\n```java\nvm.$watch('number',{\n            deep:true,\n            handler(a,b){\n                console.log(\"我被修改啦\"+a+b)\n            }\n        })\n```\n\n或者简写模式：\n\n```java\nvm.$watch('number',function(a,b){\n                console.log(\"我被修改啦\"+a+b)\n            }\n        )\n```\n\n#### 1.9.5 computed和watch的区别\n\n总结：\n computed和watch之间的区别：\n 1 computed能完成的功能，watch都可以完成。\n 2 watch能完成的功能，computed.不一定能完成，例如：watch可以进行异步操作。\n\n两个重要的小原则：\n\n1. 所有被Vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象。\n2. 所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等），最好写成箭头函数，这样this的指向才是vm或组件实例对象。\n\n### 1.8 class和style样式\n\n#### 1.8.1 class样式\n\n我们使用:class来绑定动态的样式\n\n```java\n<div id=\"root\">\n        <!-- 字符串写法，适用于：样式的类名不确定，需要动态指定 -->\n        <div class=\"basic\" :class=\"mood\">{{number.a}}</div>\n        <!-- 数组写法，适用于：要绑定的样式个数不确定，名字也不能确定 -->\n        <div class=\"basic\" :class=\"moodArr\">{{number.b}}</div>\n        <!-- 对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 -->\n        <div class=\"basic\" :class=\"moodObj\">{{number.b}}</div>\n\n    </div>\n...\ndata:{\n               number:{\n                a:1,\n                b:2,\n                \n               },\n               mood:'happy',\n               moodArr:['happy'],\n               moodObj:{\n                happy:true\n               }\n            },\n```\n\n肯定的不需要改变的样式就放在class中，需要变化的就放在:class中\n\n#### 1.8.2 style样式\n\n正常的内联style样式：\n\n```java\n<div class=\"basic\" style=\"background-color:red\">测试</div>\n···\n\n使用动态的style样式\n​```html\n        <div class=\"basic\" :style=\"styleObj\">{{number.b}}</div>\n...\ndata:{\n               styleObj:{\n                backgroundColor:'red'\n               }\n            },\n```\n\n在style前面添加一个:就可以了，和class一样\n\n总结：\n 绑定样式：\n 1 c1ass样式\n 写法：c1ass=“xxx”xxx可以是字符串、对象、数组。\n 字符串写法适用于：类名不确定，要动态获取。\n 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。\n 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。\n 2 style样式\n :style=”{fontsize:Xxx)“其中xxx是动态值。\n :style=”[a,b]\"其中a、b是样式对象。\n\n### 1.9 条件渲染\n\n**v-show**\n\n```java\n<h1 v-show=\"true\"></h1>\n```\n\n当v-show后面的双引号中可以是true，false，1===3（false），或者是一个data中的变量a：\n\n```java\n<h1 v-show=\"a\"></h1>\n...\ndata:{\na:true\n}\n```\n\n**v-if**\n\n```java\n<h1 v-if=\"true\"></h1>\n```\n\nv-show是节点还在，只是动态的控制他的隐藏或者显示，而v-if是把整个节点全都弄没了\n\n**v-else-if****v-else**\n\n```java\n<h1 v-if=\"n===1\">1</h1>\n        <h1 v-else-if=\"n===2\">2</h1>\n        <h1 v-else-if=\"n===3\">3</h1>\n        <h1 v-else>4</h1>\n```\n\n这四个需要连在一起，不可以被打断\n\n后面的用的比较多\n 当我有三个相同判断条件的想简写：\n\n```java\n<h1 v-if=\"n===1\">1</h1>\n        <h1 v-if=\"n===1\">2</h1>\n        <h1 v-if=\"n===1\">3</h1>\n```\n\n如上，三个的判断条件都是一样的，该如何简化呢，第一反应肯定是在外面包上一个div：\n\n```java\n<div v-if=\"n===1\">\n\t\t<h1>1</h1>\n        <h1>2</h1>\n        <h1>3</h1>\n</div>\n```\n\n但是这样会破坏我们页面的结构，比如我们要找body下的h1，就找不到了，所以我们可以使用另外一个标签：template\n\n```java\n<template v-if=\"n===1\">\n\t\t<h1>1</h1>\n        <h1>2</h1>\n        <h1>3</h1>\n</template>\n```\n\n这个标签不会破坏页面的结构，但是template只能和v-if配合使用，不能和v-show配合使用\n\n### 1.10 列表渲染\n\n#### 1.10.1 基本列表\n\n\n**v-for** 类似于for循环，\n 当我们想要实现类似于下图的效果时，肯定是不能写死数据的，这就要我们通过遍历的方式显示数据![img](https://img-blog.csdnimg.cn/c65cde1b0acc4bc69f0defd7340acf6e.png)\n\n```java\n<!-- 遍历数组 -->\n      在遍历数组时，数组元素后面的一个参数，是遍历时的key值，因为我们这里没有自定义key，所以默认是012\n      <ul>\n        <li v-for=\"(person,b) in persons\">\n          {{b}}--{{person.name}}--{{person.age}}\n        </li>\n      </ul>\n      <!-- 遍历对象 -->\n      遍历对象时，括号中第一个参数是对象中键值对的值，第二个参数是键值对的键，第三个参数是这个这条遍历的数据的key\n      <ul>\n        <li v-for=\"(value,key,b) in car\">{{b}}--{{key}}--{{value}}</li>\n      </ul>\n      遍历字符串时，括号中第一个参数是字符串这个位置的值，第二个参数是这个这条遍历的数据的key\n      <!-- 遍历字符串 -->\n      <ul>\n        <li v-for=\"(value,key) in str\">{{key}}--{{value}}</li>\n      </ul>\n      \n\n...\n data: {\n          persons: [\n            { id: \"001\", name: \"ice\", age: \"13\" },\n            { id: \"002\", name: \"peach\", age: \"12\" },\n          ],\n          car: {\n            speed: \"20km/h\",\n            year: \"2014\",\n          },\n          str: \"i am a word\",\n        },\n```\n\n\n展示效果：![img](https://img-blog.csdnimg.cn/8f4801beaac34ab296556baf10b4faf2.png)\n 我们要求，每一个遍历的数据都需要一个独有的key，在第一个例子中，可以这样写\n\n```java\n<ul>\n        <li v-for=\"(person,index) in persons\" :key=\"person.id\">\n         {{index}}--{{person.name}}--{{person.age}}\n        </li>\n      </ul>\n```\n\n也可以直接写：key=“index”,这就代表默认的索引就是我们要的key\n 具体关于key的下一节讲\n\n遍历指定次数：\n\n```java\n<ul>\n        <li v-for=\"(number,index) in 5\" :key=\"index\">\n         {{number}}--{{index}}\n        </li>\n      </ul>\n```\n\n\n![img](https://img-blog.csdnimg.cn/75312af0fc254fd38c16efc1c89f8ca5.png)\n\n#### 1.10.2 key的原理和使用\n\n面试题：react、vue中的key有什么作用？(key的内部原理)\n\n\n1. 虚拟D0M中key的作用：\n    key是虚拟DoM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DoM】,\n    随后Vue进行【新虚拟DoM】与【旧虚拟DoM】的差异比较，比较规则如下：\n<li>对比规则：\n    (1).旧虚拟DoM中找到了与新虚拟DoM相同的key:\n    a.若虚拟D0M中内容没变，直接使用之前的真实D0M!\n    b.若虚拟D0M中内容变了，则生成新的真实D0M,随后替换掉页面中之前的真实D0M。\n    (2).旧虚拟DoM中未找到与新虚拟DoM相同的key\n    创建新的真实DOM,随后渲染到到页面。</li>\n<li>用index作为key可能会引发的问题：\n    1,若对数据进行：逆序添加、逆序删除等破坏顺序操作：\n    会产生没有必要的真实D0M更新==&gt;界面效果没问题，但效率低。\n    2.如果结构中还包含输入类的D0M:\n    会产生错误D0M更新=&gt;界面有问题。</li>\n<li>开发中如何选择key?:\n    1.最好使用每条数据的唯一标识作为key,比如id、手机号、身份证号、学号等唯一值。\n    2.如果不存在对数据的逆序添加、逆序刚除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。![img](https://img-blog.csdnimg.cn/2798684230a744b4a78324b16c496307.png)</li>\n\n#### 1.10.3 列表过滤（查询效果）\n\n\n\n实现如下效果：![img](https://img-blog.csdnimg.cn/724a75a704144227b071238a8ce0a8c2.png)![img](https://img-blog.csdnimg.cn/af144456465441a5ba73afae8ad035e1.png)\n 两种方法：\n 1watch监视：\n 注意点：\n\n1. 使用一个数组persnsOfSearch来接受过滤后返回的值\n2. 在watch中添加一个immediate，已确保一开始的时候就运行一次watch来显示数据\n3. indexOf显示方法参数在字符串中第一次出现的索引，不存在的返回-1，如果方法参数是''空字符串，返回0\n\n```java\n<body>\n    <div id=\"root\">\n        <label>姓名：</label><input v-model=\"name\">\n        <ul>\n            <li v-for=\"(person) in persnsOfSearch\">\n                {{person.name}}--{{person.age}}\n            </li>\n        </ul>\n    </div>\n</body>\n<script type=\"text/javascript\">\n\n    var vm = new Vue(\n        {\n            el: '#root',\n            data: {\n                name: '',\n                persnsOfSearch: [],\n                persons: [{ id: '001', name: 'ice', age: '17' }, { id: '002', name: 'ipeach', age: '18' }, { id: '003', name: 'icepeach', age: '19' }]\n            },\n            watch: {\n                name: {\n                    immediate: true,\n                    handler(newValue, oldValue) {\n                        this.persnsOfSearch= this.persons.filter((p) => {\n                            return p.name.indexOf(newValue) != -1\n                        })\n                    },\n                }\n            }\n        }\n    )\n\n</script>\n```\n\n使用计算属性实现：\n\n```java\n<body>\n    <div id=\"root\">\n\n        <label>姓名：</label><input v-model=\"name\">\n        <ul>\n            <li v-for=\"(person) in persnsOfSearch\">\n               {{person.name}}--{{person.age}}\n            </li>\n        </ul>\n    </div>\n</body>\n<script type=\"text/javascript\">\n\n    var vm = new Vue(\n        {\n            el: '#root',\n            data: {\n                name:'',\n                \n                persons: [{ id: '001', name: 'ice', age: '17' }, { id: '002', name: 'ipeach', age: '18' }, { id: '003', name: 'icepeach', age: '19' }]\n            },\n            computed:{\n                persnsOfSearch(){\n                    return this.persons.filter((p) => {\n                            return p.name.indexOf(this.name) != -1\n                        })\n                } \n            }\n        }\n    )\n\n</script>\n```\n\n可以看到，使用computes明显要更简单一些，所以当computed和watch都可以实现某个功能时，使用computed更好一些\n\n#### 1.10.4 排序\n\n还是在computed中排序\n 注意点：\n\n\n1. 在计算属性中，先过滤，后排序，把过滤好的数据暂时存到一个数组中，然后排序，再返回\n2. 使用sort(a,b)的方法来排序：\n    若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。\n    若 a 等于b，则返回 0。\n    若 a 大于 b，则返回一个大于 0 的值。\n    简单点就是：比较函数两个参数a和b，返回a-b 升序，返回b-a 降序\n    效果：![img](https://img-blog.csdnimg.cn/ccdd95362917472e9feeb44355a966ea.png)\n\n```java\n<body>\n    <div id=\"root\">\n\n        <label>姓名：</label><input v-model=\"name\">\n        <button @click=\"sortType = 0\">原顺序</button>\n        <button @click=\"sortType = 1\">降序</button>\n        <button @click=\"sortType = 2\">升序</button>\n        <ul>\n            <li v-for=\"(person) in persnsOfSearch\">\n                {{person.name}}--{{person.age}}\n            </li>\n        </ul>\n\n    </div>\n</body>\n<script type=\"text/javascript\">\n\n    var vm = new Vue(\n        {\n            el: '#root',\n            data: {\n                name: '',\n                sortType: 0,//0 原顺序 1 降序 2 升序\n                persons: [{ id: '001', name: 'ice', age: '17' }, { id: '002', name: 'ipeach', age: '18' }, { id: '003', name: 'icepeach', age: '19' }]\n            },\n            computed: {\n                persnsOfSearch() {\n                    const arr = this.persons.filter((p) => {\n                        return p.name.indexOf(this.name) != -1\n                    })\n                    if (this.sortType) {\n                        arr.sort((p1, p2) => {\n                            return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age\n                        })\n                    }\n                    return arr;\n                }\n            }\n        }\n    )\n\n</script>\n```\n\n#### 1.10.5 监视数据改变的原理\n\nVue监视数据的原理：\n\n1. vue会监视data中所有层次的数据。\n2. 如何监测对象中的数据\n    通过setter实现监视，且要在new Vue时就要传入要检测的数据\n    (1).对象中后追加的属性，Vue默认不做响应式处理\n    (2).如需给后添加的属性做响应式，请使用如下API:\n    Vue.set(target,propertyName/index,value)或者\n    vm.$set(target,propertyName/index,value)\n<li>如何监测数组中的数据？\n    通过包裹数组更新元素的方法实现，本质就是做了两件事：\n    (1).调用原生对应的方法对数组进行更新。\n    (2).重新解析模板，进而更新页面。</li>\n<li>在Vue修改数组中的某个元素一定要用如下方法：\n    1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()\n    2.Vue.set()或者vm.s e t ( ) 特别注意： V u e . s e t ( ) 和 v m . set() 特别注意：Vue.set()和vm. set()特别注意：Vue.set()和vm.set()不能给vm或vm的根数据对象添加属性！！</li>\n\n### 1.11 获取表单数据\n\n朋友们，这个很简单，我直接上总结了\n 还可以参考官方这部分教程，例子要全一些： [表单输入绑定](https://v2.cn.vuejs.org/v2/guide/forms.html)\n 收集表单数据：\n\n1. ,则v-model收集的是value值，用户输入的就是value值。\n2. ,则v-model收集的是value值，且要给标签配置value值。\n3. \n\n1.没有配置input的value属性，那么收集的就是checked(勾选or未勾选，是布尔值)\n 2.配置input的value属性：\n (1)v-model的初始值是非数组，那么收集的就是checked(勾选or未勾选，是布尔值)\n (2)v-mode1的初始值是数组，那么收集的的就是va1ue组成的数组\n\n备注：v-mode1的三个修饰符：\n 1azy:失去焦点再收集数据\n number:输入字符串转为有效的数字\n trim:输入首尾空格过滤\n\n### 1.12 过滤器\n\n过滤器在vue3中已经被取消了，而且过滤器能实现的功能，computed，methods之类的基本都能实现，所以简单概括\n 过滤器：\n 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。\n 语法：\n\n1. 注册过滤器：Vue.filter(name,callback)或new Vue{filters:({}】\n2. 使用过滤器：{<!-- -->{xxx|过滤器名}}或v-bind:属性=“xxx | 过滤器名”\n    备注\n3. 过滤器也可以接收额外参数、多个过滤器也可以串联\n4. 并没有改变原本的数据，是产生新的对应的数据\n\n### 1.13 内置指令\n\n#### 1.13.1 v-text\n\n我们学过的指令：\n v-bind:单向绑定解析表达式，可简写为：xxx\n v-mode:双向数据绑定\n v-for：遍历数组/对象/字符串\n v-on：绑定事件监听，可简写为\n v-if：条件渲染（动态控制节点是否存存在）\n v-else：条件渲染（动态控制节点是否存存在）\n v-show:条件渲染（动态控制节点是否展示）\n v-text指令：\n 1.作用：向其所在的节点中谊染文本内容。\n 2.与插值语法的区别：V-text会替换掉节点中的内容，{<!-- -->{xx}}则不会。\n\n#### 1.13.2 v-html指令\n\n1.作用：向指定节点中谊染包含html结构的内容。\n 2.与插值语法的区别\n (1).v-html会替换掉节点中所有的内容，{<!-- -->{xx}}则不会.\n (2).v-html可以识别html结构.\n 3.严重注意：v-htm1有安全性问题！！！！\n (1).在网站上动态渲染任意HTML是常危险的，容易导致XSS政击。\n (2).一定要在可信的内容上使用v-html,永不要用在用户提交的内容上！\n\n#### 1.13.3 v-cloak指令\n\nv-cloak指令（没有值）：\n\n1. 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性.\n2. 使用css配合v-cloak可以解决网速慢时页面展示出{<!-- -->{xx}}的问题。\n\n```java\n<style>\n[v-cloak]{\ndispaly:none\n}\n</style>\n...\n<h2 v-cloak>{{}}</h2>\n```\n\n#### 1.13.4 v-once\n\n需求：如果我们想要展示某一个数据的初识值，即使数据被改变也只展示初识值，就可以使用v-once\n\n```java\n<h1 v-once>{{time}}</h1>\n```\n\n\n![img](https://img-blog.csdnimg.cn/77b1af8ca7ae443c9f7f732a01e5478f.png)\n\n1. v-once所在节点在初次动态渲染后，就视为静态内容了。\n2. 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。\n\n### 1.13.5 v-pre指令\n\n1.跳过其所在节点的编译过程。\n 2.可利用它跳过过没有使用指令语法、没有使用插值语法的节点，会加快编译。\n\n就是说标签上加了这个之后，就不会再编译这一个标签了,所以只要我们用到了插值，指令就不要用这个\n\n```java\n<h2 v-pre>你好</h2>\n<h2 v-pre>当前的值是：{{n}}</h2>\n```\n\n\n![img](https://img-blog.csdnimg.cn/8045707cb3cb4f63a111f10b4e1d807a.png)\n\n#### 1.13.6 自定义指令\n\n\n各位好啊，自定义指令的教程较为复杂，我有些犯懒了，这里就直接贴上老师的笔记了：![img](https://img-blog.csdnimg.cn/4bd1a9f43c5141078b9d560962b0985b.png)\n\n### 1.14 生命周期\n\n\n\n\n分开的截图（为了让您看的更清晰一些）：![img](https://img-blog.csdnimg.cn/d54e4d8f86234f9ea76013389a7ba743.png)![img](https://img-blog.csdnimg.cn/f9672ea505f54577b84556e20730e264.png)\n 完整图：![img](https://img-blog.csdnimg.cn/f92274f0cd994e05a808f0487e340748.png#pic_center)\n\n首先生命周期说的是Vue的生命周期而不是vm的生命周期\n vm的一生(vm的生命周期)：\n 将要创建===>调用beforeCreatei函数。\n 创建完毕===>调用created函数。\n 将要挂载===>调用beforeMount函数。\n (重要)挂载完毕===>调用mountedi函数。=======>【重要的钩子】\n 将要更新===>调用beforeUpdatei函数。\n 更新完毕===>调用updated函数。\n (重要)将要销毁===>调用beforeDestroyi函数。=====&gt;【重要的钩子】\n 销毁完毕==>调用destroyed函数。\n\n人生最重要的时刻：出生（mounted时候，我们一上来要做的事情都放在这）和将要离开的时候（beforeDestory 关闭你以前订阅的消息，关闭定时器，删除浏览记录之类的）\n\n## 2 组件\n\n好耶，我们终于进入第二章了！前面学了那么久，竟然还只是第一张，我真的栓Q，还好坚持到现在。\n 学完组件，就开始学脚手架了，激动的嘞~\n\n我们要搞懂，什么是组件，为什么要用组件\n\n### 2.1 模块和组件，模块化和组件化\n\n\n传统的写页面的方式：\n 写html，写css，写js，然后写新的页面时，复制相同的css，js代码，再加上自己的代码![img](https://img-blog.csdnimg.cn/e4552a181b25402f8b40870a52674924.png)**2023**了，谁还用传统方式编程啊（md，我就是）\n\n模块：\n\n1. 理解：向外提供特定功能的js程序，一般就是一个js文件\n2. 为什么：js文件很多很复杂\n3. 作用：复用js,简化js的编写，提高js运行效率\n\n组件：\n\n1. 理解：用来实现局部特定)功能效果的代码集合(html/css/js/image.)\n2. 为什么：一个界面的功能很复杂\n3. 作用：复用编码，简化项目编码，提高运行效率\n\n模块化：当应用中的js都以模块来编写的，那这个应用就是一个模块化的应用。\n\n组件化：当应用中的功能都以组件的方式来编写，那这个应用就是一个组件化的应用。\n\n### 2.2 非单文件组件\n\n#### 2.2.1 基本使用\n\n创建组件的api：Vue.extend({})\n 大括号里面，几乎和我们之前写vm一样，该data就data，该methods就methods\n 但是不能用el哦\n\nVue中使用组件的三大步骤：\n 一、 定义组件（创建组件）\n 二、 注册组件\n 三、 使用组件（写组件标签）\n 一、如何定义一个组件？\n 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别：\n 区别如下：\n\n1. el不要写，为什么？\n    最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。\n<li>data必须写成函数，为什么？\n    避免组件被复用时，数据存在引用关系。\n    备注：使用template可以配置组件结构。\n    二、如何注册组件？\n    1.局部注册：靠new Vue的时候传入components选项(只在这一个实例里生效)\n    2.全局注册：靠Vue.component(‘组件名’，组件)\n    三、\n    编写组件标签：</li>\n\n```java\n<body>\n\t\t\n\t\t<div id=\"root\">\n\t\t\t<hello></hello>\n\t\t\t<hr>\n\t\t\t<h1>{{msg}}</h1>\n\t\t\t<hr>\n\t\t\t<!-- 第三步：编写组件标签 -->\n\t\t\t<school></school>\n\t\t\t<hr>\n\t\t\t<!-- 第三步：编写组件标签 -->\n\t\t\t<student></student>\n\t\t</div>\n\n\t\t<div id=\"root2\">\n\t\t\t<hello></hello>\n\t\t</div>\n\t</body>\n\n\t<script type=\"text/javascript\">\n\t\tVue.config.productionTip = false\n\n\t\t//第一步：创建school组件\n\t\tconst school = Vue.extend({\n\t\t\ttemplate:`\n\t\t\t\t<div class=\"demo\">\n\t\t\t\t\t<h2>学校名称：{{schoolName}}</h2>\n\t\t\t\t\t<h2>学校地址：{{address}}</h2>\n\t\t\t\t\t<button @click=\"showName\">点我提示学校名</button>\t\n\t\t\t\t</div>\n\t\t\t`,\n\t\t\t// el:'#root', //组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器。\n\t\t\tdata(){\n\t\t\t\treturn {\n\t\t\t\t\tschoolName:'江南大学',\n\t\t\t\t\taddress:'无锡'\n\t\t\t\t}\n\t\t\t},\n\t\t\tmethods: {\n\t\t\t\tshowName(){\n\t\t\t\t\talert(this.schoolName)\n\t\t\t\t}\n\t\t\t},\n\t\t})\n\n\t\t//第一步：创建student组件\n\t\tconst student = Vue.extend({\n\t\t\ttemplate:`\n\t\t\t\t<div>\n\t\t\t\t\t<h2>学生姓名：{{studentName}}</h2>\n\t\t\t\t\t<h2>学生年龄：{{age}}</h2>\n\t\t\t\t</div>\n\t\t\t`,\n\t\t\tdata(){\n\t\t\t\treturn {\n\t\t\t\t\tstudentName:'桃桃',\n\t\t\t\t\tage:18\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t\n\t\t//第一步：创建hello组件\n\t\tconst hello = Vue.extend({\n\t\t\ttemplate:`\n\t\t\t\t<div>\t\n\t\t\t\t\t<h2>你好啊！{{name}}</h2>\n\t\t\t\t</div>\n\t\t\t`,\n\t\t\tdata(){\n\t\t\t\treturn {\n\t\t\t\t\tname:'Tom'\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t\n\t\t//第二步：全局注册组件\n\t\tVue.component('hello',hello)\n\n\t\t//创建vm\n\t\tnew Vue({\n\t\t\tel:'#root',\n\t\t\tdata:{\n\t\t\t\tmsg:'你好啊！'\n\t\t\t},\n\t\t\t//第二步：注册组件（局部注册）\n\t\t\tcomponents:{\n\t\t\t\tschool,\n\t\t\t\tstudent\n\t\t\t}\n\t\t})\n\n\t\tnew Vue({\n\t\t\tel:'#root2',\n\t\t})\n\t</script>\n```\n\n#### 2.2.2 注意项\n\n几个注意点：\n\n1. 关于组件名:\n    一个单词组成：\n    第一种写法(首字母小写)：school\n    第二种写法(首字母大写)：School\n    多个单词组成：\n    第一种写法(kebab-case命名)：my-school\n    第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)\n    备注：\n    (1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。\n    (2).可以使用name配置项指定组件在开发者工具中呈现的名字。\n\n```java\n//定义组件\n\t\tconst s = Vue.extend({\n\t\t\tname:'peach',\n\t\t\ttemplate:`\n\t\t\t\t<div>\n\t\t\t\t\t<h2>学校名称：{{name}}</h2>\t\n\t\t\t\t\t<h2>学校地址：{{address}}</h2>\t\n\t\t\t\t</div>\n\t\t\t`,\n\t\t\tdata(){\n\t\t\t\treturn {\n\t\t\t\t\tname:'尚硅谷',\n\t\t\t\t\taddress:'北京'\n\t\t\t\t}\n\t\t\t}\n\t\t})\n```\n\n之后，开发者工具中显示的名字就是peach了\n 2. 关于组件标签:\n 第一种写法：<school></school>\n 第二种写法：<school/>\n 备注：不用使用脚手架时，会导致后续组件不能渲染。\n\n1. 一个简写方式：\n    const school = Vue.extend(options) 可简写为：const school = options\n\n#### 2.2.3 嵌套组件\n\n实际上，嵌套组件就是前两节的使用，只不过是在创建一个组件时，本身再添加之前创建的组件，没有什么其他的东西，很多同学觉得困难，是因为前两节没学好\n\n```java\n<body>\n\t\t<!-- 准备好一个容器-->\n\t\t<div id=\"root\">\n\t\t\t\n\t\t</div>\n\t</body>\n\n\t<script type=\"text/javascript\">\n\t\tVue.config.productionTip = false //阻止 vue 在启动时生成生产提示。\n\n\t\t//定义student组件\n\t\tconst student = Vue.extend({\n\t\t\tname:'student',\n\t\t\ttemplate:`\n\t\t\t\t<div>\n\t\t\t\t\t<h2>学生姓名：{{name}}</h2>\t\n\t\t\t\t\t<h2>学生年龄：{{age}}</h2>\t\n\t\t\t\t</div>\n\t\t\t`,\n\t\t\tdata(){\n\t\t\t\treturn {\n\t\t\t\t\tname:'尚硅谷',\n\t\t\t\t\tage:18\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t\n\t\t//定义school组件\n\t\tconst school = Vue.extend({\n\t\t\tname:'school',\n\t\t\ttemplate:`\n\t\t\t\t<div>\n\t\t\t\t\t<h2>学校名称：{{name}}</h2>\t\n\t\t\t\t\t<h2>学校地址：{{address}}</h2>\t\n\t\t\t\t\t<student></student>\n\t\t\t\t</div>\n\t\t\t`,\n\t\t\tdata(){\n\t\t\t\treturn {\n\t\t\t\t\tname:'尚硅谷',\n\t\t\t\t\taddress:'北京'\n\t\t\t\t}\n\t\t\t},\n\t\t\t//注册组件（局部）\n\t\t\tcomponents:{\n\t\t\t\tstudent\n\t\t\t}\n\t\t})\n\n\t\t//定义hello组件\n\t\tconst hello = Vue.extend({\n\t\t\ttemplate:`<h1>{{msg}}</h1>`,\n\t\t\tdata(){\n\t\t\t\treturn {\n\t\t\t\t\tmsg:'欢迎来到尚硅谷学习！'\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t\n\t\t//定义app组件\n\t\tconst app = Vue.extend({\n\t\t\ttemplate:`\n\t\t\t\t<div>\t\n\t\t\t\t\t<hello></hello>\n\t\t\t\t\t<school></school>\n\t\t\t\t</div>\n\t\t\t`,\n\t\t\tcomponents:{\n\t\t\t\tschool,\n\t\t\t\thello\n\t\t\t}\n\t\t})\n\n\t\t//创建vm\n\t\tnew Vue({\n\t\t\ttemplate:'<app></app>',\n\t\t\tel:'#root',\n\t\t\t//注册组件（局部）\n\t\t\tcomponents:{app}\n\t\t})\n\t</script>\n```\n\n#### 2.2.4 关于VueComponent\n\n1. school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。\n2. 我们只需要写或，Vue解析时会帮我们创建school组件的实例对象，\n    即Vue帮我们执行的：new VueComponent(options)。\n3. 特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！\n<li>关于this指向：\n    (1).组件配置中：\n    data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。\n    (2).new Vue(options)配置中：\n    data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</li>\n<li>VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。\n    Vue的实例对象，以后简称vm。</li>\n\n\n实际上 vc和vm是很像的双胞胎![img](https://img-blog.csdnimg.cn/667afa956ce74f799bca05f488a5c173.png)\n\n#### 2.2.5\n\n首先我们要知道一个前置知识:\n 这段看不懂的，需要去学一下es6中的高级js知识\n\n```java\n<script>\n//定义一个构造函数\n\t\t function Demo(){\n\t\t\tthis.a = 1\n\t\t\tthis.b = 2\n\t\t}\n\t\t//创建一个Demo的实例对象\n\t\tconst d = new Demo()\n\t\tconsole.log(Demo.prototype) //显示原型属性\n\t\tconsole.log(d.__proto__) //隐式原型属性\n\t\tconsole.log(Demo.prototype === d.__proto__)\n\t\t//程序员通过显示原型属性操作原型对象，追加一个x属性，值为99\n\t\tDemo.prototype.x = 99\n\n\t\tconsole.log('@',d) \n\t\t</script>\n```\n\n各位好，为了速成（做项目），我先不看视频了找个笔记去学一下\n 看的这个笔记： [笔记地址](http://t.csdn.cn/czoDQ)\n\n### 组件的自定义事件总结：\n\n\n![img](https://img-blog.csdnimg.cn/977a26305d6242a1917ade416c6167d9.png)\n\n### 全局事件总线\n\n\n![img](https://img-blog.csdnimg.cn/4496d361faef4add8f37b6c7e1e4eaf4.png)\n\n### 消息订阅\n\n\n![img](https://img-blog.csdnimg.cn/87b3486a11de4c16b9c5e3bd05b74d78.png)\n\n### axios\n\n\n![img](https://img-blog.csdnimg.cn/b3b5d3b5d5004e25acd86e68bbaa3373.png)\n 上图中2，3都是封装的1，如果1不能用了，2，3就都不能用了。\n 然后jQuery的80%内容都在封装dom，剩下的才是封装一些周边的东西，比如$.get,$.post\n 然后fetch和xhr是平级的，但是有两个问题，就是它封装了两次promise，所以要then两次才能拿到数据，然后它存在兼容性问题，比如ie浏览器就不可以使用fetch\n 综上，我们使用axios\n\n\n首先，我们写一个axios的get![img](https://img-blog.csdnimg.cn/3f5ed63a50ff44fd95cb3a129a54145b.png)\n\n运行的时候我们发现，哎呀妈呀跨域了，为什么会跨域呢，原因是我们违背了**同源原则****同源原则**：协议名，主机名，端口号\n 如下图，端口号对不上\n\n>实际上，我们请求之后，服务器是收到了请求，而且把数据返回了，但是浏览器一看，哎不同源，就把数据藏起来了\n\n\n![img](https://img-blog.csdnimg.cn/e0d9010878e0497e9cfff832d62ef896.png)\n\n\n解决方法\n 1cors:\n 在服务器里，返回数据的时候，添加了一些请求头，然后浏览器一看，你都这么表态了，那我就把数据给你吧。所以在服务器解决跨域问题才是真正的解决跨域![img](https://img-blog.csdnimg.cn/8e5449543c2d42978ca467f2940eb1b1.png)\n 2 jsonp\n 只能解决get请求的\n\n\n3 配置代理服务器![img](https://img-blog.csdnimg.cn/01f773b0650d4078b6779def03adad96.png)\n 使用方法：1 nginx(有点麻烦) 2 vue-cli\n\n\nvue-cli:\n 添加配置的第一种方法：![img](https://img-blog.csdnimg.cn/f9de45fcceb64da5ab98be4d22cb5c81.png)\n\n\nvue-cli添加配置的第er二种方法![img](https://img-blog.csdnimg.cn/832533819a044d5a9c7605b94d807745.png)\n\n加上·pathRewrite:{'/atguigu':''的意思是，在把请求中的atguigu去掉\n\n\n\n\n总结:![img](https://img-blog.csdnimg.cn/542276adefc14742ba5e1d95ce3cd877.png)![img](https://img-blog.csdnimg.cn/95768906557846a2b9457616c4a94c3a.png)![img](https://img-blog.csdnimg.cn/19d5d596528c4b889521e7e6b719879d.png)\n\n### vuex\n\n\n![img](https://img-blog.csdnimg.cn/d357e3baa23f437d9bec64c0a046c254.png)\n\n\n我们现在用的是vue2，所以要安装vuex3![img](https://img-blog.csdnimg.cn/dcfc8ffc1e1544d6b512da4f3f959bb3.png)\n\n","tags":["前端","vue.js","javascript"]},{"title":"安装完vue-cli后 在控制台输入vue 显示‘vue‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件。","url":"/2023/05/31/安装完vue-cli后 在控制台输入vue 显示‘vue‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件。/","content":"\n\n在使用 npm install -g @vue/cli 命令全局安装vue脚手架之后，关掉控制台重新打开后输入vue，显示\n 显示’vue’ 不是内部或外部命令，也不是可运行的程序或批处理文件\n\n\n\n\n\n\n**可能的解决办法：**\n 在控制台运行npm config list 查看npm配置信息\n 我的是这样：![img](https://img-blog.csdnimg.cn/e16d3c2df789452cbeb49e95e1ece622.png)\n 找到prefix属性后的地址，到文件夹对应地址看一下里面有没有vue\n 有的话，打开修改系统变量的地方：![img](https://img-blog.csdnimg.cn/16496742c2294be88c9efc82c3e3b055.png)![img](https://img-blog.csdnimg.cn/ad086eb541a64687ab5853a78e8d028e.png)\n 找到系统变量中的path![img](https://img-blog.csdnimg.cn/8f5e979deb1047a79966695d4cd1a3c4.png)\n 点击编辑，添加刚刚的地址![img](https://img-blog.csdnimg.cn/ef5894cd7e83435baf21a414a88236fe.png)\n\n","tags":["前端","vue.js","javascript"]},{"title":"linux学习之一配置环境篇","url":"/2023/05/31/linux学习之一配置环境篇/","content":"\n\n### 前言\n\n一般来说，配置linux有两种方法，第一种是在各大云服务厂商**购买云服务器**，在本地通过xshell等远程连接软件调用。很多厂商对学生是有补贴的，比如阿里云有学生试用三个月的活动，这一方法的**优点**是它最接近工作之后对linux服务器的使用。**缺点**是有可能需要一些小钱钱。\n\n第二种就是在**本地**通过**虚拟机安装linux**系统，然后ping通物理机和虚拟机，之后通过xshell连接虚拟机中的linux进行学习（当然也可以直接在虚拟机的linux通过命令行学习）。这一方法的优点是免费，缺点是可能需要折腾，会出现各种各样的问题\n\n### 我的配置\n\n我是使用的第二种方法，在本地安装虚拟机。\n\n我为大家准备了尚硅谷的安装文档，我就是完全这个安装文档来进行配置的。\n\n阿里云盘：https://www.aliyundrive.com/s/qeWFkJeKf6r\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/42dad5568bf83a6d184d21574a85b1ce.png)\n\n>为什么使用阿里云盘：因为阿里云盘不限制下载速度。\n\n虚拟机使用的是 **VMware Workstation**，这也是最常用的一个虚拟机，安装包也在上述云盘中，大家只需要根据安装教程安装，且最后在网上寻找一下密钥即可。\n\n寻找密钥方式如下（百度搜索）：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/a7e23604086f1f8f22530e2220ee18e5.png)\n\n同时linux的镜像文件也放在了云盘的文件中，各位只要根据文档安装配置，大概率是可以一次成功的。（笔者就是一次成功，没有什么波折）。\n\n根据文档安装完成图：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/952b3fea3c342d89848dc5552c3737ed.png)\n\n之后的学习就看下一篇：\n\nlinux学习之二基础命令篇\n\n","tags":["linux","学习","运维"]},{"title":"网站介绍","url":"/2023/05/12/网站介绍/","content":"\n> 从2022年中开始，就已经有了创建自己的博客网站的想法，那个时候就找了使用hexo创建网站的文章，但那个时候没研究过前端，进度一直卡在一开始的node安装上，折腾出一个开始页面之后就有些懈怠了，再之后就不了了之。\n\n> 后来也有几次建站的想法，但因为毕业，找工作等原因一直搁置了，直到现在。\n\n> 我的本科是机械，因为对计算机行业的兴趣，在女朋友的支持下，转行到了互联网行业，目前在南京从事java后端的岗位。\n\n> 网站使用hexo框架，主题是butterfly。\n\n>网站的主页封面是原神中的角色，宵宫，是我在这个游戏中最爱的角色。我很爱她对生活的热情，同时也希望自己能对生活抱有更多的期待。\n\n>网站的名字取自我的外号以及女朋友的外号。之后我会在这个网站持续更新技术博客以及生活中的所思所想。\n\n> 未完待续...\n","tags":["博客","网站"],"categories":["记录"]},{"title":"在列表中删除某一条数据（仅前端）","url":"/2023/04/25/在列表中删除某一条数据（仅前端）/","content":"\n\n在表格的最后一行添加一个按钮\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/b7d91017f066537a0733ccea0e463c72.jpeg)\n\n按钮的方法：\n\n```java\n<a onclick=\"delete(this)\"></a>\n<script>\nfunction delete(obj){\n$(obj).parent().parenet().remove();\n}</script>\n```\n\n","tags":["前端","html","javascript"]},{"title":"表格，表单等数字转换为千分位显示","url":"/2022/11/22/表格，表单等数字转换为千分位显示/","content":"\n\n#### 封装方法：\n\n```java\nfunction clearNum(obj) {\n    obj.value = (numberFormat(obj.value,2));\n}\n\nfunction numberFormat (number, decimals, decPoint, thousandsSep, roundtag) {\n    number = (number + '').replace(/[^0-9+-Ee.]/g, '')\n    roundtag = roundtag || 'ceil' // 'ceil','floor','round'\n    var n = !isFinite(+number) ? 0 : +number\n    var prec = !isFinite(+decimals) ? 0 : Math.abs(decimals)\n    var sep = (typeof thousandsSep === 'undefined') ? ',' : thousandsSep\n    var dec = (typeof decPoint === 'undefined') ? '.' : decPoint\n    var s = ''\n    var toFixedFix = function (n, prec) {\n        var k = Math.pow(10, prec)\n        return '' + parseFloat(Math[roundtag](parseFloat((n * k).toFixed(prec * 2))).toFixed(prec * 2)) / k\n    }\n    s = (prec ? toFixedFix(n, prec) : '' + Math.round(n)).split('.')\n    var re = /(-?\\d+)(\\d{3})/\n    while (re.test(s[0])) {\n        s[0] = s[0].replace(re, '$1' + sep + '$2')\n    }\n\n    if ((s[1] || '').length < prec) {\n        s[1] = s[1] || ''\n        s[1] += new Array(prec - s[1].length + 1).join('0')\n    }\n    return s.join(dec)\n}\n//复原为数字\nfunction numberFormatReduce(num){\n    if(num&&num!=undefined&&num!=null){\n        let _num = num;\n        _num = _num.toString();\n        _num = _num.replace(/,/gi,'');\n        return _num\n    }else{\n        return num\n    }\n}\n```\n\n#### 1 列表中的金额\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/00b491cc63d0dac75dc2f0fdd43f07e2.png)\n\n如图，将计划金额（万元）下的金额变为图中这样\n\n```java\n//给表格的tbody上添加一个id\n<table class=\"frog-table\">\n        <thead>\n        <tr>\n            <th>序号</th>\n            <th>立项号</th>\n            <th>项目建议书编号</th>\n            <th>项目名称</th>\n            <th>资金计划渠道</th>\n            <th>计划金额（万元）</th>\n            <th>项目状态</th>\n            <th>申报人</th>\n            <th>申报单位</th>\n            <th>立项时间</th>\n        </tr>\n        </thead>\n        <tbody id=\"cimp1_tbody\">\n        <c:forEach items=\"${}\" var=\"\" varStatus=\"\">\n            <tr target=\"\" rel=\"${}\" onclick=\"\">\n                <td></td>\n                <td></td>\n                <td></td>\n                <td></td>\n                <td></td>\n                <td >${projectamt}</td>\n                <td></td>\n                <td></td>\n                <td></td>\n                <td></td>\n            </tr>\n        </c:forEach>\n        </tbody>\n    </table>\n```\n\n在文档中添加一个当文件加载结束后运行的方法，或直接写在script的最后（写在最后是为了防止之前的方法中有要修改数据的）\n\n```java\n$(document).ready(function(){\n    //通过id找到tbody，遍历tr的每一行\n    $(\"#cimp1_tbody tr\").each(function(){\n        var trs = $(this).children();\n        //将这一行的第6个数字修改为千分符，并保留两位小数\n        trs.eq(5).text(numberFormat(trs.eq(5).text(),2))\n    });\n})\n```\n\n#### 2 表单中的金额\n\n同样在文档中添加一个当文件加载结束后运行的方法，或直接写在script的最后（写在最后是为了防止之前的方法中有要修改数据的）\n\n```java\n<script>\n    xxx\n    xxx\n    xxx\n    $('#id').val(numberFormat($('#id').val(),2))\n</script>\n```\n\n注：表单提交之前，要把表单中内容还原成正常的数字\n\n```java\n$('#id').val(numberFormatReduce($('#id').val(),2))\n```\n\n#### 3 在表格中的表单\n\n```java\n$(\"#tabfourtbody tr\").each(function () {// tabfourtbody是表格的tobody的id\n    var trs = $(this).children();\ntrs.find(\"input[name='updateamt']\").val((numberFormat(trs.find(\"input[name='updateamt']\").val(),2)));\n}\n```\n\n","tags":["前端","开发语言","javascript"]},{"title":"尚硅谷周阳spring cloud alibaba笔记","url":"/2022/09/22/尚硅谷周阳spring cloud alibaba笔记/","content":"\n\n【尚硅谷SpringCloud框架开发教程(SpringCloudAlibaba微服务分布式架构丨Spring Cloud)】https://www.bilibili.com/video/BV18E411x7eT?p=97&amp;vd_source=10e3dfac95ac3a6883b1f8a6c3bc65d5\n\n注：从spring cloud alibaba开始学习的，所以笔记只包含第十三章之后的部分\n 持续更新中…\n\n\n\n\n## nacos\n\n### 一、nacos的安装和运行\n\n访问官网https://nacos.io/zh-cn/\n\n在前往GitHub下方的xxx版本说明处点击进入下载页面\n\n\n点击releases![img](https://img-blog.csdnimg.cn/c8e3acbc41df4009b22e35f2b8e09ddd.png#pic_center)\n\n点击Tags可以选择不同的版本（注：不同的版本和spring boot会相互对应）\n\n\n![img](https://img-blog.csdnimg.cn/ed0e5e74da584a53ba00143fc0a7b3f0.png#pic_center)\n\n本课程使用的 是1.1.4版本\n\n下载完后解压安装包，在nacos文件夹中的bin文件夹中找到startup文件，双击运行。\n\n\n![img](https://img-blog.csdnimg.cn/bb5e34d8183c4852903eb97466b68c69.png#pic_center)\n\n访问localhost:8849/nacos，如果出现如下页面，则启动成功。\n\n\n![img](https://img-blog.csdnimg.cn/f8f0cadd6bf94cca837f5966773c8df7.png#pic_center)\n\n注：如果访问不成功，大概率是没有把默认的集结模式改成单例模式\n\n修改方法：\n\n [青戈程序员_nacos——服务注册_abjtxf的博客-CSDN博客](https://blog.csdn.net/abjtxf/article/details/126965089#comments_23365646)中3 nacos的启动\n\n登录账号密码都是nacos\n\n### 二、nacos服务注册\n\n使用之前写过的青戈程序员的方法，过程是一样的\n\n [青戈程序员_nacos——服务注册_abjtxf的博客-CSDN博客](https://blog.csdn.net/abjtxf/article/details/126965089#comments_23365646)\n\n","tags":["java","后端","微服务","spring cloud"]},{"title":"青戈程序员_nacos——服务注册","url":"/2022/09/21/青戈程序员_nacos——服务注册/","content":"\n\n传统大并发，高流量的场景不适合使用普通的技术，所以有了微服务\n\n链接：【最适合小白学习的SpringCloud微服务实战-全程敲代码纯干货分享】https://www.bilibili.com/video/BV1UG411u7XP?vd_source=10e3dfac95ac3a6883b1f8a6c3bc65d5\n\nnacos是springcloud的一个注册中心\n\n\n\n\n#### 1 组件下载\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/1c4b7901d1fbb73c24f7ae571c1599c8.png)\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/bdf80580b779707728eede6531b6caae.png)\n\n下载zip\n\n#### 2 创建服务\n\n##### 创建新项目\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/3f553190af975cff1e9701a72ab4d457.png)\n\n##### 选择组件（暂时选这个，之后再选其他的）\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/2a1d404aca9a5f50c92c91d33b3889e5.png)\n\n现在这个项目是作为父级，咱们可以把不必要的东西删掉\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/6222157a6a4c304b380d313953dea864.png)\n\n##### pom：add as maven project\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/0aa694cb7f96787ac506f304f14dac04.png)\n\ntest和start不需要可以删掉\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/f78bf040bbf15cac394f9c7e85a652ba.png)\n\n父级的作用就是控制版本，版本之间的对应关系一定要对，具体的对应关系可以在springcloudalibaba的GitHub/wiki中找到\n\n\n![img](https://img-blog.csdnimg.cn/0fd013119c294fb29248fe289f027f89.png#pic_center)\n\nps：\n\n##### 报错：Cannot resolve plugin org.springframework.boot:spring-boot-maven-plugin:2.7.3\n\n```java\nCannot resolve plugin org.springframework.boot:spring-boot-maven-plugin:2.7.3\n```\n\n因为springboot版本要和你的版本一样，解决方法：\n\n [(4条消息) Cannot resolve plugin org.springframework.boot:spring-boot-maven-plugin: 解决办法_大王我亲自来巡山的博客-CSDN博客](https://blog.csdn.net/weixin_43923436/article/details/121394457)\n\n我将我的版本改成了和自己一样的2.5.2\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/e1c5aeb218e7379c869a9929f62352dd.png)\n\n#### 3 nacos的启动\n\nnacos的bin文件夹中：cmd是Windows的启动脚本\n\n\n![img](https://img-blog.csdnimg.cn/667e0bd6489c4ced8e2e2886e1f468f9.png#pic_center)\n\n如果启动不成功，编辑模式打开cmd文件（就是用记事本或者其他软件打开）\n\n找到：set MODE=\"cluster\"\n\n将cluster修改为standalone\n\n==注：==好习惯：添加注释：rem cluster\n\n##### 运行成功画面：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/f4d5967e94ed15dcf9764c8fcdd04592.png)\n\n##### 浏览器访问\n\n访问这里的地址，访问成功了说明项目启动成功了：\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/e6fbea4a6fa8a6cea6bc866dab01c95c.png)\n\n\n成功：![img](https://img-blog.csdnimg.cn/img_convert/2b0a212115ae82571f8671ac381bb7a8.png)\n\n然后现在访问localhost:8848/nacos\n\n**访问成功**\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/81a8cf5614e3345f1ed2a2dec2f24ba7.png)\n\n默认的账号密码都是nacos\n\n#### 4 创建子模块\n\n使用maven新建子模块\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/cf638a3499cf847a336bd43cbf80171a.png)\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/0be666ddffe35b6d9618527452ca905b.png)\n\n#### 父级pom添加依赖管理\n\n<dependencyManagement>的左右是在父级添加过依赖后，子模块就不用再添加了\n\n这里对应的springboot的版本是2.4.2\n\n```java\n<dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>2020.0.1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>2021.1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n\n#### 5 子模块添加nacos依赖\n\n\n![img](https://img-blog.csdnimg.cn/a80567529fe34601bd85364fd1536abe.png#pic_center)\n\n在模块的pom中添加\n\n\n![img](https://img-blog.csdnimg.cn/802cb3aec070483e8247d3e213a93551.png#pic_center)\n\n```java\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n#### 6 新建启动类\n\n\n![img](https://img-blog.csdnimg.cn/8f94fc1483584b198d2a225057380f02.png#pic_center)\n\n发现无法添加注解：要在子模块加一个依赖包：web组件\n\n```java\n<dependency>\n     <groupId>org.springframework.boot</groupId>\n     <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n实体类：\n\n```java\n@SpringBootApplication\npublic class OrderApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderApplication.class, args);\n    }\n\n}\n```\n\n#### 7 启动启动类\n\n报错：\n\n```java\njava.lang.IllegalArgumentException: Param 'serviceName' is illegal, serviceName is blank\n```\n\n原因是什么什么识别不了，要在父级添加一个依赖\n\n```java\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bootstrap</artifactId>\n</dependency>\n```\n\n虽然引用了nacos，但是没有注册，在启动类添加注解：\n\n```java\n@EnableDiscoveryClient\n```\n\n#### 8 添加配置\n\nresource中添加配置文件bootstrap.yml\n\n```java\nserver:\n  port: 8000\n\nspring:\n  application:\n    name: service-order\n  cloud:\n    nacos:\n      server-addr: localhost:8848\n      discovery:\n        ephemeral: false #如果这里是一个短暂的实例,就用TRUE\n```\n\n#### 9 运行\n\n看到nacos registry, DEFAULT_GROUP service-order 2.0.0.1:8000 register finished\n\n说明注册成功\n\n打开nacos查看，发现也注册好了\n\n\n![img](https://img-blog.csdnimg.cn/2ae100fd77f3443488086c826983e8c9.png#pic_center)\n\n#### 10 多个运行\n\n##### 新建一个运行：\n\n设置端口号和允许并发运行\n\n\n![img](https://img-blog.csdnimg.cn/71a6cfe454bc4ca0918644751957672b.png#pic_center)\n\n##### 设置多个并发运行：\n\n\n![img](https://img-blog.csdnimg.cn/7601a0150ac64fc4ab9f60b8d144a237.png#pic_center)\n\n添加springboot\n\n\n![img](https://img-blog.csdnimg.cn/b2ab712e6a394240b169dfe4d5a48fe8.png#pic_center)\n\n就能看到了：\n\n\n![img](https://img-blog.csdnimg.cn/f6e01d27b6af4e29af68a20592d8a4e8.png#pic_center)\n\n三个都运行后：\n\n\n![img](https://img-blog.csdnimg.cn/a278e4cefca94ba7af73826d878a1022.png#pic_center)\n\n","tags":["java","spring boot","微服务"]},{"title":"现代设计方法作业3-19","url":"/2021/05/17/现代设计方法作业3-19/","content":"\n```java\nclc\nclear all\nsyms x1 x2;\np=0;\nq=0;\nX=[x1,x2];\nf=X(1)^2+X(2)^2-X(1)*X(2)-10*X(1)-4*X(2)+60;\nx0=[x1 x2]';\nfx1=diff(f,'x1');      %对x1求偏导数\nfx2=diff(f,'x2');      %对x2求偏导数\nx1=p;\nx2=q;                  %p,q是初始点的横纵坐标\nx=[x1,x2];\ng=[fx1 fx2]';         %g是梯度\nm=subs(fx1);\nn=subs(fx2);\ngz=[m n]';           %gz（g的值）是带入初始值的梯度\ngzm=(m^2+n^2)^(1/2);   %gzm(gz的模）\ni=0\n\nwhile gzm >= 0.01\ni=i+1\nsyms x1 x2;    \nX=[x1,x2];\nf=X(1)^2+X(2)^2-X(1)*X(2)-10*X(1)-4*X(2)+60;\nx0=[x1 x2]';\nfx1=diff(f,'x1');      %对x1求偏导数\nfx2=diff(f,'x2');      %对x2求偏导数\nx1=p;\nx2=q;                  %p,q是初始点的横纵坐标\ng=[fx1 fx2]'          %g是梯度\nm=subs(fx1);\nn=subs(fx2);\ngz=[m n]'            %gz（g的值）是带入初始值的梯度\ngzm=(m^2+n^2)^(1/2)%gzm(gz的模）\n\n\n%以上部分与while前相同\nif gzm < 0.01\n    break\nelse\n\ns=-(gz / gzm)         %s是探索方向\n\nsyms a                  %a是步长（学习率）\nx22=[p q]'-a*s;         %最终要求的值\nx1=x22(1); \nx2=x22(2);\nf22=subs(f)           \nf22w=diff(f22,'a')     %f22w是f22的微分\na=solve(f22w,a)          %求a的值\nx22=[p q]'-a*s\np=x22(1);\nq=x22(2);\nend\n\n\n\n\nend\ngzm\ni\nx22\nf=subs(f)\n```\n\n&nbsp;\n\n运行结果：\n\n```java\ni =\n\n     9\n\n \nx22 =\n \n 952390159855/119107138592\n2857170479565/476428554368\n \n \nf =\n \n139682782605677363693345/17460320570552487067648\n \n>>  952390159855/119107138592\n2857170479565/476428554368\n \n\nans =\n\n    7.9961\n\n\nans =\n\n    5.9971\n\n>> 139682782605677363693345/17460320570552487067648\n\nans =\n\n    8.0000\n```\n\n&nbsp;\n\n"}]